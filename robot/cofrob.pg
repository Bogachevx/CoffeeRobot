.***************************************************************************
.* === AS GROUP ===         : AS_09200022 2017/10/02 17:53
.* USER IF AS               : UAS09200022 2017/10/02 17:53
.* USER IF TP               : TP disconnected
.* USER IF AS MESSAGE       : MAS092022EN 2017/10/02 17:53
.* USER IF IPL              : WIP02030000 2014/12/15
.* ================
.* APPLICATION              : ADU00016 2017/9/1
.* No1 AMP                  : A004 A004 A004 A004  
.* No2 AMP                  : A004 A004 A004 A004  
.* No1 Monitor speed        : 100.00(%)
.* No2 Monitor speed        : 100.00(%)
.* SERVO I/F                : SRVIF-51
.* ARM-ID I/F               : ARMID-41 (No = 1)
.* ARM-ID BOARD             : 1GV-PV13 (No = 1)
.* ARM-ID I/F               : ARMID-41 (No = 2)
.* ARM-ID BOARD             : 1GV-PV13 (No = 2)
.* USER-COM I/F             : CSCOM-41
.* === Cubic-S ===
.* CPU-A(No = 1)            : CSUV010444408    2016/05/18 16:00 01b6:01b6
.* CPU-B(No = 1)            : CSUW010444408    2016/05/18 16:00 66d4:66d4
.* CPU-A(No = 2)            : CSUV010444408    2016/05/18 16:00 01b6:01b6
.* CPU-B(No = 2)            : CSUW010444408    2016/05/18 16:00 66d4:66d4
.* SAVED TIME               : 19-06-30 19:51:21
.***************************************************************************
.NETCONF     192.168.0.2,"",255.255.255.0,0.0.0.0,0.0.0.0,0.0.0.0,""
.PROGRAM adj_pos(.rno,.mode,.#inpos,.#outpos)
;-------------------------------- 
;機能：目標位置が動作範囲上下限を超えている場合に目標位置を動作範囲ギリギリに上書きする
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)、目標位置(実数配列)
;戻値：調整後位置(実数配列)
;--------------------------------
;    FOR .i=1 TO 6
;        .outpos[.i]=.inpos[.i]
;        .calpos[.i]=.inpos[.i]
;    END
DECOMPOSE .inpos[1] = .#inpos
DECOMPOSE .calpos[1] = .#inpos
DECOMPOSE .outpos[1] = .#inpos
.mergin = 0.1
;動作範囲取得
GETULIMIT 1: .#ulimit[robot_master]
GETLLIMIT 1: .#llimit[robot_master]
GETULIMIT 2: .#ulimit[robot_slave]
GETLLIMIT 2: .#llimit[robot_slave]
DECOMPOSE .ulim_master[1] = .#ulimit[robot_master]
DECOMPOSE .llim_master[1] = .#llimit[robot_master]
DECOMPOSE .ulim_slave[1] = .#ulimit[robot_slave]
DECOMPOSE .llim_slave[1] = .#llimit[robot_slave]
;XYZR1EXT1値から各軸値算出
IF .mode==mode_xyzr1ext1 THEN
IF .rno==robot_slave THEN
ZL3JNT 2: .#tpos=.inpos[1],#S_HERE(2),1;逆変換
ELSE
ZL3JNT 1: .#tpos=.inpos[1],#S_HERE(1),1;逆変換
END
DECOMPOSE .outpos[1] = .#tpos
DECOMPOSE .calpos[1] = .#tpos
END
;各軸値で動作範囲チェック
FOR .i = 1 TO 6
IF .rno==robot_slave THEN
IF .calpos[.i]>.ulim_slave[.i]-.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_slave[.i]-.mergin
END
.outpos[.i] = .ulim_slave[.i]-.mergin
END
IF .calpos[.i]<.llim_slave[.i]+.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_slave[.i]+.mergin
END
.outpos[.i] = .llim_slave[.i]+.mergin
END
ELSE
IF .calpos[.i]>.ulim_master[.i]-.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.ulim_master[.i]-.mergin
END
.outpos[.i] = .ulim_master[.i]-.mergin
END
IF .calpos[.i]<.llim_master[.i]+.mergin THEN
IF debug.prt.cmd==TRUE THEN
PRINT "adj_pos()-> OVERWRITE .rno=",.rno,", ",.outpos[.i],"->",.llim_master[.i]+.mergin
END
.outpos[.i] = .llim_master[.i]+.mergin
END
END
END
;各軸値からXYZR1EXT1値算出
IF .mode==mode_xyzr1ext1 THEN
POINT .temp = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
DECOMPOSE .outpos[1] = .temp
END
POINT .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
.END
.PROGRAM autostart.pc()
;-------------------------------- 
;機能：自動起動プログラム
;引数：無し
;戻値：無し
;--------------------------------
PRINT "TASKNO=",TASKNO,", autostart.pc() -> CALL noexist_init()"
CALL noexist_init
UTIMER @com_check_timer = 0
UTIMER @slowlimit_timer = 0
flg_exec_first_ = TRUE
SETAPPLIVER $appli_ver_tbl
data_execute = FALSE
flg_vchk_done = FALSE
flg_cvpc_stop = OFF;コンベア同期PC状態リセット
flg_cvpc_run = OFF;コンベア同期PC状態リセット
CALL cv_init;コンベア同期パラメータ初期化
IF SYSDATA(ZSIMENV)<>2 THEN
debug_status = -1
END
IF robot_status_ou==sta_exe OR robot_status_ou==sta_l2exe THEN
CALL updatel2l3info(TRUE,0,0,TRUE)
END
CALL resetstartinfo
CALL rebootsystem
.END
.PROGRAM before_exec(.ret)
;-------------------------------- 
;機能：実行前の処理
;戻値：成否
;-------------------------------- 
.ret = err_no_error
RETURN
.END
.PROGRAM bootpcprogram(.ret)
;-------------------------------- 
;PCプログラム再起動(PCプログラムは停止しない方針に変更)
;引数：無し
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;**********動作命令用*************
IF TASK(1005)<>1 THEN
UTIMER .@nowtime = 0
DO
PCEXECUTE 5: pccom,-1
IF UTIMER(.@nowtime)>.time_out THEN
.ret = err_pccom_start
CALL update_error(.ret)
RETURN
END
TWAIT 0.5
UNTIL TASK(1005)==1
END
;**********非動作命令用*************
IF TASK(1006)<>1 THEN
UTIMER .@nowtime = 0
DO
PCEXECUTE 6: pccompc,-1
IF UTIMER(.@nowtime)>.time_out THEN
.ret = err_pccom_start
CALL update_error(.ret)
RETURN
END
TWAIT 0.5
UNTIL TASK(1006)==1
END
.END
.PROGRAM caffeeh1()
sg1 = 0
sg2 = 0
sg3 = 0
sg4 = 0
sg5 = 0
SPEED spd ALWAYS
JMOVE #h1_home
JMOVE #h1_1
JMOVE #h1_2; Zahvat stakana
JMOVE #h1_3
JMOVE #h1_4
BREAK
sg1 = 1
WAIT sg2==1
sg3 = 1
JMOVE #h1_5
JMOVE #h1_6
;BREAK
JMOVE #h1_7
JMOVE #h1_8
JMOVE #h1_9
JMOVE #h1_10
JMOVE #h1_11
WAIT sg4==1
JMOVE #h1_10
JMOVE #h1_9
JMOVE #h1_8
JMOVE #h1_7
JMOVE #h1_6
JMOVE #h1_12
JMOVE #h1_13
JMOVE #h1_14
BREAK
sg5 = 1
JMOVE #h1_15
isready = TRUE
coffeemade = TRUE
.END
.PROGRAM caffeeh2()
sg1 = 0
sg2 = 0
sg3 = 0
sg4 = 0
SPEED spd ALWAYS
JMOVE #h2_home
JMOVE #h2_1
PRINT sg1
WAIT sg1==1
JMOVE #h2_2
BREAK
sg2 = 1
WAIT sg3==1
TYPE "2: go away"
JMOVE #h2_3
JMOVE #h2_4
JMOVE #h2_5
JMOVE #h2_6
JMOVE #h2_7
JMOVE #h2_8
JMOVE #h2_9
JMOVE #h2_10
IF $drink=="Espresso\n" THEN
JMOVE #h2_e1
JMOVE #h2_e2
TWAIT 0.5
JMOVE #h2_e3
JMOVE #h2_11
TWAIT 40
END
IF $drink=="Americano\n" THEN
JMOVE #h2_a1
JMOVE #h2_a2
TWAIT 0.5
JMOVE #h2_a3
JMOVE #h2_11
TWAIT 55
END
IF $drink=="Cappuccino\n" THEN
JMOVE #h2_c1
JMOVE #h2_c2
TWAIT 0.5
JMOVE #h2_c3
JMOVE #h2_11
TWAIT 40
END
IF $drink=="Latte\n" THEN
JMOVE #h2_l1
JMOVE #h2_l2
TWAIT 0.5
JMOVE #h2_l3
JMOVE #h2_11
TWAIT 30
END
sg4 = 1
WAIT sg5==1
SPEED 2 ALWAYS
JMOVE #h2_12
.END
.PROGRAM caffeepc()
port = 52000
ip[0] = 192
ip[1] = 168
ip[2] = 0
ip[3] = 100
max_length = 255
tout_open = 100000
tout_rec = 1
tout = 1
ret = 1
stopcycle = FALSE
isready = FALSE
CALL open_socket
IF sock_id<0 THEN
GOTO exit_end
END
aaa = 1
WHILE (aaa==1) DO
isready = FALSE
ret = 0
CALL tcprecv;Receiving instruction data from PC
TYPE $recv_buf[1]
IF ($recv_buf[1]!="000") THEN
$drink = $recv_buf[1]
MC execute caffeeh1
MC execute 2: caffeeh2
END
IF ($drink=="Espresso") THEN
i = 0;MC execute test1
END
IF ($drink=="Americano") THEN
i = 0;MC execute 2: test1
END
WAIT (isready==TRUE)
TYPE ("lol");
END
exit_end:
CALL close_socket
.END
.PROGRAM calvision(.rno,.id,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン計算実行
;引数：ロボット番号、ビジョンID()、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
SIGNAL -ix_result_vng[.rno]; ビジョンＮＧ信号初期化
;
IF debug.prt.visio==TRUE THEN
PRINT "calvision()->TASKNO=",TASKNO
PRINT "calvision()->ROBOT No.=",.rno
PRINT "calvision()->.id=",.id
PRINT "calvision()->.calpos=",.calpos
END
; ID変換
CALL convert_vid(mode_add,1,.id,.vid1);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
CALL convert_vid(mode_add,2,.id,.vid2);      calposに合わせてID変換 calpos=0:ID=1〜999, calpos=1:ID=1001〜1999, calpos=2:ID=2001〜2999
; 装置補正計測フラグONチェック
IF vequip_flg[.vid1]!=ON OR vequip_flg[.vid2]!=ON THEN
.ret = err_vis_lesspos
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
SIGNAL ix_result_vng[.rno]; ビジョンＮＧ信号ＯＮ
RETURN
END
;
NOEXIST_SET_R vc_chkflg[.id] = OFF
IF vc_chkflg[.id]<>OFF THEN
; 位置ズレチェック
.dist1 = DISTANCE(v_master[.vid1,1],vwork[.vid1,1]); 装置1点目の位置ズレ量
.dist2 = DISTANCE(v_master[.vid2,1],vwork[.vid2,1]); 装置2点目の位置ズレ量
NOEXIST_SET_R vc_poschk[.id] = 100
IF .dist1>vc_poschk[.id] OR .dist2>vc_poschk[.id] THEN; 閾値判定
.ret = err_vis_poschk
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN
END
; 距離ズレチェック
.dist1 = DISTANCE(v_master[.vid1,1],v_master[.vid2,1])
.dist2 = DISTANCE(vwork[.vid1,1],vwork[.vid2,1])
NOEXIST_SET_R vc_distchk = 5
IF ABS(.dist1-.dist2)>vc_distchk THEN
.ret = err_vis_distchk
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN
END
END
;第2、第3階層を探索
FOR .i = 1 TO data_l2num
FOR .j = 1 TO data_l3num[.i]
IF data_l3type[.i,.j]==l3type_move THEN
IF data_mode[.i,.j]==mode_jt THEN
;各軸値
ELSE
;変換値
IF .id==data_vision_id1[.i,.j] THEN; 計算実行する装置IDと動作の装置ID(DATA_VISION_ID)が一致
POINT .in_pos = TRANS(data_pos1[.i,.j],data_pos2[.i,.j],data_pos3[.i,.j],data_pos4[.i,.j],0,0); 変換値
CALL vcorrect_table(.&in_pos,.id,.&out_pos); 装置補正実行
DECOMPOSE .out_p[1] = .out_pos; 補正後の変換値分解
; 補正値を書き換え
data_pos1[.i,.j] = .out_p[1]
data_pos2[.i,.j] = .out_p[2]
data_pos3[.i,.j] = .out_p[3]
data_pos4[.i,.j] = .out_p[4]
data_pos5[.i,.j] = 0
data_pos6[.i,.j] = 0
END
END
END
END
END
; 実行後、装置補正計測結果のマスターを現在値で上書き
POINT v_master[.vid1,1] = vwork[.vid1,1]
POINT v_master[.vid2,1] = vwork[.vid2,1]
; 装置補正計測フラグOFF
vequip_flg[.vid1] = OFF
vequip_flg[.vid2] = OFF
CALL vlog_cal(.vid1,.vid2,1,0)
.END
.PROGRAM change_cvcoop(.rno,.cvno,.cvwork,.cvmode,.cvjt,.cvworkno,.ret)
;-------------------------------- 
;機能：コンベア番号取得
;引数：ロボット番号、同期コンベア番号、同期対象ワーク、同期開始/コンベア待ち/条件分岐
;戻値：同期コンベア軸、ワーク番号、成否
;-------------------------------- 
.ret = err_no_error
.cvworkno = FALSE
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_cv_setting
RETURN
END
IF (.cvno<>1 AND .cvno<>2) OR (.cvwork<>1 AND .cvwork<>2) THEN
.ret = err_cv_setting
RETURN
END
.cvjt = cv_coopjt[.rno,.cvno]
CALL cvaxis_check(.rno,.cvjt,.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
cv_coop_mode[.rno,.cvno] = .cvmode
cv_need[.rno,.cvno] = .cvwork
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
cv_need[.rno,.cvno] = FALSE
.ret = err_cvcoop
RETURN
END
TWAIT ascycle
UNTIL (cv_need[.rno,.cvno]==0)
IF cv_work[.cvno,.cvwork]==-.cvwork THEN
.ret = err_cv_nowork
RETURN
END
IF cv_work[.cvno,.cvwork]<1 OR cv_work[.cvno,.cvwork]>100 THEN
.ret = err_cvcoop
RETURN
END
.cvworkno = cv_work[.cvno,.cvwork]
;    CASE .cvmode OF
;        VALUE cv_mode_move:
;            ;CVCOOPJT .rno:.cvjt
;        VALUE cv_mode_wait,cv_mode_ifchk:
;            cv_work[.cvno,.cvwork] = 0
;    END
.END
.PROGRAM change_ms_mode(.timeout,.ret)
;-------------------------------- 
;機能：協調動作モードに移行
;引数：
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() MASTER-SLAVE MODE"
END
flg_req_mamode = TRUE
flg_slave_move = TRUE
UTIMER .@nowtime = 0
WHILE (1) DO
IF flg_slave_rdy==TRUE THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() SLAVE STATUS IS RDY! MASTER ROBOT CHANGE TO RDY TOO."
END
MASTER
GOTO check
END
IF (UTIMER(.@nowtime)>.timeout) THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() Cannot Slave robot change to RDY status."
END
.ret = err_srobot_time
RETURN
END
IF g_last_error<>err_no_error THEN
IF debug.prt.move==TRUE THEN
PRINT "->change_ms_mode() Detected error. g_last_error=",g_last_error
END
.ret = err_srobot_erro
RETURN
END
TWAIT ascycle
END
check:
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "->change_ms_mode() Cannot change MASTER-mode for MASTER_ROBOT"
RETURN
END
TWAIT ascycle
UNTIL (COOPSTATUS(1)==3)
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "->change_ms_mode() Cannot change SLAVE-mode for SLAVE_ROBOT"
RETURN
END
TWAIT ascycle
UNTIL (COOPSTATUS(2)==4)
.END
.PROGRAM check_disp_sock(.$buf,.flg_disp)
;-------------------------------- 
;機能：プロトコル詳細デバッグフラグ設定
;引数：受信文字列
;戻値：デバッグ文表示フラグ
;-------------------------------- 
.flg_disp = TRUE
IF debug.prt.proc==TRUE THEN
RETURN
END
IF TASKNO==1006 AND (INSTR(.$buf , "1017")<>0 OR INSTR(.$buf , "1001")<>0 OR INSTR(.$buf , "1015")<>0 OR INSTR(.$buf , "1005")<>0 OR INSTR(.$buf , "1006")<>0 OR INSTR(.$buf , "1010")<>0 OR INSTR(.$buf , "1011")<>0 OR INSTR(.$buf , "1018")<>0) THEN
.flg_disp = FALSE
END
.END
.PROGRAM check_exec_cmd(.cmd,.flg_exec_cmd)
;-------------------------------- 
;機能：コマンド実行制限
;引数：無し
;戻値：可否
;--------------------------------
.flg_exec_cmd = TRUE
IF (robot_mode==mode_tablet) AND (robot_mode_flg==FALSE) THEN
;タブレットモード(手動教示)OFF
CASE .cmd OF
VALUE cmd_exe_teach,cmd_exe_move:
;ティーチ系禁止
.flg_exec_cmd = FALSE
END
END
IF (robot_mode_flg<>FALSE) THEN
;タブレットモード(手動教示)/ダイレクトモードON
CASE .cmd OF
VALUE cmd_exe_gen,cmd_exe_start,cmd_exe_reset,cmd_exe_l2exe,cmd_exe_gravity,cmd_exe_vscalib,cmd_exe_vcalchk,cmd_exe_reboot,cmd_exe_cchkom,cmd_exe_calxom,cmd_exe_calyom:
;ティーチ系以外の動作系コマンド禁止
.flg_exec_cmd = FALSE
VALUE cmd_exe_teach,cmd_exe_move:
;ダイレクトモードON
;ティーチ系禁止
IF (robot_mode==mode_direct) THEN
.flg_exec_cmd = FALSE
END
VALUE cmd_exe_restart,cmd_set_home,cmd_set_zeroing,cmd_set_tool,cmd_set_handio,cmd_set_lowspar,cmd_set_lowspse,cmd_set_slowlim,cmd_set_intfpar,cmd_set_wspec,cmd_set_genopt:
;(非動作系)再開、設定2禁止
.flg_exec_cmd = FALSE
VALUE cmd_set_armslow,cmd_set_linkslo,cmd_set_l3lsp:
;Cubic-S用設定禁止
.flg_exec_cmd = FALSE
END
END
IF (SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON) AND (robot_mode_flg==FALSE) THEN
;実行中
CASE .cmd OF
VALUE cmd_exe_gen,cmd_exe_start,cmd_exe_reset,cmd_exe_l2exe,cmd_exe_gravity,cmd_exe_vscalib,cmd_exe_teach,cmd_exe_move,cmd_exe_vcalchk,cmd_exe_cchkom,cmd_exe_calxom,cmd_exe_calyom:
;動作系コマンド禁止
.flg_exec_cmd = FALSE
VALUE cmd_set_home,cmd_set_zeroing,cmd_set_tool,cmd_set_handio,cmd_set_lowspar,cmd_set_lowspse,cmd_set_slowlim,cmd_set_intfpar,cmd_set_wspec,cmd_set_wno,cmd_set_genopt,cmd_set_cvprm:
;(非動作系)設定2禁止
.flg_exec_cmd = FALSE
VALUE cmd_exe_restart,cmd_exe_io,cmd_exe_hand,cmd_exe_robotmo,cmd_exe_vision,cmd_exe_vlescal,cmd_exe_reboot:
;(非動作系)制御系
.flg_exec_cmd = FALSE
VALUE cmd_set_l2exetb,cmd_set_wset,cmd_set_l1info,cmd_set_l2info,cmd_set_l3info,cmd_set_winfo,cmd_set_step,cmd_set_steppos,cmd_set_stepifg,cmd_set_mcrpos:
;(非動作系)作業設定系
.flg_exec_cmd = FALSE
VALUE cmd_set_armslow,cmd_set_linkslo,cmd_set_l3lsp:
;Cubic-S用設定禁止
.flg_exec_cmd = FALSE
VALUE cmd_exe_cvmove,cmd_exe_cvset:
;コンベア同期関連禁止
.flg_exec_cmd = FALSE
END
END
IF (SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON) THEN
;AUTO中
CASE .cmd OF
VALUE cmd_set_pitch,cmd_set_tool,cmd_set_home,cmd_set_handio,cmd_set_lowspar,cmd_set_lowspse,cmd_set_zeroing:
;設定2禁止
.flg_exec_cmd = FALSE
VALUE cmd_set_slowlim,cmd_set_intfpar,cmd_set_genpara,cmd_set_wspec,cmd_set_genopt:
;設定2禁止
.flg_exec_cmd = FALSE
VALUE cmd_exe_gravity,cmd_exe_vscalib,cmd_exe_vlescal,cmd_exe_vcalchk,cmd_exe_cchkom,cmd_exe_calxom,cmd_exe_calyom,cmd_set_cvprm:
;設定3禁止
.flg_exec_cmd = FALSE
VALUE cmd_set_armslow,cmd_set_linkslo,cmd_set_l3lsp:
;Cubic-S用設定禁止
.flg_exec_cmd = FALSE
VALUE cmd_exe_cvmove,cmd_exe_cvset:
;コンベア同期関連禁止
.flg_exec_cmd = FALSE
END
END
IF robot_status_ou<>sta_nomove THEN
;停止（再開不可）中以外
CASE .cmd OF
VALUE cmd_set_wno:
;作業グループ番号設定禁止
.flg_exec_cmd = FALSE
END
END
.END
.PROGRAM check_exec_pg(.flg_exec_main)
;-------------------------------- 
;機能：動作プログラム実行要否判定
;引数：無し
;戻値：動作プログラム実行要否
;--------------------------------
.flg_exec_main = FALSE
;サイクルランプが落ちてる場合
IF (SWITCH(CS ,1)==OFF OR SWITCH(CS ,2)==OFF) THEN
.flg_exec_main = TRUE
RETURN
END
;要求ロボットモードと動作中のプログラムが異なる場合
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) AND (flg_main_run==TRUE) THEN
.flg_exec_main = TRUE
RETURN
END
;要求ロボットモードと動作中のプログラムが異なる場合
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) AND (flg_direct_run==TRUE) THEN
.flg_exec_main = TRUE
RETURN
END
.END
.PROGRAM check_holdpos(.rno,.ret)
;-------------------------------- 
;機能：現在位置と記録位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "check_home()-> .rno=",.rno
END
IF .rno==robot_master THEN
POINT .rno: .#pos = #S_HERE(1)
DECOMPOSE .rno: .buf1[1] = #rec_holdpos[1]
ELSE
POINT .rno: .#pos = #S_HERE(2)
DECOMPOSE .rno: .buf1[1] = #rec_holdpos[2]
END
DECOMPOSE .rno: .buf2[1] = .#pos
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
FOR .i = 1 TO .axis+2
IF .i<9 THEN
IF (.buf1[.i]-poslimit_restar<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_restar) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_holdpos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-poslimit_restar,"<",.buf2[.i],"<",.buf1[.i]+poslimit_restar
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_holdpos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-poslimit_restar,"<",.buf2[.i],"<",.buf1[.i]+poslimit_restar
END
.ret = err_bad_positio
RETURN
END
END
END
.END
.PROGRAM check_home(.rno,.ret)
;-------------------------------- 
;機能：現在位置とホーム位置比較
;引数：ロボット番号
;戻値：範囲内/範囲外=err_no_error/err_bad_position
;-------------------------------- 
.ret = err_bad_positio
IF debug.prt.cmd==TRUE THEN
PRINT "check_home()-> .rno=",.rno
END
.homeno = 1
POINT .rno: .#home = #HOME(.homeno)
IF .rno==robot_master THEN
POINT .#pos = #S_HERE(1)
ELSE
POINT .#pos = #S_HERE(2)
END
DECOMPOSE .buf1[1] = .#home
DECOMPOSE .buf2[1] = .#pos
FOR .i = 1 TO 6
IF (.buf1[.i]-poslimit_gen<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_gen) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....OK",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-poslimit_gen,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+poslimit_gen
END
IF .i==6 THEN
.ret = err_no_error
;ホーム1、ホーム2のどちらかにいればOKとする
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....NG",",.buf1[.i]-POSLIMIT_GEN=",.buf1[.i]-poslimit_gen,",.buf2[.i]=",.buf2[.i],",.buf1[.i]+POSLIMIT_GEN=",.buf1[.i]+poslimit_gen
END
GOTO 100
END
END
100
.homeno = 2
POINT .rno: .#home = #HOME(.homeno)
IF .rno==robot_master THEN
POINT .#pos = #S_HERE(1)
ELSE
POINT .#pos = #S_HERE(2)
END
DECOMPOSE .buf1[1] = .#home
DECOMPOSE .buf2[1] = .#pos
FOR .i = 1 TO 6
IF (.buf1[.i]-poslimit_gen<.buf2[.i]) AND (.buf2[.i]<.buf1[.i]+poslimit_gen) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....OK",",",.buf1[.i]-poslimit_gen,"<",.buf2[.i],"<",.buf1[.i]+poslimit_gen
END
IF .i==6 THEN
.ret = err_no_error
;ホーム1、ホーム2のどちらかにいればOKとする
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "check_pos()-> JTNUM=",.i,"....NG",",",.buf1[.i]-poslimit_gen,"<",.buf2[.i],"<",.buf1[.i]+poslimit_gen
END
RETURN
END
END
.END
.PROGRAM check_pos(.rno,.cmd,.ret)
;-------------------------------- 
;機能：位置チェック
;引数：ロボット番号、コマンド
;戻値：成否
;-------------------------------- 
.ret = err_bad_positio
CASE .cmd OF
VALUE cmd_exe_start,cmd_exe_gravity:
;原点の専用信号が割り付いていない場合はエラー
.dsig_home[1] = SYSDATA(DSIG.HOME1,robot_master)
.dsig_home[2] = SYSDATA(DSIG.HOME2,robot_master)
.dsig_home[3] = SYSDATA(DSIG.HOME1,robot_slave)
.dsig_home[4] = SYSDATA(DSIG.HOME2,robot_slave)
FOR .i = 1 TO 4
IF .dsig_home[.i]<>0 THEN
.home_sta[.i] = SIG(.dsig_home[.i])
ELSE
.home_sta[.i] = OFF
END
END
;原点位置からの開始のみ許容する
CASE .rno OF
VALUE robot_all:
IF (.home_sta[1] OR .home_sta[2]) AND (.home_sta[3] OR .home_sta[4]) THEN
.ret = err_no_error
END
VALUE robot_master:
IF (.home_sta[1] OR .home_sta[2]) THEN
.ret = err_no_error
END
VALUE robot_slave:
IF (.home_sta[3] OR .home_sta[4]) THEN
.ret = err_no_error
END
END
VALUE cmd_exe_restart:
;停止位置記憶有効フラグ
IF flg_enable_stop==TRUE THEN
;ホールド停止した時の位置からの開始のみ許容する
CASE .rno OF
VALUE robot_all:
CALL check_holdpos(robot_master,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL check_holdpos(robot_slave,.ret)
IF .ret<>err_no_error THEN
RETURN
END
VALUE robot_master:
CALL check_holdpos(robot_master,.ret)
VALUE robot_slave:
CALL check_holdpos(robot_slave,.ret)
END
END
END
CALL update_error(.ret)
.END
.PROGRAM check_vsl3data(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン補正設定有効・無効判定
;引数：第2階層番号、第3階層番号
;戻値：補正要否(TRUE:有効、FALSE:無効)
;-------------------------------- 
;ビジョン有効（初期値）
.ret = TRUE
IF debug.prt.visio==TRUE THEN
PRINT "check_vs_l3data()->DATA_VISION_ID1[",.l2num,",",.l3num,"]=",data_vision_id1[.l2num,.l3num]
PRINT "check_vs_l3data()->DATA_VISION_ID2[",.l2num,",",.l3num,"]=",data_vision_id2[.l2num,.l3num]
PRINT "check_vs_l3data()->DATA_VISION_ID3[",.l2num,",",.l3num,"]=",data_vision_id3[.l2num,.l3num]
END
;ビジョンIDが0
IF data_vision_id2[.l2num,.l3num]==0 AND data_vision_id3[.l2num,.l3num]==0 THEN
;ビジョン無効
.ret = FALSE
RETURN
END
IF debug.prt.visio==TRUE THEN
PRINT "check_vs_l3data()->DATA_ROBOTTYPE[",.l2num,",",.l3num,"]=",data_robottype[.l2num,.l3num]
END
;動作モードがXYZであることを確認
IF data_mode[.l2num,.l3num]<>mode_xyzr1ext1 THEN
.ret = FALSE
RETURN
END
.END
.PROGRAM chg_colcalflg(.flg)
;-------------------------------- 
;衝突検知感度自動調整設定変更
;引数：ON/OFF(OFF=0.ON=0以外、通信の場合ON=1、ASのON/TRUE=-1）
;戻値：無し（ASシステムから状態取得できない）
;--------------------------------
IF .flg==OFF THEN
;衝突検知感度自動調整設定OFF
flg_enable_colc = FALSE
COLCALOFF 1: 
COLCALOFF 2: 
ELSE
;衝突検知感度自動調整設定ON
flg_enable_colc = TRUE
COLCALON 1: 
COLCALON 2: 
END
.END
.PROGRAM chg_jt1rad(.jt,.jtans)
;-------------------------------- 
;機能：1軸の角度を0°〜360°内に変換
;引数：1軸値
;戻値：変換後の1軸値
;-------------------------------- 
IF .jt<0 THEN
.jtans = .jt+360
ELSE
IF .jt>360 THEN
.jtans = .jt-360
ELSE
.jtans = .jt
END
END
.END
.PROGRAM chg_move_param(.sp_mode,.sp,.acc,.dec,.accu,.ret)
;-------------------------------- 
;機能：動作パラメータ変更
;引数：絶対速度モード[0;OFF(%),1:ON(%),2:OFF(mm/sec),3:ON(mm/sec)]、速度、加速度、減速度、精度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL reset_mon_sp(TASKNO); モニタ速度を変更している場合は元に戻す
IF flg_slowlimit==TRUE THEN
IF UTIMER(@slowlimit_timer)<slowlimit_time THEN
IF TASKNO==1 THEN
ABS.SPEED 1:  ON
ELSE
ABS.SPEED 2:  ON
END
IF slowlimit_speed<slowlimit_spmin OR slowlimit_spmax<slowlimit_speed THEN
IF slowlimit_speed<slowlimit_spmin THEN
slowlimit_speed = slowlimit_spmin
ELSE
slowlimit_speed = slowlimit_spmax
END
END
CALL setl3speed(slowlimit_speed,TRUE)
IF debug.prt.move==TRUE THEN
PRINT "chg_move_param()-> START---SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
IF debug.prt.sp==TRUE THEN
PRINT "chg_move_param()-> -- SLOWSTART -- M.SPEED",SYSDATA(M.SPEED,TASKNO),"[%], P.SPEED",slowlimit_speed,"[mm/sec], TASKNO =",TASKNO,", L3NUM =",tmp_move_l3num[TASKNO]
END
GOTO jump
ELSE
IF debug.prt.move==TRUE THEN
PRINT "chg_move_param()-> DONE----SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
flg_slowlimit = FALSE
IF flg_exec_first_==TRUE THEN
flg_exec_first_ = FALSE
END
END
END
IF debug.prt.move==TRUE THEN
PRINT "chg_move_param()-> TASKNO=",TASKNO
END
CASE .sp_mode OF
VALUE 0,1:; 絶対速度指定OFF[%]
IF .sp<=0 OR .sp>130 THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
IF .sp_mode==0 THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%] ABS.SPEED OFF"
ELSE
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%] ABS.SPEED ON"
END
END
IF .sp_mode==0 THEN; 絶対速度指定OFF
IF TASKNO==1 THEN
ABS.SPEED 1:  OFF
ELSE
ABS.SPEED 2:  OFF
END
ELSE; 絶対速度指定ON
IF TASKNO==1 THEN
ABS.SPEED 1:  ON
ELSE
ABS.SPEED 2:  ON
END
END
IF SWITCH(ZUPSPEED)==FALSE AND .sp>100 THEN
.sp = 100
END
CALL setl3speed(0,TRUE)
SPEED .sp ALWAYS; 速度を設定
IF debug.prt.sp==TRUE THEN
PRINT "chg_move_param()-> M.SPEED",SYSDATA(M.SPEED,TASKNO),"[%], P.SPEED",.sp,"[%], TASKNO =",TASKNO,", L3NUM =",tmp_move_l3num[TASKNO]
END
END
VALUE 2,3:; 速度指定[mm/sec]
IF .sp<=0 THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
IF .sp_mode==0 THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[mm/sec] ABS.SPEED OFF"
ELSE
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[mm/sec] ABS.SPEED ON"
END
END
IF .sp_mode==2 THEN; 絶対速度指定OFF
IF TASKNO==1 THEN
ABS.SPEED 1:  OFF
ELSE
ABS.SPEED 2:  OFF
END
ELSE; 絶対速度指定ON
IF TASKNO==1 THEN
ABS.SPEED 1:  ON
ELSE
ABS.SPEED 2:  ON
END
END
;暫定消去(システム対応までR11?)	  IF SWITCH(ZUP2SPEED)==FALSE AND .sp>1500 THEN
IF .sp>1500 THEN
.sp = 1500
END
CALL setl3speed(0,TRUE)
SPEED .sp MM/S ALWAYS; 速度を設定
IF debug.prt.sp==TRUE THEN
PRINT "chg_move_param()-> M.SPEED",SYSDATA(M.SPEED,TASKNO),"[%], P.SPEED",.sp,"[mm/sec], TASKNO =",TASKNO,", L3NUM =",tmp_move_l3num[TASKNO]
END
END
END
;
jump:
IF .acc<=0 OR 130<.acc THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_accel"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change accel to ",.acc,"[%]"
END
IF SWITCH(ZUPSPEED)==FALSE AND .acc>100 THEN
.acc = 100
END
ACCEL .acc ALWAYS; 加速度を設定
END
;
IF .dec<=0 OR 130<.dec THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_decel"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change decel to ",.dec,"[%]"
END
IF SWITCH(ZUPSPEED)==FALSE AND .dec>100 THEN
.dec = 100
END
DECEL .dec ALWAYS; 減速度を設定
END
;
IF .accu<=0 THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_accuracy"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change accuracy to ",.accu,"[mm]"
END
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外,7:EXT1,8:EXT2]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
END
.END
.PROGRAM chg_sp(.sp,.ret)
;-------------------------------- 
;機能：速度変更
;引数：変更希望速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF .sp>0 THEN
IF flg_slowlimit==TRUE THEN
IF UTIMER(@slowlimit_timer)<slowlimit_time THEN
CALL setl3speed(slowlimit_speed,TRUE)
IF debug.prt.move==TRUE THEN
PRINT "chg_sp()-> START---SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "chg_sp()-> DONE----SPEED SLOWLIMIT_SPEED ALWAYS(MM/SEC)=",slowlimit_speed,",UTIMER(@SLOWLIMIT_TIMER)=",UTIMER(@slowlimit_timer),",SLOWLIMIT_TIME=",slowlimit_time
END
flg_slowlimit = FALSE
END
END
IF (.sp>safty_move_sp-1 AND .sp<safty_move_sp+1) OR (.sp>safty_lmove_sp-1 AND .sp<safty_lmove_sp+1) THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[mm/sec]"
END
IF TASKNO==1 THEN
ABS.SPEED 1:  ON
ELSE
ABS.SPEED 2:  ON
END
IF (.sp>safty_move_sp-1 AND .sp<safty_move_sp+1) THEN
CALL setl3speed(safty_move_sp,TRUE)
ELSE
CALL setl3speed(safty_lmove_sp,TRUE)
END
ELSE
IF .sp<=0 OR .sp>100 THEN
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
END
.ret = err_bad_speed
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", change speed to ",.sp,"[%]"
END
IF TASKNO==1 THEN
ABS.SPEED 1:  OFF
ELSE
ABS.SPEED 2:  OFF
END
CALL setl3speed(0,TRUE)
SPEED .sp ALWAYS
END
END
ELSE
IF debug.prt.move==TRUE THEN
PRINT "TASKNO=",TASKNO,", sp is invalid value. .sp=",.sp
END
END
.END
.PROGRAM chgprt()
;-------------------------------- 
;機能：デバッグ文表示設定切替
;引数：なし
;戻値：なし
;-------------------------------- 
CALL noexist_init
PRINT ""
PRINT "********************************************************"
PRINT "****  デバッグ表示設定  特殊反映  ************************"
PRINT "********************************************************"
PRINT ""
;CALL chgprtflg("sock.pg(PROTOCOL詳細のみ)設定",DEBUG.PRT.PROC)
CALL chgprtflg("act.pg(l2exeのみ)設定",debug.prt.l2exe)
CALL chgprtflg("move.pg(位置情報詳細のみ)設定",debug.prt.pos)
CALL chgprtflg("core.pg(再起動のみ)設定",debug.prt.reboo)
CALL chgprtflg("com.pg(外部制御盤のみ)設定",debug.prt.extio)
PRINT ""
PRINT "********************************************************"
PRINT "****  デバッグ表示設定　ファイル単位 *********************"
PRINT "********************************************************"
PRINT ""
CALL chgprtflg("act.pgファイル設定",debug.prt.act)
CALL chgprtflg("cmd.pgファイル設定",debug.prt.cmd)
CALL chgprtflg("main.pgファイル設定",debug.prt.main)
CALL chgprtflg("sub.pgファイル設定",debug.prt.sub)
CALL chgprtflg("gen.pgファイル設定",debug.prt.gen)
CALL chgprtflg("com.pgファイル設定",debug.prt.com)
CALL chgprtflg("sock.pgファイル設定",debug.prt.sock)
CALL chgprtflg("func.pgファイル設定",debug.prt.func)
CALL chgprtflg("vision.pgファイル設定",debug.prt.visio)
CALL chgprtflg("move.pgファイル設定",debug.prt.move)
.END
.PROGRAM chgprtflg(.$mes,.val)
;-------------------------------- 
;機能：デバッグ文表示設定変更、問合せ文字列生成、問合わせ発生、設定変更結果表示
;引数：表示文字列の一部
;戻値：操作対象フラグ
;-------------------------------- 
.ret = 0
IF .val==0 THEN
.$sta = "非表示"
ELSE
.$sta = "表示"
END
PROMPT "変更? "+.$mes+":[現在設定="+.$sta+"] (YES:1,NO:ENTER)",.ret 
IF .ret==1 THEN
IF .val==TRUE THEN
.val = FALSE
ELSE
.val = TRUE
END
IF .val==FALSE THEN
PRINT "---------------> [変更後設定=非表示]"
ELSE
PRINT "---------------> [変更後設定=表示]"
END
PRINT ""
ELSE
PRINT "---------------> 変更無し"
PRINT ""
END
.END
.PROGRAM chk_break(.l2num,.l3num,.bflag)
;-------------------------------- 
;機能：動作後BREAK有無確認
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：動作後BREAK有無
;-------------------------------- 
.bflag = FALSE; BREAK無
IF (.l3num+1)<=data_l3num[.l2num] THEN
.rno = data_robottype[.l2num,.l3num]; 動作ロボット番号取得
FOR .i = .l3num+1 TO data_l3num[.l2num]
; 次の動作までに協調開始または協調終了がある場合はBREAK有
IF data_l3type[.l2num,.i]==l3type_cstart OR data_l3type[.l2num,.i]==l3type_cend THEN
.bflag = TRUE
RETURN
END
; 次の動作までに並列開始または並列終了がある場合はBREAK有
IF data_l3type[.l2num,.i]==l3type_wstart OR data_l3type[.l2num,.i]==l3type_wend THEN
.bflag = TRUE
RETURN
END
; 次の動作までに条件分岐がある場合はBREAK有
IF data_l3type[.l2num,.i]==l3type_ifgoto THEN
.next_rno = data_robottype[.l2num,.i]
IF .rno==.next_rno THEN
.bflag = TRUE
RETURN
END
END
; 次の動作でアームが切り替わる場合はBREAK有(並列動作の時以外)
IF (data_l3type[.l2num,.i]==l3type_move) OR (data_l3type[.l2num,.i]==l3type_shift) THEN
.next_rno = data_robottype[.l2num,.i]
IF .rno==.next_rno THEN
RETURN
ELSE
IF (flg_slave_paral==FALSE AND TASKNO==robot_master) THEN
.bflag = TRUE
RETURN
END
END
END
; 次のマクロPG呼び出しでアームが切り替わる場合はBREAK有(並列動作の時以外)
IF data_l3type[.l2num,.i]==l3type_call THEN
.next_rno = data_robottype[.l2num,.i]
IF .rno==.next_rno THEN
RETURN
ELSE
IF (flg_slave_paral==FALSE AND TASKNO==.rno) THEN
.bflag = TRUE
RETURN
END
END
END
; 次の動作までに作業停止か作業終了がある場合はBREAK有
IF data_l3type[.l2num,.i]==l3type_return OR data_l3type[.l2num,.i]==l3type_stop THEN
.next_rno = data_robottype[.l2num,.i]
IF .rno==.next_rno THEN
.bflag = TRUE
RETURN
END
END
END
END
.END
.PROGRAM chk_cv_setting(.ret)
;-------------------------------- 
;機能：コンベア設定チェック
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF ZOPTION(6,1)<>0 AND ZOPTION(6,2)<>0 THEN
FOR .cvno = 1 TO 2
IF cv_coopjt[1,.cvno]<>0 AND cv_coopjt[2,.cvno]<>0 THEN
IF cv_coopjt[1,.cvno]==cv_coopjt[2,.cvno] THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
IF SYSDATA(DSIG.CVRESET,-1,cv_coopjt[1,.cvno])==0 THEN
.ret = err_cv_setting
RETURN
ELSE
IF cv_vision[.cvno]==1 THEN
.cvio = SYSDATA(DSIG.CVRESET,-1,cv_coopjt[1,.cvno])
CALL get_iotype(.cvio,.sigtype,.ret)
IF .sigtype<>io_int THEN
.ret = err_cv_setting
RETURN
END
END
END
ELSE
.ret = err_cv_setting
RETURN
END
ELSE
IF cv_coopjt[1,.cvno]<>0 THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
IF SYSDATA(DSIG.CVRESET,1,cv_coopjt[1,.cvno])==0 THEN
.ret = err_cv_setting
RETURN
ELSE
IF cv_vision[.cvno]==1 THEN
.cvio = SYSDATA(DSIG.CVRESET,1,cv_coopjt[1,.cvno])
CALL get_iotype(.cvio,.sigtype,.ret)
IF .sigtype<>io_int THEN
.ret = err_cv_setting
RETURN
END
END
END
ELSE
IF cv_coopjt[2,.cvno]<>0 THEN
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
IF SYSDATA(DSIG.CVRESET,2,cv_coopjt[2,.cvno])==0 THEN
.ret = err_cv_setting
RETURN
ELSE
IF cv_vision[.cvno]==1 THEN
.cvio = SYSDATA(DSIG.CVRESET,2,cv_coopjt[2,.cvno])
CALL get_iotype(.cvio,.sigtype,.ret)
IF .sigtype<>io_int THEN
.ret = err_cv_setting
RETURN
END
END
END
END
END
END
END
IF cv_vision[1]==1 THEN
IF cv_vision[2]<>0 THEN
.ret = err_cv_setting
RETURN
END
ELSE
IF cv_vision[2]==1 THEN
IF cv_vision[1]<>0 THEN
.ret = err_cv_setting
RETURN
END
END
END
IF z_vselect<>0 AND (cv_vision[1]<>0 OR cv_vision[2]<>0) THEN
.ret = err_cv_setting
END
ELSE
.ret = err_cv_setting
RETURN
END
.END
.PROGRAM chk_cycle_time()
;-------------------------------- 
;サイクルタイム計測(K-ROSET用)
;引数：無し
;戻値：無し
;-------------------------------- 
IF flg_cycle_time==FALSE THEN
IF SIG(ix_cycle_time) THEN
flg_cycle_time = TRUE
UTIMER .@cycle_time = 0
END
ELSE
IF SIG(-ix_cycle_time) THEN
flg_cycle_time = FALSE
TYPE 6: "cycle_time =",UTIMER(.@cycle_time)," sec"
END
END
.END
.PROGRAM chk_exe_staus(.ret)
;-------------------------------- 
;機能：作業実行中か判定
;引数：無し
;戻値：成否
;-------------------------------- 
.ret = err_no_error
FOR .rno = 1 TO 2
IF data_cur_l2rec[.rno]<>0 OR data_cur_l3rec[.rno]<>0 THEN
.ret = err_still_worki
RETURN
END
END
.END
.PROGRAM chk_extin(.status,.num)
;-------------------------------- 
;機能：外部制御盤入力信号状態チェック
;引数：無し
;戻値：信号状態(0:入力無し、1:入力有)、コマンド
;--------------------------------
.status = FALSE
FOR .i = 0 TO max_prm
$prm[TASKNO,.i] = ""
END
;操作パネルのティーチ／リピート入力が不正な場合は実行禁止
IF ((SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==ON) OR (SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==OFF)) AND SIG(extin_start_but)==ON THEN
CALL update_error(err_extio_unkno)
RETURN
END
.wait_extin_time = wait_extin_time
;STARTを先に押した場合だけSTOPが押されてるか確認する
;STOPが先に押されてる場合は停止指示の可能性があるので即次の処理に移る
IF SIG(extin_start_but)==ON THEN
UTIMER .@nowtime = 0
DO
IF SIG(extin_start_but)==ON AND SIG(extin_stop_butt)==ON THEN
IF robot_mode==mode_direct THEN
;ダイレクトモード中は実行禁止
RETURN
END
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF flg_extin_gen<>FALSE THEN
;AUTO時緑/赤ボタン（原点復帰）の無効
RETURN
END
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_GEN"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_gen)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "0"
$prm[TASKNO,3] = "1"
$prm[TASKNO,4] = "1234"
.num = 3
.status = TRUE
RETURN
END
END
TWAIT ascycle
UNTIL (UTIMER(.@nowtime)>wait_extin_time)
END
IF (sw_extin_gena==ON AND SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON) OR (sw_extin_genm==ON AND SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF) THEN
IF SIG(sig_extin_gen) THEN
IF (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
;外部I/Oから原点復帰
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_GEN"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_gen)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "0"
$prm[TASKNO,3] = "1"
$prm[TASKNO,4] = "1234"
.num = 3
.status = TRUE
RETURN
END
END
END
IF SIG(extin_start_but)==ON THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF robot_mode==mode_direct THEN
;ダイレクトモード中は実行禁止
RETURN
END
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
IF flg_extin_resta<>FALSE THEN
;AUTO時緑ボタン（再開）の無効
RETURN
END
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESTART"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_restart)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
ELSE
IF flg_extin_start<>FALSE THEN
;AUTO時緑ボタン（実行）の無効
RETURN
END
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_START"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_start)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1"
$prm[TASKNO,3] = "1234"
.num = 3
END
ELSE
IF flg_extin_robot<>FALSE THEN
;MANUAL時緑ボタン（ﾀﾞｲﾚｸﾄﾃｨｰﾁ）の無効
RETURN
END
IF (SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON) THEN
RETURN
END
;ロボットモード=ダイレクトティーチ、フラグ=ONに変更
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->ON"
END
;ダイレクトティーチゲインデフォルト設定
mode_sa = 0
sa_tool[1] = 1
sa_tool[2] = 1
FOR .i = 1 TO 2
FOR .j = 1 TO 6
sa_param[.i,.j] = 1
END
END
$sa_param = "0,1,1,1,1,1,1,1,1,1,1,1,1"
flg_sa_change = 3
;
$prm[TASKNO,0] = $ENCODE(cmd_exe_robotmo)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1"
$prm[TASKNO,3] = "1"
$prm[TASKNO,4] = "1234"
.num = 4
END
.status = TRUE
RETURN
END
IF sw_extin_start==ON AND SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
;外部I/Oから実行
IF SIG(sig_extin_start) THEN
IF robot_status_ou==sta_nomove AND (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_START"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_start)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1"
$prm[TASKNO,3] = "1234"
.num = 3
.status = TRUE
RETURN
END
END
END
IF sw_extin_restar==ON AND SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
;外部I/Oから再開
IF SIG(sig_extin_resta) THEN
IF robot_status_ou==sta_hold AND (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESTART"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_restart)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
.status = TRUE
RETURN
END
END
END
IF sw_extin_robotm==ON AND SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
;外部I/Oからダイレクトティーチ
IF SIG(sig_extin_robot) THEN
IF (TASK(1)<>1 AND SWITCH(CS ,1)==OFF) AND (TASK(2)<>1 AND SWITCH(CS ,2)==OFF) THEN
;ロボットモード=ダイレクトティーチ、フラグ=ONに変更
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ROBOTMODE->ON"
END
;ダイレクトティーチゲインデフォルト設定
mode_sa = 0
sa_tool[1] = 1
sa_tool[2] = 1
FOR .i = 1 TO 2
FOR .j = 1 TO 6
sa_param[.i,.j] = 1
END
END
$sa_param = "0,1,1,1,1,1,1,1,1,1,1,1,1"
flg_sa_change = 3
;
$prm[TASKNO,0] = $ENCODE(cmd_exe_robotmo)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1"
$prm[TASKNO,3] = "1"
$prm[TASKNO,4] = "1234"
.num = 4
.status = TRUE
RETURN
END
END
END
IF SIG(extin_stop_butt)==ON THEN
IF g_last_error<>err_no_error THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF flg_extin_arese<>FALSE THEN
;AUTO時赤ボタン（エラーリセット）の無効
RETURN
END
ELSE
IF flg_extin_mrese<>FALSE THEN
;MANUAL時赤ボタン（エラーリセット）の無効
RETURN
END
END
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESET"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_reset)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
.status = TRUE
RETURN
ELSE
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF flg_extin_aabor<>FALSE THEN
;AUTO時赤ボタン（停止）の無効
RETURN
END
ELSE
IF flg_extin_mabor<>FALSE THEN
;MANUAL時赤ボタン（停止）の無効
RETURN
END
END
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ABORT"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_abort)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
.status = TRUE
RETURN
END
END
IF sw_extin_reset==ON THEN
IF SIG(sig_extin_reset) THEN
;外部I/Oからエラーリセット
IF g_last_error<>err_no_error THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_RESET"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_reset)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
.status = TRUE
RETURN
END
END
END
IF sw_extin_abort==ON THEN
IF SIG(sig_extin_abort) THEN
;外部I/Oから停止
IF g_last_error==err_no_error THEN
IF debug.prt.extio==ON THEN
PRINT "chk_extin()-> START CMD_EXE_ABORT"
END
$prm[TASKNO,0] = $ENCODE(cmd_exe_abort)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1234"
.num = 2
.status = TRUE
RETURN
END
END
END
.END
.PROGRAM chk_pos(.rno,.mode,.#inpos,.ret)
;-------------------------------- 
;機能：目標位置が動作範囲内かチェック
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)、目標位置(実数配列)
;戻値：成否
;--------------------------------
.ret = err_no_error
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
;位置情報生成
DECOMPOSE .temp_rno: .inpos[1] = .#inpos
IF .mode==mode_jt THEN
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .#move_pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
POINT .temp_rno: .move_pos = .#move_pos
VALUE 5:
POINT .temp_rno: .#move_pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7])
POINT .temp_rno: .move_pos = .#move_pos
VALUE 6,7,8:
POINT .temp_rno: .#move_pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8])
POINT .temp_rno: .move_pos = .#move_pos
ANY :
.ret = err_bad_axesno
RETURN
END
ELSE
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .move_pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
VALUE 5:
POINT .temp_rno: .move_pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7])
VALUE 6,7,8:
POINT .temp_rno: .move_pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8])
ANY :
.ret = err_bad_axesno
RETURN
END
END
IF .rno==2 THEN
IF .mode==mode_jt THEN
.res = INRANGE:2(.#move_pos)
ELSE
.res = INRANGE:2(.move_pos,#S_HERE(2))
END
ELSE
IF .mode==mode_jt THEN
.res = INRANGE(.#move_pos)
ELSE
.res = INRANGE(.move_pos,#S_HERE(1))
END
END
IF .res<>0 THEN
.ret = err_out_range
END
IF .rno==0 AND .ret==err_no_error THEN
;協調動作の時はスレーブ側の目標位置もチェック
POINT .temp = -S_HERE(1)+S_HERE(2)
POINT .slave_pos = .move_pos+.temp
DECOMPOSE robot_slave: .pos_s[1] = .slave_pos
DECOMPOSE robot_master: .here1[1] = S_HERE(robot_master)
DECOMPOSE robot_slave: .here2[1] = S_HERE(robot_slave)
.coop[7] = SWITCH(COOP.DRIVE.EX1)
.coop[8] = SWITCH(COOP.DRIVE.EX2)
FOR .jt = 7 TO 8
IF SYSDATA(JTEXIST,robot_master,.jt)<>FALSE AND SYSDATA(JTEXIST,robot_slave,.jt)<>FALSE AND .coop[.jt]<>FALSE THEN
;EXT1(EXT2)が協調可能
.pos_s[.jt] = .here2[.jt]+(.inpos[.jt]-.here1[.jt]) ;EXT1(EXT2)の目標値
ELSE
.pos_s[.jt] = 0
END
END
CASE SYSDATA(ZROB.NOWAXIS,robot_slave) OF
VALUE 4:
POINT robot_slave: .slave_pos2 = TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4],.pos_s[5],.pos_s[6])
VALUE 5:
POINT robot_slave: .slave_pos2 = TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4],.pos_s[5],.pos_s[6],.pos_s[7])
VALUE 6,7,8:
POINT robot_slave: .slave_pos2 = TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4],.pos_s[5],.pos_s[6],.pos_s[7],.pos_s[8])
END
.res = INRANGE:2(.slave_pos2,#S_HERE(2))
IF .res<>0 THEN
.ret = err_out_range
END
END
.END
.PROGRAM chk_robot_stop_()
;-------------------------------- 
;機能：ロボット状態を停止に変更
;引数：無し
;戻値：無し
;--------------------------------
;動作プログラム実行状態フラグ
flg_main_run = FALSE
flg_tablet_run[1] = FALSE
flg_tablet_run[2] = FALSE
flg_direct_run = FALSE
;作業実行フラグ
data_execute = FALSE
;ロボット動作中フラグ
flg_master_move = FALSE
flg_slave_move = FALSE
;ロボットモードONフラグ
robot_mode_flg = FALSE
;ロボットモード
robot_mode = mode_tablet
IF no_restart_flg<>FALSE OR cv_norestart[robot_master]<>FALSE OR cv_norestart[robot_slave]<>FALSE THEN
;再開不可
FOR .i = 1 TO 2
data_cur_l2rec[.i] = 0
data_cur_l3rec[.i] = 0
now_move_l3num[.i] = 0
END
no_restart_flg = FALSE
cv_norestart[robot_master] = FALSE
cv_norestart[robot_slave] = FALSE
END
;ロボット状態遷移
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
robot_status = sta_hold
ELSE
robot_status = sta_nomove
END
;重力補償自動調整プログラム実行状態
flg_gravityadj_ = FALSE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL -extout_start_bu,-extout_stop_but
.END
.PROGRAM chk_slow_start()
;-------------------------------- 
;機能：スロースタート判定
;引数：無し
;戻値：無し
;-------------------------------- 
IF slowlimit_ena<>FALSE AND flg_single_move==FALSE AND flg_call_now[robot_master]==FALSE AND flg_call_now[robot_slave]==FALSE THEN; スロースタート有効・個別実行ではない・マクロPG実行中でない
; スロースタート用タイマーリセット
UTIMER @slowlimit_timer = 0
; 現在のプログラム速度を取得
.now_pg_sp = SYSDATA(P.SPEED,robot_master); %
.now_pg_sp_m = SYSDATA(P.SPEED.M,robot_master); mm/sec
.sp_m_max = .now_pg_sp_m/(.now_pg_sp/100)
; スロースタートの速度を算出(mm/sec⇒%)
.slowstart_sp = (slowlimit_speed/.sp_m_max)*100
; 現在のモニタ速度を取得
.now_mon_sp = SYSDATA(M.SPEED,robot_master)
IF .now_mon_sp>.slowstart_sp THEN
; 初期化(変更確認用)
chg_bef_mspeed[robot_master] = 0
chg_bef_mspeed[robot_slave] = 0
; 速度変更確認
IF flg_slowlimit==FALSE THEN; スロースタート中ではない時
flg_slowlimit = TRUE; スロースタートON
chg_bef_mspeed[robot_master] = .now_mon_sp
chg_bef_mspeed[robot_slave] = SYSDATA(M.SPEED,robot_slave)
ELSE; スロースタート中の時
; 現在のプログラム速度がSLOWLIMIT_SPEEDの時はモニタ速度を変更しない
IF .now_pg_sp_m<(slowlimit_speed-robot_master) OR (slowlimit_speed+1)<.now_pg_sp_m THEN
chg_bef_mspeed[robot_master] = .now_mon_sp
END
; 現在のプログラム速度を取得
.now_pg_sp_m2 = SYSDATA(P.SPEED.M,robot_slave)
IF .now_pg_sp_m2<(slowlimit_speed-1) OR (slowlimit_speed+1)<.now_pg_sp_m2 THEN
chg_bef_mspeed[robot_slave] = SYSDATA(M.SPEED,robot_slave)
END
END
; 速度変更(プログラム速度は変更出来ないのでモニタ速度で調整)
FOR .rno = robot_master TO robot_slave
IF chg_bef_mspeed[.rno]<>0 THEN
.chg_mon_sp = INT((.slowstart_sp*100)/SYSDATA(P.SPEED,.rno))
IF .chg_mon_sp>chg_bef_mspeed[.rno] THEN
.chg_mon_sp = chg_bef_mspeed[.rno]
END
MC SPEED .rno:.chg_mon_sp
IF debug.prt.sp==TRUE THEN
PRINT "chk_slow_start() -> M.SPEED",SYSDATA(M.SPEED,.rno),"[%], P.SPEED",SYSDATA(P.SPEED,.rno),"[%], TASKNO =",TASKNO,", rno =",.rno
END
chg_aft_mspeed[.rno] = SYSDATA(M.SPEED,.rno)
END
END
END
END
.END
.PROGRAM close_socket() ;Closing communication
TCP_CLOSE ret,sock_id;Normal socket closure 
IF ret<0 THEN
PRINT "TCP_CLOSE error ERROE=(",ret,") ",$ERROR(ret)
TCP_CLOSE ret1,sock_id;Forced closure of socket (shutdown) 
IF ret1<0 THEN
PRINT "TCP_CLOSE error id=",sock_id
END
ELSE
PRINT "TCP_CLOSE OK id=",sock_id
END
TCP_END_LISTEN ret,port
IF ret<0 THEN
PRINT "TCP_CLOSE error id=",sock_id
ELSE
PRINT "TCP_CLOSE OK id=",sock_id
END
.END
.PROGRAM cmdabort(.ret)
;-------------------------------- 
;機能：中断コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;外部制御盤操作を許容する
IF 0 THEN
IF TASKNO<>pg_com_noact THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,"->cmdabort() 非動作コマンドポートからの実行指示のみ可能"
END
RETURN
END
END
IF flg_master_move==TRUE OR flg_slave_move==TRUE OR SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON THEN
exout_start_fla = FALSE
;status_check関数でエラーを発生させないようにフラグ操作する
flg_main_run = FALSE
IF robot_mode==mode_direct AND robot_mode_flg<>FALSE AND flg_direct_run==TRUE THEN
flg_direct_run = FALSE
END
;HOLD後、PCプログラムがエラーを検知する←status_check関数でエラーを発生させないように仕様変更する20151006
UTIMER .@nowtime = 0
.comp_flag = FALSE
MC HOLD 1:
MC HOLD 2:
DO
IF (SWITCH(CS ,1)==OFF) AND (SWITCH(CS ,2)==OFF) THEN
.comp_flag = TRUE
END
TWAIT ascycle
UNTIL (.comp_flag==TRUE OR UTIMER(.@nowtime)>boot_timeout)
IF SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON THEN
IF SWITCH(CS ,1)==ON THEN
PRINT "Can NOT abort program on MASTER-ROBOT."
END
IF SWITCH(CS ,2)==ON THEN
PRINT "Can NOT abort program on SLAVE-ROBOT."
END
.ret = err_main_stop
RETURN
END
IF data_execute==TRUE THEN
CALL update_holdpos
END
CALL reset_mon_sp(robot_all); モニタ速度を変更している場合は元に戻す
;status_check関数でエラーを発生させないため、本来status_check関数で初期化するパラメータをここで初期化する
CALL chk_robot_stop_
IF debug.prt.cmd==TRUE THEN
PRINT "cmdabort()->ROBOT_NUM=",$prm[TASKNO,1]
PRINT "cmdabort()->SENDING REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "cmdabort()->ROBOT_NUM=",$prm[TASKNO,1]
PRINT "cmdabort()->NO NEED SEND REQUEST FOR ABORT(FLG_ROBOT_ABORT)"
END
END
.END
.PROGRAM cmdchgio(.ret)
;-------------------------------- 
;機能：IO変更コマンド
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;-------------------------------- 
IF debug.prt.cmd==TRUE THEN
PRINT ".rno=",$prm[TASKNO,1]
PRINT "Signal Number=",$prm[TASKNO,2],", Signal Status=",$prm[TASKNO,3],", Keed Signal Time=",$prm[TASKNO,4]
END
IF 2001<=VAL($prm[TASKNO,2]) AND VAL($prm[TASKNO,2])<=2256 THEN
;内部信号のシステム領域は変更できない
.ret = err_bad_signo
RETURN
END
CALL iochange(VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),.ret)
.END
.PROGRAM cmdchgrobotmode(.ret)
;-------------------------------- 
;機能：ロボットモード変更
;引数：ロボットモード(0:タブレット、1:ダイレクト)、ON/OFFフラグ(0:OFF、1:ON)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;モードチェンジ可否判定
IF robot_mode==mode_tablet AND robot_mode_flg<>FALSE AND (flg_master_move==TRUE OR flg_slave_move==TRUE) THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not change robot-mode, because still moving any robot."
END
.ret = err_robot_busy
RETURN
END
.robot_mode = VAL($prm[TASKNO,2])
.flg_onoff = VAL($prm[TASKNO,3])
robot_mode = .robot_mode
;動作プログラム起動要否判定
.flg_execute = FALSE
IF .flg_onoff==1 THEN
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
END
CASE .robot_mode OF
VALUE mode_tablet:
IF .flg_onoff==1 THEN
.flg_execute = TRUE
END
VALUE mode_direct:
IF .flg_onoff==1 THEN
.flg_execute = TRUE
END
;ダイレクトティーチ
flg_sa_change = 3
ANY :
.ret = err_bad_mode
RETURN
END
;ﾛﾎﾞｯﾄﾓｰﾄﾞ変更後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
exout_start_fla = FALSE
IF .flg_execute==TRUE THEN
robot_mode_flg = .flg_onoff
CALL exec_pg(.ret)
IF .ret<>err_no_error THEN
robot_mode_flg = FALSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not execute program."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Executed program successfully."
END
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Start abort program automatically."
END
CALL rdyboot(FALSE,.ret)
IF .ret<>err_no_error THEN
robot_mode_flg = FALSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Can not abort program."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdchgrobotmode() Aborted program successfully."
END
robot_mode_flg = .flg_onoff
END
END
exout_start_fla = FALSE
.END
.PROGRAM cmdcon(.ret)
;-------------------------------- 
;機能：作業番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdcon() .rno=",$prm[TASKNO,1]
END
.sp = VAL($prm[TASKNO,2])
.id = VAL($prm[TASKNO,3])
CALL chg_move_param(0,.sp,data_acc,data_dec,data_accu,.ret)
IF .ret<>err_no_error THEN
RETURN
END
FOR .i = 1 TO data_l3num[.id]
CALL exec_move(.id,.i,.ret)
END
BREAK
.END
.PROGRAM cmdexe(.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_exe
;個別実行記憶フラグ
flg_single_move = FALSE
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
;前回移動位置初期化
POINT #dest_pos[1] = #PPOINT(9999,9999,9999,9999)
POINT #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
dest_mode[1] = 9999
dest_mode[2] = 9999
;マクロPG実行中フラグ
flg_call_now[robot_master] = FALSE
flg_call_now[robot_slave] = FALSE
;コンベア同期関連初期化
CALL cv_init
cv_vision_id = 0 ;コンベア固定ビジョンの品種ID初期化
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
;コンベア同期バッファリセット
flg_cvpc_stop = TRUE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cvpc_stop = FALSE
.ret = err_cvpc_ready
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run==FALSE)
CALL cv_init
FOR .i = 1 TO 2
FOR .j = 1 TO 2
CALL cvaxis_check(.i,cv_coopjt[.i,.j],.ret)
IF .ret==0 THEN
IF cv_ulim[.j]>=cv_llim[.j] THEN
.ret = err_cv_setting
RETURN
END
CVSWITCH .i:  ON
ELSE
.ret = 0
END
END
END
flg_cvpc_stop = FALSE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_cvpc_ready
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run<>FALSE)
END
IF flg_load_now<>FALSE THEN
;作業転送転送未完
.ret = err_not_load
RETURN
END
; 作業グルーピング設定確認
IF data_wset_ena<>FALSE THEN
CALL get_workno(.work_no,.ret)
data_cur_workno = .work_no
IF .ret<>err_no_error THEN
RETURN
END
ELSE
data_cur_workno = -999; 作業グルーピング設定無効
END
; ビジョン結果ＮＧ信号初期化
SIGNAL -ix_result_vng[1]
SIGNAL -ix_result_vng[2]
; ビジョンインターロック信号初期化
SIGNAL -ix_vloc_mas
SIGNAL -ix_vloc_sla
SIGNAL -ix_vloc_now
; 信号待ちＮＧ(タイムアウト)信号初期化
SIGNAL -ix_iowait_to[1]
SIGNAL -ix_iowait_to[2]
IF disable_continu==FALSE THEN
CALL chk_exe_staus(.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
;位置チェック
CALL check_pos(VAL($prm[TASKNO,1]),cmd_exe_start,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
CALL cmdexecore(.ret)
;実行完了後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdexecalchkom(.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーション精度チェック実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_vscalib; カメラキャリブレーションと共通の状態遷移変数
.camno = VAL($prm[TASKNO,2]); カメラ番号
.$cam = $ENCODE(/I1,.camno); カメラ番号
.$chk_r = "vcal_robot["+.$cam+"]"
IF EXISTDATA(.$chk_r,R)==OFF THEN
.ret = err_vis_nocalib; キャリブレーション未実施
CALL error_log(.ret)
robot_status = sta_nomove
RETURN
END
.rno = vcal_robot[.camno]; キャリブレーション時のロボット番号を使用
.sceno = VAL($prm[TASKNO,3]); シーン番号
IF .sceno<0 OR 127<.sceno THEN
.ret = err_bat_value
RETURN
END
.height = VAL($prm[TASKNO,4]); 逃げ高さ
;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
robot_status = sta_nomove
RETURN
VALUE robot_master:
CALL vis_excalchkom(.rno,.camno,.sceno,.height,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = .rno
gs_camno = .camno
gs_calno = .sceno
gs_height = .height
flg_slave_move = TRUE; スレーブロボット実行
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
;ロボット状態遷移
.ret = gs_excalchk_err
robot_status = sta_nomove
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
TWAIT ascycle
END
END
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdexecalxom(.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーションX実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_vscalib
.rno = VAL($prm[TASKNO,1])
;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master:
.len = VAL($prm[TASKNO,2]); 移動距離
IF .len==0 THEN
.ret = err_bat_value; 移動距離0は不可
RETURN
END
.height = VAL($prm[TASKNO,3]); 逃げ高さ
CALL vis_execalxom(.rno,.len,.height,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = VAL($prm[TASKNO,1])
gs_len = VAL($prm[TASKNO,2]); 移動距離
IF gs_len==0 THEN
.ret = err_bat_value; 移動距離0は不可
RETURN
END
gs_height = VAL($prm[TASKNO,3]); 逃げ高さ
;スレーブロボット実行
flg_slave_move = TRUE
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
;ロボット状態遷移
.ret = gs_excalib_err
robot_status = sta_nomove
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
TWAIT ascycle
END
END
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdexecalyom(.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーションY実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_vscalib
.rno = VAL($prm[TASKNO,1])
;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master:
.camno = VAL($prm[TASKNO,2]); カメラ番号
.camtype = VAL($prm[TASKNO,3]); カメラ種別
POINT .target = TRANS(VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),0,0); ターゲット位置
.len = VAL($prm[TASKNO,8]); 移動距離
IF .len==0 THEN
.ret = err_bat_value; 移動距離0は不可
RETURN
END
.height = VAL($prm[TASKNO,9]); 逃げ高さ
POINT .tool_p = TRANS(VAL($prm[TASKNO,10]),VAL($prm[TASKNO,11]),0,0,0,0); ツール位置
CALL vis_execalyom(.rno,.camno,.camtype,.&target,.len,.height,.&tool_p,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = VAL($prm[TASKNO,1])
gs_camno = VAL($prm[TASKNO,2]); カメラ番号
gs_camtype = VAL($prm[TASKNO,3]); カメラ種別
POINT gs_posxyzr1 = TRANS(VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),0,0); ターゲット位置
gs_len = VAL($prm[TASKNO,8]); 移動距離
IF gs_len==0 THEN
.ret = err_bat_value; 移動距離0は不可
RETURN
END
gs_height = VAL($prm[TASKNO,9]); 逃げ高さ
POINT gs_toolp = TRANS(VAL($prm[TASKNO,10]),VAL($prm[TASKNO,11]),0,0,0,0); ツール位置
;スレーブロボット実行
flg_slave_move = TRUE
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
;ロボット状態遷移
.ret = gs_excalib_err
robot_status = sta_nomove
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
TWAIT ascycle
END
END
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdexecore(.ret)
;-------------------------------- 
;機能：作業プログラム実行
;引数：実行回数
;戻値：成否
;-------------------------------- 
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() .rno=",$prm[TASKNO,1]
END
.exe_num = VAL($prm[TASKNO,2])
IF .exe_num<=0 THEN
.ret = err_bad_num
RETURN
END
IF $data_pgname=="" THEN
.ret = err_exe_name
RETURN
END
data_execute = TRUE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() STARTING $DATA_PGNAME=",$data_pgname
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
ELSE
IF kroset==TRUE THEN
INTFCHK ON
END
END
FOR .i = 1 TO .exe_num
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() Executing.... ",$data_pgname,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
END
;作業連続実行開始
CALL mainexe
BREAK
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() Done ",$data_pgname,"->",$ENCODE(.i),"/",$ENCODE(.exe_num)
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexe() DONE $DATA_PGNAME=",$data_pgname
END
.ret = g_last_error
.END
.PROGRAM cmdexecvmove(.ret)
;-------------------------------- 
;機能：コンベア停止/起動
;引数：コンベア番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
RETURN
END
.cvno = VAL($prm[TASKNO,1])
IF cv_coopjt[1,.cvno]<>0 AND cv_coopjt[2,.cvno]<>0 THEN
IF cv_coopjt[1,.cvno]==cv_coopjt[2,.cvno] THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 3
ELSE
.ret = err_cv_setting
RETURN
END
ELSE
IF cv_coopjt[1,.cvno]<>0 THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 1
ELSE
IF cv_coopjt[2,.cvno]<>0 THEN
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 2
ELSE
.ret = err_cv_setting
RETURN
END
END
END
CASE .cvnum OF
VALUE 1:
.cvsta[1] = SYSDATA(CVSWITCH,1,cv_coopjt[1,.cvno])
IF .cvsta[1]==0 THEN
CVSWITCH 1:  ON
ELSE
CVSWITCH 1:  OFF
END
VALUE 2:
.cvsta[2] = SYSDATA(CVSWITCH,2,cv_coopjt[2,.cvno])
IF .cvsta[2]==0 THEN
CVSWITCH 2:  ON
ELSE
CVSWITCH 2:  OFF
END
VALUE 3:
.cvsta[1] = SYSDATA(CVSWITCH,1,cv_coopjt[1,.cvno])
IF .cvsta[1]==0 THEN
CVSWITCH 1:  ON
CVSWITCH 2:  ON
ELSE
CVSWITCH 1:  OFF
CVSWITCH 2:  OFF
END
END
.END
.PROGRAM cmdexecvset(.ret)
;-------------------------------- 
;機能：コンベアセット
;引数：コンベア番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
RETURN
END
.cvno = VAL($prm[TASKNO,1])
CALL setparam_range($prm[TASKNO,2],"REAL",0,99999,FALSE,.cvval,.ret); 領域最小値[0]・最大値[100000]確認
IF .ret<>err_no_error THEN
RETURN
END
IF cv_coopjt[1,.cvno]<>0 AND cv_coopjt[2,.cvno]<>0 THEN
IF cv_coopjt[1,.cvno]==cv_coopjt[2,.cvno] THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 3
ELSE
.ret = err_cv_setting
RETURN
END
ELSE
IF cv_coopjt[1,.cvno]<>0 THEN
CALL cvaxis_check(1,cv_coopjt[1,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 1
ELSE
IF cv_coopjt[2,.cvno]<>0 THEN
CALL cvaxis_check(2,cv_coopjt[2,.cvno],.ret)
IF .ret<>0 THEN
.ret = err_cv_setting
RETURN
END
.cvnum = 2
ELSE
.ret = err_cv_setting
RETURN
END
END
END
CASE .cvnum OF
VALUE 1:
CALL change_cvcoop(1,.cvno,1,cv_mode_wait,.cvjt,.cvworkno,.ret)
IF .ret<>0 THEN
RETURN
END
CVSET 1: .cvval,.cvworkno
VALUE 2:
CALL change_cvcoop(2,.cvno,1,cv_mode_wait,.cvjt,.cvworkno,.ret)
IF .ret<>0 THEN
RETURN
END
CVSET 2: .cvval,.cvworkno
VALUE 3:
CALL change_cvcoop(1,.cvno,1,cv_mode_wait,.cvjt,.cvworkno,.ret)
IF .ret<>0 THEN
RETURN
END
CVSET 1: .cvval,.cvworkno
CVSET 2: .cvval,.cvworkno
END
.END
.PROGRAM cmdexecvvcal(.ret)
;-------------------------------- 
;機能：コンベアビジョンキャリブレーション
;引数：なし
;戻値：成否
;-------------------------------- 
.ret = err_no_error
; パラメータ取得
.rno = VAL($prm[TASKNO,1])
.cvno = VAL($prm[TASKNO,2])
.camno = VAL($prm[TASKNO,3])
.cvdist = VAL($prm[TASKNO,4])
POINT .tool_p = TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),0,0,0,0)
POINT .target1 = TRANS(VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),VAL($prm[TASKNO,9]),VAL($prm[TASKNO,10]),0,0)
POINT .target2 = TRANS(VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]),VAL($prm[TASKNO,13]),VAL($prm[TASKNO,14]),0,0)
POINT .target3 = TRANS(VAL($prm[TASKNO,15]),VAL($prm[TASKNO,16]),VAL($prm[TASKNO,17]),VAL($prm[TASKNO,18]),0,0)
CALL vis_execvcal(.rno,.camno,.cvno,.cvdist,.&tool_p,.&target1,.&target2,.&target3,.ret)
.END
.PROGRAM cmdexevcalchk(.ret)
;-------------------------------- 
;機能：カメラキャリブレーション精度チェック実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_vscalib; カメラキャリブレーションと共通の状態遷移変数
.camno = VAL($prm[TASKNO,2]); カメラ番号
.$cam = $ENCODE(/I1,.camno); カメラ番号
.$chk_r = "vcal_robot["+.$cam+"]"
IF EXISTDATA(.$chk_r,R)==OFF THEN
.ret = err_vis_nocalib; キャリブレーション未実施
CALL error_log(.ret)
robot_status = sta_nomove
RETURN
END
.rno = vcal_robot[.camno]; キャリブレーション時のロボット番号を使用
.height = VAL($prm[TASKNO,3])
;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
robot_status = sta_nomove
RETURN
VALUE robot_master:
CALL vision_excalchk(.rno,.camno,.height,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = .rno
gs_camno = .camno
gs_height = .height
flg_slave_move = TRUE; スレーブロボット実行
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
;ロボット状態遷移
.ret = gs_excalchk_err
robot_status = sta_nomove
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
TWAIT ascycle
END
END
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdexevscalib(.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_vscalib
.rno = VAL($prm[TASKNO,1])
;ｷｬﾘﾌﾞﾚｰｼｮﾝ実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master:
.camno = VAL($prm[TASKNO,2])
.calno = VAL($prm[TASKNO,3])
IF .calno<1 OR 999<.calno THEN
.ret = err_bat_value
RETURN
END
.camtype = VAL($prm[TASKNO,4])
POINT .target = TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),0,0)
.len = VAL($prm[TASKNO,9])
IF .len==0 THEN
.ret = err_bat_value
RETURN
END
.height = VAL($prm[TASKNO,10])
POINT .tool_p = TRANS(VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]),0,0,0,0)
CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
VALUE robot_slave:
;パラメータ設定
gs_rno = VAL($prm[TASKNO,1])
gs_camno = VAL($prm[TASKNO,2])
gs_calno = VAL($prm[TASKNO,3])
IF gs_calno<1 OR 999<gs_calno THEN
.ret = err_bat_value
RETURN
END
gs_camtype = VAL($prm[TASKNO,4])
POINT gs_posxyzr1 = TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),0,0)
gs_len = VAL($prm[TASKNO,9])
IF gs_len==0 THEN
.ret = err_bat_value
RETURN
END
gs_height = VAL($prm[TASKNO,10])
POINT gs_toolp = TRANS(VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]),0,0,0,0)
;スレーブロボット実行
flg_slave_move = TRUE
;スレーブロボット終了待ち
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() Done ... SLAVE-ROBOT."
END
;ロボット状態遷移
.ret = gs_excalib_err
robot_status = sta_nomove
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdexevscalib() WAITING ... SLAVE-ROBOT."
END
END
TWAIT ascycle
END
END
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdgen(.ret)
;-------------------------------- 
;機能：ホーム移動コマンド
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_gen
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
exout_start_fla = FALSE
;全作業実行状態初期化
CALL updatel2l3info(TRUE,0,0,TRUE)
CALL gen(.ret)
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdgetmcrpos(.$res,.ret)
;-------------------------------- 
;機能：マクロPG用位置変数取得
;引数：第2階層番号、第3階層番号、呼び出し番号、位置変数番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL getmcrpos(.$res,.ret)
.END
.PROGRAM cmdgetparam(.cmd,.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
.ret = err_no_error
CALL getparam(.cmd,.$res,.ret)
.END
.PROGRAM cmdgetstep(.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
.ret = err_no_error
CALL getstep(.$res,.ret)
.END
.PROGRAM cmdgetstepifgot(.$res,.ret)
;-------------------------------- 
;機能：条件分岐詳細取得
;引数：第2階層番号、第3階層番号、条件番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
CALL getstepifgoto(.$res,.ret)
.END
.PROGRAM cmdgetsteppos(.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
CALL getsteppos(.$res,.ret)
.END
.PROGRAM cmdgravityadj(.ret)
;-------------------------------- 
;重力補償自動調整コマンド
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_gravityadj
.rno = VAL($prm[TASKNO,1])
;モード(0:自動、1:手動)
.mode = VAL($prm[TASKNO,2])
;マスタ設定値
.master_setval = VAL($prm[TASKNO,3])
;スレーブ設定値
.slave_setval = VAL($prm[TASKNO,4])
IF .mode==0 THEN
;重力補償自動調整実行後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
;自動調整の場合は原点確認
CALL check_pos(VAL($prm[TASKNO,1]),cmd_exe_gravity,.ret)
ELSE
IF .rno==1 AND (.master_setval>200 OR .master_setval<-200) THEN
.ret = err_bat_value
END
IF .rno==2 AND (.slave_setval>200 OR .slave_setval<-200) THEN
.ret = err_bat_value
END
END
IF .ret<>err_no_error THEN
robot_status = sta_nomove
CALL update_error(.ret)
RETURN
END
flg_gravityadj_ = TRUE
CALL gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
BREAK
flg_gravityadj_ = FALSE
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdhand(.ret)
;-------------------------------- 
;機能：ハンド操作コマンド
;引数：ハンド状態(0=閉、1=開)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL($prm[TASKNO,1])
.status = VAL($prm[TASKNO,2])
.solno = VAL($prm[TASKNO,3])
CALL hand(.rno,.status,.solno,.ret)
.END
.PROGRAM cmdhold(.ret)
;-------------------------------- 
;機能：一時停止コマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;2015/10/2機能削除
RETURN
.END
.PROGRAM cmdl2check(.l2num,.l2num_ok,.ret)
;-------------------------------- 
;機能：第2階層作業条件の成立チェック(個別実行時)
;引数：第2階層番号
;戻値：成立した第2階層番号、成立有無(FALSE/TRUE)
;-------------------------------- 
.ret = FALSE
.l2num_ok = -1
;.cnt=成立条件数
.cnt = 0
IF data_l2exetblnu[.l2num]<=0 THEN
;実行条件なし
ELSE
;実行条件確認
FOR .j = 1 TO data_l2exetblnu[.l2num]
IF data_l2tbl_sign[.l2num,.j]=<3000 THEN
IF data_l2tbl_stat[.l2num,.j]==1 THEN
IF SIG(data_l2tbl_sign[.l2num,.j])==ON THEN
.cnt = .cnt+1
END
ELSE
IF SIG(data_l2tbl_sign[.l2num,.j])==OFF THEN
.cnt = .cnt+1
END
END
ELSE
IF data_l2tbl_stat[.l2num,.j]==1 THEN
IF data_l2status[data_l2tbl_sign[.l2num,.j]-3000]==TRUE THEN
.cnt = .cnt+1
END
ELSE
IF data_l2status[data_l2tbl_sign[.l2num,.j]-3000]==FALSE THEN
.cnt = .cnt+1
END
END
END
END
END
IF .cnt==data_l2exetblnu[.l2num] THEN
NOEXIST_SET_R data_l2workno[.l2num] = 0
IF (data_l2workno[.l2num]==data_cur_workno AND data_cur_workno<>0 AND data_wset_ena==1) OR data_wset_ena==0 THEN; 作業グループ番号一致または作業グルーピング設定無効
;実行条件成立
.l2num_ok = .l2num
.ret = TRUE
RETURN
END
END
.END
.PROGRAM cmdl2exe(.ret)
;-------------------------------- 
;機能：第2階層指定個別実行コマンド
;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;ロボット状態遷移
robot_status = sta_l2exe
IF flg_load_now<>FALSE THEN
;作業転送転送未完
.ret = err_not_load
RETURN
END
;個別実行記憶フラグ
flg_single_move = TRUE
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
;前回移動位置初期化
POINT #dest_pos[1] = #PPOINT(9999,9999,9999,9999)
POINT #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
dest_mode[1] = 9999
dest_mode[2] = 9999
;マクロPG実行中フラグ
flg_call_now[robot_master] = FALSE
flg_call_now[robot_slave] = FALSE
;コンベア同期関連初期化
CALL cv_init
cv_vision_id = 0 ;コンベア固定ビジョンの品種ID初期化
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
;コンベア同期バッファリセット
flg_cvpc_stop = TRUE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cvpc_stop = FALSE
.ret = err_cvpc_ready
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run==FALSE)
CALL cv_init
FOR .i = 1 TO 2
FOR .j = 1 TO 2
CALL cvaxis_check(.i,cv_coopjt[.i,.j],.ret)
IF .ret==0 THEN
IF cv_ulim[.j]>=cv_llim[.j] THEN
.ret = err_cv_setting
RETURN
END
CVSWITCH .i:  ON
ELSE
.ret = 0
END
END
END
flg_cvpc_stop = FALSE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_cvpc_ready
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run<>FALSE)
END
; ビジョン結果ＮＧ信号初期化
SIGNAL -ix_result_vng[1]
SIGNAL -ix_result_vng[2]
; ビジョンインターロック信号初期化
SIGNAL -ix_vloc_mas
SIGNAL -ix_vloc_sla
SIGNAL -ix_vloc_now
; 信号待ちＮＧ(タイムアウト)信号初期化
SIGNAL -ix_iowait_to[1]
SIGNAL -ix_iowait_to[2]
.l2num = VAL($prm[TASKNO,2])
.flg_l2chk = VAL($prm[TASKNO,3])
.repeat_num = VAL($prm[TASKNO,4])
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,",cmdl2exe()->.rno=",VAL($prm[TASKNO,1]),",.l2num=",.l2num,",.flg_l2chk=",.flg_l2chk,",.repeat_num=",.repeat_num
END
FOR .i = 1 TO data_l2num
data_l2status[.i] = FALSE
END
data_execute = TRUE
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
ELSE
IF kroset==TRUE THEN
INTFCHK ON
END
END
FOR .i = 1 TO .repeat_num
IF disable_l2chk==TRUE THEN
;順次実行
flg_slave_move = FALSE
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
ELSE
IF .flg_l2chk==1 THEN
;第2階層条件チェック実行
;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
DO
CALL cmdl2check(.l2num,.l2num_ok,.ret)
IF ((.ret<>TRUE) OR (.l2num_ok<>.l2num)) THEN
flg_l2chk_wait = TRUE
END
TWAIT ascycle
UNTIL ((.ret==TRUE) AND (.l2num_ok==.l2num))
END
flg_l2chk_wait = FALSE
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdl2exe() DONE .l2num=",.l2num,",.repeat_num=",.i
END
END
;個別実行完了後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
;ロボット状態遷移
robot_status = sta_nomove
.END
.PROGRAM cmdmain(.cmd,.$res,.ret)
;-------------------------------- 
;機能：コマンド実行
;引数：コマンド、コマンド引数
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.$res = ""
IF debug.prt.cmd==TRUE THEN
IF TASKNO==1006 AND (ope_commandpc<>cmd_get_info OR ope_commandpc<>cmd_get_monsp) THEN
;描画しない
ELSE
PRINT "TASKNO=",TASKNO," ->cmdmain() OPE_COMMAND=",ope_command,".cmd=",.cmd
END
END
IF mode_customer==TRUE THEN
CASE .cmd OF
VALUE cmd_exe_start,cmd_exe_move,cmd_exe_restart,cmd_exe_hold,cmd_exe_abort,cmd_exe_l2exe:
;VALUEに追加すればコマンドを無視する
;誤操作時にエラーリセットするのが手間なのでエラーにしないで抜ける
GOTO 10
END
END
CASE .cmd OF
VALUE cmd_exe_reset:
CALL cmdreset(.ret)
CALL exec_alone(.ret)
VALUE cmd_exe_gen:
;引数：動作速度(.sp)
CALL cmdgen(.ret)
BREAK
VALUE cmd_exe_con:
;引数：動作速度(.sp)、第2階層番号(.id)
CALL cmdcon(.ret)
VALUE cmd_exe_one:
;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
CALL cmdone(.ret)
VALUE cmd_exe_teach:
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
CALL cmdteach(.ret)
VALUE cmd_set_tnum,cmd_set_sp,cmd_set_pitch,cmd_set_cord,cmd_set_tool,cmd_set_home,cmd_set_signame,cmd_set_signum,cmd_set_l2exetb:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_set_handio,cmd_set_vtbnum,cmd_set_vtb,cmd_set_lowspar,cmd_set_lowspse,cmd_set_zeroing,cmd_set_colchkm,cmd_set_slowlim,cmd_set_intfpar,cmd_set_genpara,cmd_set_colr:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_set_wset,cmd_set_wspec,cmd_set_wno,cmd_set_genopt:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_set_armslow,cmd_set_linkslo,cmd_set_l3lsp,cmd_set_cvprm,cmd_set_cvvis:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_get_tnum,cmd_get_info,cmd_get_l1info,cmd_get_l2info,cmd_get_l3info,cmd_get_sp,cmd_get_pitch,cmd_get_cord,cmd_get_tool,cmd_get_pos,cmd_get_io,cmd_get_home:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$res,.ret)
VALUE cmd_get_signame,cmd_get_signum,cmd_get_monsp,cmd_get_l2exetb,cmd_get_infoex,cmd_get_hand,cmd_get_handio,cmd_get_vtbnum,cmd_get_vtb,cmd_get_vresult,cmd_get_robotmo:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$res,.ret)
VALUE cmd_get_lowspar,cmd_get_lowspse,cmd_get_gravity,cmd_get_colchkm,cmd_get_slowlim,cmd_get_sa,cmd_get_version,cmd_get_iostat,cmd_get_count,cmd_get_intfpar,cmd_get_genpara,cmd_get_colr:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$res,.ret)
VALUE cmd_get_wset,cmd_get_wspec,cmd_get_winfo,cmd_get_wno,cmd_get_genopt,cmd_get_license:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$res,.ret)
VALUE cmd_get_zoption,cmd_get_armslow,cmd_get_linkslo,cmd_get_l3lsp,cmd_get_loadsta,cmd_get_sagain,cmd_get_cvprm,cmd_get_cvmon,cmd_get_cvvis:
;引数：変数種類(.ptype)、値(.value)
CALL cmdgetparam(.cmd,.$res,.ret)
VALUE cmd_set_l1info,cmd_set_l2info,cmd_set_l3info,cmd_set_winfo:
;CMD_SET_PARAM設定機能は実数配列専用として文字列設定はこちらで実行する
;引数：名前種類[]、名称
CALL cmdnameset(.cmd,.ret)
VALUE cmd_exe_start:
CALL cmdexe(.ret)
VALUE cmd_set_steppos:
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
CALL cmdsetsteppos(.ret)
VALUE cmd_set_step:
;引数：作業情報種類、作業情報配列
CALL cmdsetstep(.ret)
VALUE cmd_set_stepifg:
;引数：作業情報種類、作業情報配列
CALL cmdsetstepifgot(.ret)
VALUE cmd_set_mcrpos:
;引数：作業情報種類、作業情報配列
CALL cmdsetmcrpos(.ret)
VALUE cmd_get_step:
;引数：第2階層番号、第3階層番号
CALL cmdgetstep(.$res,.ret)
VALUE cmd_get_steppos:
;引数：第2階層番号、第3階層番号
CALL cmdgetsteppos(.$res,.ret)
VALUE cmd_get_stepifg:
;引数：第2階層番号、第3階層番号
CALL cmdgetstepifgot(.$res,.ret)
VALUE cmd_get_mcrpos:
;引数：第2階層番号、第3階層番号
CALL cmdgetmcrpos(.$res,.ret)
VALUE cmd_exe_move:
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
CALL cmdmove(.ret)
VALUE cmd_exe_io:
;信号番号、信号状態、状態保持時間
CALL cmdchgio(.ret)
VALUE cmd_exe_vision:
;引数；ビジョンID
CALL cmdvision(.ret)
VALUE cmd_exe_restart:
CALL cmdrestart(.ret)
VALUE cmd_exe_hold:
CALL cmdhold(.ret)
VALUE cmd_exe_abort:
CALL cmdabort(.ret)
VALUE cmd_exe_monsp:
CALL cmdmonsp(.ret)
VALUE cmd_exe_l2exe:
;引数：第2階層番号、第2階層起動条件有効無効、繰返し回数
CALL cmdl2exe(.ret)
VALUE cmd_exe_hand:
;引数：ハンド状態
CALL cmdhand(.ret)
VALUE cmd_exe_resetio:
FOR .i = 1 TO 128
;非常停止割当IOとハンド制御IOは操作しない
IF .i<>SYSDATA(DSIG.EMG_STOP) AND .i<>sig_ext_reboot AND .i<>data_hand_io[robot_master,1] AND .i<>data_hand_io[robot_master,2] AND .i<>data_hand_io[robot_master,3] AND .i<>data_hand_io[robot_master,4] AND .i<>data_hand_io[robot_master,5] AND .i<>data_hand_io[robot_master,6] AND .i<>data_hand_io[robot_master,7] AND .i<>data_hand_io[robot_master,8] THEN
IF .i<>data_hand_io[robot_slave,1] AND .i<>data_hand_io[robot_slave,2] AND .i<>data_hand_io[robot_slave,3] AND .i<>data_hand_io[robot_slave,4] AND .i<>data_hand_io[robot_slave,5] AND .i<>data_hand_io[robot_slave,6] AND .i<>data_hand_io[robot_slave,7] AND .i<>data_hand_io[robot_slave,8] THEN
SIGNAL -(.i)
END
END
END
FOR .i = 1 TO 256
;非常停止割当IOとハンド制御IOは操作しない
IF .i<>SYSDATA(DSIG.EMG_STOP) AND .i<>sig_ext_reboot AND .i<>data_hand_io[robot_master,1] AND .i<>data_hand_io[robot_master,2] AND .i<>data_hand_io[robot_master,3] AND .i<>data_hand_io[robot_master,4] THEN
IF .i<>data_hand_io[robot_slave,1] AND .i<>data_hand_io[robot_slave,2] AND .i<>data_hand_io[robot_slave,3] AND .i<>data_hand_io[robot_slave,4] THEN
SIGNAL -(2000+.i)
END
END
END
VALUE cmd_exe_waitend:
flg_wait_end = TRUE
VALUE cmd_exe_robotmo:
;引数：ロボットモード(0:タブレット、1:ダイレクトティーチ)、ON/OFFフラグ
CALL cmdchgrobotmode(.ret)
VALUE cmd_exe_gravity:
CALL cmdgravityadj(.ret)
VALUE cmd_exe_vscalib:
CALL cmdexevscalib(.ret)
VALUE cmd_exe_sa,cmd_exe_sagain:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_exe_flash:
;引数：変数種類(.ptype)、値(.value)
CALL cmdsetparam(.cmd,.ret)
VALUE cmd_exe_vlescal:
CALL cmdvlesscalib(.ret)
VALUE cmd_exe_vcalchk:
; キャリブレーション精度チェック
CALL cmdexevcalchk(.ret)
VALUE cmd_exe_reboot:
;R/C電源再起動
ZREBOOT Z9894Y
VALUE cmd_set_vselect:
; 他社ビジョン選択
CALL cmdsetvselect(.ret)
VALUE cmd_exe_calxom:
; OMRON CAL_X
CALL cmdexecalxom(.ret)
VALUE cmd_exe_calyom:
; OMRON CAL_Y
CALL cmdexecalyom(.ret)
VALUE cmd_exe_cchkom:
; OMRON キャリブレーション精度チェック
CALL cmdexecalchkom(.ret)
VALUE cmd_exe_cvmove:
CALL cmdexecvmove(.ret)
VALUE cmd_exe_cvset:
CALL cmdexecvset(.ret)
VALUE cmd_exe_cvvcal:
; コンベアビジョンキャリブレーション
CALL cmdexecvvcal(.ret)
ANY :
PRINT "TASKNO=",TASKNO," ->cmdmain() Error occuerd. You try to execute unsupport command."
.ret = err_cmd_type
END
10
IF .ret<>err_no_error THEN
IF TASKNO==pg_com_act THEN
CALL sendresp(.cmd,"",.ret)
END
END
.END
.PROGRAM cmdmonsp(.ret)
;-------------------------------- 
;機能：モニタ速度変更コマンド
;引数：速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL monsp(.ret)
.END
.PROGRAM cmdmove(.ret)
;-------------------------------- 
;機能：指定位置移動コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdmove() .rno=",$prm[TASKNO,1]
END
.rno = VAL($prm[TASKNO,1])
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
.mode = VAL($prm[TASKNO,2])
IF .rno==robot_all THEN
;協調動作
IF TASKNO==pg_master THEN
;開始処理
sys_force_cmode = TRUE
syn_mode_start = TRUE
END
END
.type = VAL($prm[TASKNO,4])
.move = VAL($prm[TASKNO,11]) ;移動する指定軸
.ref_current = VAL($prm[TASKNO,12]);現在値参照有無(0:参照しない、1:参照する)
.ref_move = VAL($prm[TASKNO,19]);基準位置シフトの基準位置移動軸指定
CALL getcurrentpos(.temp_rno,.mode,.#here,.ret)
DECOMPOSE .temp_rno: .here[1] = .#here
NOEXIST_SET_R .here[7] = 0
NOEXIST_SET_R .here[8] = 0
;位置情報
IF .ref_current<>0 AND .ref_move==0 THEN ;基準位置が現在位置の場合
FOR .i = 1 TO 8
.cpos[.i] = .here[.i]
END
ELSE
.cpos[1] = VAL($prm[TASKNO,5]);JT1/X
.cpos[2] = VAL($prm[TASKNO,6]);JT2/Y
.cpos[3] = VAL($prm[TASKNO,7]);JT3/Z
.cpos[4] = VAL($prm[TASKNO,8]);JT4/R1
.cpos[5] = 0
.cpos[6] = 0
.cpos[7] = VAL($prm[TASKNO,9]);EXT1
.cpos[8] = VAL($prm[TASKNO,10]);EXT2
END
.shift[1] = VAL($prm[TASKNO,13]);shift_X
.shift[2] = VAL($prm[TASKNO,14]);shift_Y
.shift[3] = VAL($prm[TASKNO,15]);shift_Z
.shift[4] = VAL($prm[TASKNO,16]);shift_R1
.shift[5] = 0
.shift[6] = 0
.shift[7] = VAL($prm[TASKNO,17]);shift_EXT1
.shift[8] = VAL($prm[TASKNO,18]);shift_EXT2
;コンベヤ位置情報
POINT .#cvpos = #PPOINT(0,0,0,0,0,0)
;基準位置の作成
POINT .temp_rno: .#bpos = #PPOINT(.cpos[1],.cpos[2],.cpos[3],.cpos[4],.cpos[5],.cpos[6]);基軸ポイント
POINT .temp_rno: .#epos = #PPOINT(.cpos[7],.cpos[8],0,0,0,0);外部軸ポイント
CASE .move OF ;移動/シフト移動ステップの移動指定軸
VALUE 0:;基軸のみ動作
POINT .temp_rno: .#epos = #PPOINT(.here[7],.here[8],0,0,0,0);外部軸ポイントを現在値に変更
;基準位置で指定されていない軸は現在値に変更する
CASE .ref_move OF ;基準位置の移動軸指定
VALUE 0:;基準位置指定のシフト移動ではない
VALUE 1:;基軸のみ動作
VALUE 2:;外部軸+基軸動作
VALUE 3:;外部軸のみ動作
POINT .temp_rno: .#bpos = #PPOINT(.here[1],.here[2],.here[3],.here[4],.here[5],.here[6]);基軸ポイントを現在値に変更
END
VALUE 1:;外部軸+基軸動作
;基準位置で指定されていない軸は現在値に変更する
CASE .ref_move OF ;基準位置の移動軸指定
VALUE 0:;基準位置指定のシフト移動ではない
VALUE 1:;基軸のみ動作
POINT .temp_rno: .#epos = #PPOINT(.here[7],.here[8],0,0,0,0);外部軸ポイントを現在値に変更
VALUE 2:;外部軸+基軸動作
VALUE 3:;外部軸のみ動作
POINT .temp_rno: .#bpos = #PPOINT(.here[1],.here[2],.here[3],.here[4],.here[5],.here[6]);基軸ポイントを現在値に変更
END
VALUE 2:;外部軸のみ動作
POINT .temp_rno: .#bpos = #PPOINT(.here[1],.here[2],.here[3],.here[4],.here[5],.here[6]);基軸ポイントを現在値に変更
;基準位置で指定されていない軸は現在値に変更する
CASE .ref_move OF ;基準位置の移動軸指定
VALUE 0:;基準位置指定のシフト移動ではない
VALUE 1:;基軸のみ動作
POINT .temp_rno: .#epos = #PPOINT(.here[7],.here[8],0,0,0,0);外部軸ポイントを現在値に変更
VALUE 2:;外部軸+基軸動作
VALUE 3:;外部軸のみ動作
END
END
IF .mode==mode_jt AND .ref_move<>0 THEN ;基準位置指定のシフト移動で、基準位置の座標種類が各軸値の場合は変換値に変換する。
L3TRN .temp_rno: .trn[1]=.#bpos,1 ;基準位置を各軸値から変換値に変換
POINT .temp_rno: .#bpos2 = .#bpos
POINT .temp_rno: .#bpos = #PPOINT(.trn[1],.trn[2],.trn[3],.trn[4],.trn[5],.trn[6])
.mode = mode_xyzr1ext1 ;動作方法を変換値に変更
END
DECOMPOSE .temp_rno: .bpos[1] = .#bpos
DECOMPOSE .temp_rno: .epos[1] = .#epos
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .#cpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6])
POINT .temp_rno: .#offsetpos = #PPOINT(.shift[1],.shift[2],.shift[3],.shift[4],.shift[5],.shift[6])
;            POINT .temp_rno:.#outpos =#PPOINT(.bpos[1]+.shift[1],.bpos[2]+.shift[2],.bpos[3]+.shift[3],.bpos[4]+.shift[4],.bpos[5]+.shift[5],.bpos[6]+.shift[6])
VALUE 5:
POINT .temp_rno: .#cpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6],.epos[1])
POINT .temp_rno: .#offsetpos = #PPOINT(.shift[1],.shift[2],.shift[3],.shift[4],.shift[5],.shift[6],.shift[7])
;            POINT .temp_rno:.#outpos =#PPOINT(.bpos[1]+.shift[1],.bpos[2]+.shift[2],.bpos[3]+.shift[3],.bpos[4]+.shift[4],.bpos[5]+.shift[5],.bpos[6]+.shift[6],.epos[1]+.shift[7])
VALUE 6,7,8:
POINT .temp_rno: .#cpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6],.epos[1],.epos[2])
POINT .temp_rno: .#offsetpos = #PPOINT(.shift[1],.shift[2],.shift[3],.shift[4],.shift[5],.shift[6],.shift[7],.shift[8])
;            POINT .temp_rno:.#outpos =#PPOINT(.bpos[1]+.shift[1],.bpos[2]+.shift[2],.bpos[3]+.shift[3],.bpos[4]+.shift[4],.bpos[5]+.shift[5],.bpos[6]+.shift[6],.epos[1]+.shift[7],.epos[2]+.shift[8])
END
flg_shift_move = TRUE ;shift_pos関数内処理用フラグON
CALL shift_pos(.rno,.mode,mode_tool,.#cpos,.#offsetpos,.#outpos,.ret)
CALL chk_pos(.rno,.mode,.#outpos,.ret)
IF .ret<>err_no_error THEN
RETURN
END
IF .mode==mode_jt THEN;JMOVE
.sp = safty_move_sp
ELSE;LMOVE
.sp = safty_lmove_sp;指定位置移動とティーチ移動のLMOVEのみに使用
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
IF zsw_man_intfoff==FALSE THEN
INTFCHK ON
ELSE
INTFCHK OFF
END
ELSE
IF kroset==TRUE THEN
INTFCHK ON
END
END
CALL movepos(.rno,.#cvpos,.mode,.type,.#outpos,TRUE,.sp,data_acc,data_dec,data_accu,3,0,0,0,.ret)
IF TASKNO==pg_master THEN
IF sys_force_cmode==TRUE THEN
sys_force_cmode = FALSE
syn_mode_end = TRUE
;終了処理
flg_req_mamode = FALSE
CALL exec_alone(.ret)
END
END
.END
.PROGRAM cmdnameset(.cmd,.ret)
;-------------------------------- 
;機能：名称設定
;引数：文字列配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL nameset(.cmd,.ret)
.END
.PROGRAM cmdone(.ret)
;-------------------------------- 
;機能：作業番号、教示点番号指定移動コマンド
;引数：動作速度(.sp)、第2階層番号(.id)、第3階層番号(.num)、補間方法(.type->0:LMOVE、1:JMOVE)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdone() .rno=",$prm[TASKNO,1]
END
.sp = VAL($prm[TASKNO,2])
.id = VAL($prm[TASKNO,3])
.num = VAL($prm[TASKNO,4])
CALL chg_move_param(0,.sp,data_acc,data_dec,data_accu,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL getposdata(.id,.num,.mode,.type,.#pos,.ret)
;移動方法は指定の方法で上書き
CALL exec_move(.id,.num,.ret)
.END
.PROGRAM cmdreset(.ret)
;-------------------------------- 
;機能：エラーリセットコマンド
;引数：なし
;戻値：成否
;-------------------------------- 
IF g_last_error==err_no_error THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() skipped reset command."
END
RETURN
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() Starting reset command."
END
;システム管理のエラー情報の初期化のみのためロボット別処理不要
.ret = err_no_error
CALL update_error(.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdreset() Done reset command."
END
.END
.PROGRAM cmdrestart(.ret)
;-------------------------------- 
;機能：CONTINUEコマンド
;引数：ロボット番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;外部制御盤操作を許容する
IF 0 THEN
IF TASKNO<>pg_com_noact THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,"->cmdrestart() 非動作コマンドポートからの実行指示のみ可能"
END
RETURN
END
END
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->TASKNO=",TASKNO,",ROBOT_NUM=",$prm[TASKNO,1]
END
IF flg_load_now<>FALSE THEN
;作業転送転送未完
.ret = err_not_load
CALL update_error(.ret)
RETURN
END
;動作プログラム実行要否確認
CALL check_exec_pg(.flg_exec_main)
IF .flg_exec_main==FALSE THEN
RETURN; 再開出来ない状態(プログラムが実行中!?)
END
;個別実行再開ではない場合
IF flg_single_move==FALSE THEN
;作業グループ番号変更確認
IF data_wset_ena<>FALSE THEN
CALL get_workno(.work_no,.ret)
IF .ret<>err_no_error OR data_cur_workno<>.work_no THEN
.ret = err_work_unmatc
CALL update_error(.ret)
RETURN
END
END
END
;PCプログラムから実行するためこのタイミングでOPE_COMMANDを更新する
ope_command = cmd_exe_restart
IF disable_continu==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->START CHECK ROBOT-ACTION STATUS"
END
exout_start_fla = FALSE
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
IF flg_master_move==TRUE OR flg_slave_move==TRUE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "cmdrestart()->ロボットの動作中のため再開操作を実行できません。"
END
RETURN
END
;非常停止を確認する
.dsig_emg = SYSDATA(DSIG.EMG_STOP)
IF .dsig_emg<>0 THEN
IF SIG(.dsig_emg)==ON THEN
PRINT "cmdrestart()->Need to clear EMG-STOP button."
.ret = err_emg_on
CALL update_error(.ret)
RETURN
END
END
;モータOFFしている場合はモータONする
IF SWITCH(POWER ,1)==OFF OR SWITCH(POWER ,2)==OFF THEN
UTIMER .@nowtime = 0
DO
MC ZPOWER ON
IF UTIMER(.@nowtime)>power_timeout THEN
IF SWITCH(POWER ,1)==OFF THEN
PRINT "Can NOT motor-on on MASTER-ROBOT."
END
IF SWITCH(POWER ,2)==OFF THEN
PRINT "Can NOT motor-on on SLAVE-ROBOT."
END
.ret = err_poweron
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON)
END
;位置チェック
IF flg_enable_stop==TRUE THEN
CALL check_pos(VAL($prm[TASKNO,1]),cmd_exe_restart,.ret)
END
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
exout_start_fla = FALSE
;作業実行フラグ
data_execute = TRUE
;中断された作業を継続実行する
.l2num = data_cur_l2rec[robot_master]
.l3num = data_cur_l3rec[robot_master]
CALL get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
IF .req_wstart==TRUE THEN
;並列中のスレーブロボット動作
IF data_cur_l2rec[robot_slave]<>0 AND data_cur_l3rec[robot_slave]<>0 THEN
;スレーブロボット並列動作継続実行
flg_slave_move = TRUE
END
END
IF .l2num<>0 AND .l3num<>0 THEN
;マスターロボット動作継続実行
flg_master_move = TRUE
;非並列中のスレーブロボット単独動作
IF now_move_l3num[robot_master]<>0 THEN
IF now_move_l3num[robot_slave]==0 AND data_robottype[.l2num,now_move_l3num[robot_master]]==robot_slave THEN
IF data_l3type[.l2num,.l3num]==l3type_move OR data_l3type[.l2num,.l3num]==l3type_call OR data_l3type[.l2num,.l3num]==l3type_shift THEN
;スレーブロボット動作継続実行
flg_slave_move = TRUE
;マスターロボットスレーブ動作待ちタイマーリセット
UTIMER @slavetime = 0
END
END
END
END
; ビジョン並列インターロックタイマー初期化
UTIMER @vtime_mas = 0
UTIMER @vtime_sla = 0
; ビジョン通信タイマー初期化
UTIMER @vtime_vision = 0
UTIMER @vtime_vset_pos = 0
UTIMER @vtime_vchk_pc = 0
UTIMER @vtime_vchk_sig = 0
;スロースタート確認
CALL chk_slow_start
;status_check関数でエラーを発生させないようにフラグを操作
flg_restart = TRUE
;エラー状態を一旦解除する
g_last_error = err_no_error
;status_check関数でエラーを発生させないように操作したフラグを戻す
flg_main_run = TRUE
flg_tablet_run[1] = TRUE
flg_tablet_run[2] = TRUE
;コンベア同期関連初期化
CALL cv_init
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
;コンベア同期バッファリセット
flg_cvpc_stop = TRUE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cvpc_stop = FALSE
.ret = err_cvpc_ready
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run==FALSE)
CALL cv_init
FOR .i = 1 TO 2
FOR .j = 1 TO 2
CALL cvaxis_check(.i,cv_coopjt[.i,.j],.ret)
IF .ret==0 THEN
IF cv_ulim[.j]>=cv_llim[.j] THEN
.ret = err_cv_setting
CALL update_error(.ret)
RETURN
END
CVSWITCH .i:  ON
ELSE
.ret = 0
END
END
END
flg_cvpc_stop = FALSE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_cvpc_ready
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run<>FALSE)
END
;中断された状態から再開
UTIMER .@nowtime = 0
.comp_flag = FALSE
MC CONTINUE
IF .req_cstart==FALSE THEN
MC CONTINUE 2:; 協調動作中は必要ない！！
END
DO
IF (SWITCH(CS ,1)==ON AND TASK(1)==1) AND (SWITCH(CS ,2)==ON AND TASK(2)==1) THEN
.comp_flag = TRUE
END
TWAIT ascycle
UNTIL (.comp_flag==TRUE OR UTIMER(.@nowtime)>boot_timeout)
IF SWITCH(CS ,1)==OFF OR SWITCH(CS ,2)==OFF THEN
IF SWITCH(CS ,1)==OFF THEN
PRINT "Can NOT continue program on MASTER-ROBOT."
END
IF SWITCH(CS ,2)==OFF THEN
PRINT "Can NOT continue program on SLAVE-ROBOT."
END
.ret = err_main_start
CALL update_error(.ret)
RETURN
END
;ロボット状態遷移
IF flg_single_move==FALSE THEN
robot_status = sta_exe
ELSE
robot_status = sta_l2exe
END
;status_check関数でエラーを発生させないように操作したフラグを戻す
flg_restart = FALSE
RETURN
ELSE
PRINT "cmdrestart()->再開できません。"
END
END
.END
.PROGRAM cmdsetmcrpos(.ret)
;-------------------------------- 
;機能：マクロPG用位置変数設定
;引数：呼び出し番号、位置変数番号、位置変数名、
;      座標種類、ツール番号、位置情報1〜4
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setmcrpos(.ret)
.END
.PROGRAM cmdsetparam(.cmd,.ret)
;-------------------------------- 
;機能：変数設定コマンド
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setparam(.cmd,.ret)
.END
.PROGRAM cmdsetstep(.ret)
;-------------------------------- 
;機能：作業情報の設定
;引数：実数配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setstep(.ret)
.END
.PROGRAM cmdsetstepifgot(.ret)
;-------------------------------- 
;機能：作業用条件分岐詳細設定
;引数：2:第2階層番号、3:第3階層番号、4:条件番号、
;      5:分岐指定、6:分岐判断種類、7:分岐判断材料、8:分岐判定閾値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setstepifgoto(.ret)
.END
.PROGRAM cmdsetsteppos(.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL setsteppos(.ret)
.END
.PROGRAM cmdsetvselect(.ret)
;-------------------------------- 
;機能：他社ビジョン選択
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.mode = VAL($prm[TASKNO,2]); ビジョン種類
CALL vis_change(.mode)
.END
.PROGRAM cmdteach(.ret)
;-------------------------------- 
;機能：手動移動操作コマンド
;引数：動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、動作方向フラグ(0:動かない、1:+方向、-1:マイナス方向)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
;ロボット番号
.rno = VAL($prm[TASKNO,1])
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
flg_shift_move = FALSE ;基準位置シフトフラグOFF(shift_pos関数内で使用)
;動作方法
.mode = VAL($prm[TASKNO,2])
;補間方法
.type = VAL($prm[TASKNO,5])
;位置情報(実機調整が必要な可能性有)
;位置情報MASTER
.flag[1,1] = VAL($prm[TASKNO,6]);JT1/X
.flag[1,2] = VAL($prm[TASKNO,7]);JT2/Y
.flag[1,3] = VAL($prm[TASKNO,8]);JT3/Z
.flag[1,4] = VAL($prm[TASKNO,9]);JT4/R1
.flag[1,5] = 0;
.flag[1,6] = 0;
.flag[1,7] = VAL($prm[TASKNO,10]);EXT1
.flag[1,8] = VAL($prm[TASKNO,16]);EXT2
;位置情報SLAVE
.flag[2,1] = VAL($prm[TASKNO,11]);JT1/X
.flag[2,2] = VAL($prm[TASKNO,12]);JT2/Y
.flag[2,3] = VAL($prm[TASKNO,13]);JT3/Z
.flag[2,4] = VAL($prm[TASKNO,14]);JT4/R1
.flag[2,5] = 0;
.flag[2,6] = 0;
.flag[2,7] = VAL($prm[TASKNO,15]);EXT1
.flag[2,8] = VAL($prm[TASKNO,17]);EXT2
;R10暫定対策
IF .type==0 AND .rno<>0 THEN ;単独アーム指定の場合は、それぞれのアームを確認
IF .flag[1,7]<>0 OR .flag[1,8]<>0 OR .flag[2,7]<>0 OR .flag[2,8]<>0 THEN
.type = 1 ;各軸補間に強制的に設定
END
IF (.flag[1,4]<>0 AND data_teachcoord==1) OR (.flag[2,4]<>0 AND data_teachcoord==1) THEN ;4軸ツール移動の場合
.type = 1 ;各軸補間に強制的に設定
END
ELSEIF .type==0 AND .rno==0 THEN ;両アーム指定の場合は、下アームのみ確認
IF .flag[1,7]<>0 OR .flag[1,8]<>0 THEN
.type = 1 ;各軸補間に強制的に設定
END
IF (.flag[1,4]<>0 AND data_teachcoord==1) THEN ;4軸ツール移動の場合
.type = 1 ;各軸補間に強制的に設定
END
END
;R10暫定対策ここまで
;コンベヤ位置情報
POINT .#cvpos = #PPOINT(0,0,0,0,0,0)
CALL get_jttype(.rno,.mode,.#axis_type)
DECOMPOSE .temp_rno: .axis_type[1] = .#axis_type
NOEXIST_SET_R .axis_type[7] = 0
NOEXIST_SET_R .axis_type[8] = 0
.axis = SYSDATA(ZROB.NOWAXIS,.temp_rno)
FOR .i = 1 TO 8
CASE .rno OF
VALUE robot_all:
;協調動作
IF TASKNO==pg_master THEN
;開始処理
sys_force_cmode = TRUE
syn_mode_start = TRUE
END
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[1,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[1,.i]
ANY :
.offsetpos[.i] = 0
END
VALUE robot_master:
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[1,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[1,.i]
ANY :
.offsetpos[.i] = 0
END
VALUE robot_slave:
CASE .axis_type[.i] OF
VALUE mode_lin:
.offsetpos[.i] = data_teachpitch*.flag[2,.i]
VALUE mode_rot:
.offsetpos[.i] = data_teachrot*.flag[2,.i]
ANY :
.offsetpos[.i] = 0
END
END
END
;基準用現在値取得
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CASE .axis OF
VALUE 4:
POINT .temp_rno: .#offsetpos = #PPOINT(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6])
VALUE 5:
POINT .temp_rno: .#offsetpos = #PPOINT(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6],.offsetpos[7])
VALUE 6,7,8:
POINT .temp_rno: .#offsetpos = #PPOINT(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6],.offsetpos[7],.offsetpos[8])
END
CALL shift_pos(.rno,.mode,data_teachcoord,.#cpos,.#offsetpos,.#outpos,.ret)
CALL chk_pos(.rno,.mode,.#outpos,.ret)
IF .ret<>err_no_error THEN
RETURN
END
IF .mode==mode_jt THEN;JMOVE
.sp = safty_move_sp
ELSE;LMOVE
.sp = safty_lmove_sp;指定位置移動とティーチ移動のLMOVEのみに使用
END
INTFCHK OFF
CALL movepos(.rno,.#cvpos,.mode,.type,.#outpos,TRUE,.sp,data_acc,data_dec,data_accu,3,0,0,0,.ret)
IF TASKNO==pg_master THEN
IF sys_force_cmode==TRUE THEN
sys_force_cmode = FALSE
syn_mode_end = TRUE
;終了処理
flg_req_mamode = FALSE
CALL exec_alone(.ret)
END
END
.END
.PROGRAM cmdvision(.ret)
;-------------------------------- 
;機能：ビジョンコマンド
;引数：ビジョンID
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF VAL($prm[TASKNO,2])>999 THEN
.ret = err_bat_value
RETURN
END
;ビジョンID変換
CALL convert_vid(mode_add,VAL($prm[TASKNO,7]),VAL($prm[TASKNO,2]),.vision_id)
CALL vision_main(VAL($prm[TASKNO,1]),.vision_id,VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]),.ret)
.END
.PROGRAM cmdvlesscalib(.ret)
;-------------------------------- 
;機能：ビジョンなし装置補正コマンド
;引数：
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF VAL($prm[TASKNO,2])>999 OR VAL($prm[TASKNO,2])<1 THEN
.ret = err_bat_value
RETURN
END
POINT .t = TRANS(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]))
POINT .p1 = TRANS(VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),VAL($prm[TASKNO,8]))
POINT .p2 = TRANS(VAL($prm[TASKNO,9]),VAL($prm[TASKNO,10]),VAL($prm[TASKNO,11]),VAL($prm[TASKNO,12]))
CALL vless_calmain(VAL($prm[TASKNO,1]),VAL($prm[TASKNO,2]),.&t,.&p1,.&p2,VAL($prm[TASKNO,13]),.ret)
.END
.PROGRAM cmdzero(.rno,.jtno,.val,.ret)
;-------------------------------- 
;ゼロイング設定コマンド
;引数：ロボット番号、軸番号、軸設定値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.margin = 5
;サイクル中実行不可
IF SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON THEN
.ret = err_robot_busy
RETURN
END
GETULIMIT .rno: .#ulim
GETLLIMIT .rno: .#llim
DECOMPOSE .rno: .ulim[1] = .#ulim
DECOMPOSE .rno: .llim[1] = .#llim
.ulim[3] = .ulim[3]+.margin
.llim[3] = .llim[3]-.margin
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
;モータ電源は自動OFF(モータ電源ONは他のシーケンスに任せる)
IF SWITCH(POWER ,1)==ON OR SWITCH(POWER ,2)==ON THEN
CALL cmdabort(.ret)
UTIMER .@nowtime = 0
DO
MC ZPOWER OFF
IF UTIMER(.@nowtime)>power_timeout THEN
PRINT "->RdyBoot() Can NOT motor-off."
.ret = err_motor_off
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(POWER ,1)==OFF AND SWITCH(POWER ,2)==OFF)
END
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
IF .jtno>.axis THEN
.ret = err_bad_axesno
RETURN
ELSE
.jt = .jtno
IF .jtno>4 THEN
.jt = .jtno+2
END
IF SYSDATA(JTEXIST,.rno,.jt)==FALSE THEN
.ret = err_bad_axesno
RETURN
ELSE
IF .val>.ulim[.jt] OR .val<.llim[.jt] THEN
.ret = err_bat_value
RETURN
END
ZJZERO .rno: .jt , .val
END
END
ANY :
.ret = err_bad_rno
RETURN
END
RETURN
.END
.PROGRAM coffee()
MC exec 1: lp1
MC exec 2: upr
.END
.PROGRAM coffeeh1()
SPEED 5 ALWAYS
JMOVE #h1_home
JMOVE #h1_1
WAIT st1==1
JMOVE #h1_2
JMOVE #h1_3
BREAK
st2 = 1
JMOVE #h1_4
JMOVE #h1_5
JMOVE #h1_6
JMOVE #h1_7
BREAK
st3 = 1
JMOVE #h1_8
JMOVE #h1_home
SPEED 5 ALWAYS
WAIT st4==1
JMOVE #h1_9
JMOVE #h1_w1
JMOVE #h1_w2
JMOVE #h1_w3
JMOVE #h1_w4
JMOVE #h1_home
BREAK
st5 = 1
.END
.PROGRAM coffeeh2()
SPEED 5 ALWAYS
JMOVE #h2_home
JMOVE #h2_1
JMOVE #h2_2
JMOVE #h2_3
JMOVE #h2_4
BREAK
st1 = 1
WAIT st2==1
JMOVE #h2_5
JMOVE #h2_6
WAIT st3==1
JMOVE #h2_7
JMOVE #h2_8
SPEED 5 ALWAYS
JMOVE #h2_9
JMOVE #h2_10
JMOVE #h2_11
JMOVE #h2_12
JMOVE #h2_13
BREAK
st4 = 1
WAIT st5==1
TWAIT 3
JMOVE #h2_12
JMOVE #h2_11
JMOVE #h2_10
JMOVE #h2_9
JMOVE #h2_8
JMOVE #h2_7
JMOVE #h2_14
JMOVE #h2_15
JMOVE #h2_16
JMOVE #h2_home
.END
.PROGRAM coffeepc()
;WHILE TRUE DO
$cnt[0] = "null"
UDP_RECVFROM ret,52000,$cnt[0],p,2
TYPE $cnt[0]
;END
;IF $cnt[0]!="null" THEN
st1 = 0
st2 = 0
st3 = 0
st4 = 0
st5 = 0
MC execute coffeeh1
MC execute 2: coffeeh2
;END
;END
.END
.PROGRAM coffeeroboth1()
CP OFF
ACCURACY 0.01 ALWAYS
sg1 = 0
sg2 = 0
sg3 = 0
sg4 = 0
sg5 = 0
SPEED 4 ALWAYS
JMOVE #h1_home
JMOVE #h1_1
JMOVE #h1_2
JMOVE #h1_3
JMOVE #h1_4
JMOVE #h1_5
BREAK
sg1 = 1
WAIT sg2==1
JMOVE #h1_6
JMOVE #h1_7
JMOVE #h1_8
JMOVE #h1_9
JMOVE #h1_10
WAIT sg3==1
JMOVE #h1_9
JMOVE #h1_8
JMOVE #h1_7
JMOVE #h1_6
JMOVE #h1_11
JMOVE #h1_12
JMOVE #h1_13
BREAK
sg4 = 1
JMOVE #h1_14
.END
.PROGRAM coffeeroboth2()
CP OFF
ACCURACY 0.01 ALWAYS
SPEED 4 ALWAYS
sg1 = 0
sg2 = 0
sg3 = 0
ct = 100
sg4 = 0
JMOVE #h2_home
JMOVE #h2_1
WAIT sg1==1
JMOVE #h2_2
JMOVE #h2_3
BREAK
sg2 = 1
JMOVE #h2_4
JMOVE #h2_5
JMOVE #h2_6
JMOVE #h2_7
JMOVE #h2_8
JMOVE #h2_9
IF $drink=="Espresso\n" THEN
SPEED 5 ALWAYS
ct = 25
JMOVE #h2_e1
JMOVE #h2_e2
TWAIT 0.5
JMOVE #h2_e3
END
IF $drink=="Americano\n" THEN
SPEED 4 ALWAYS
ct = 45
JMOVE #h2_a1
JMOVE #h2_a2
TWAIT 0.5
JMOVE #h2_a3
END
IF $drink=="Cappuccino\n" THEN
SPEED 4 ALWAYS
ct = 32
JMOVE #h2_c1
JMOVE #h2_c2
TWAIT 0.5
JMOVE #h2_c3
END
IF $drink=="Latte\n" THEN
SPEED 4 ALWAYS
ct = 30
JMOVE #h2_l1
JMOVE #h2_l2
TWAIT 0.5
JMOVE #h2_l3
END
SPEED 16 ALWAYS
L3LMOVE #h2_10,1
JMOVE #h2_11
TWAIT ct
sg3 = 1
WAIT sg4==1
JMOVE #h2_12
isready = TRUE
coffeemade = TRUE
.END
.PROGRAM coffeerobotpc()
port = 49152
max_length = 255
tout_open = 5
tout_rec = 5
text_id = 0
tout = 60
eret = 0
rret = 0
stopcon = FALSE;
;WHILE TRUE DO
con_begin:
CALL open_socket;Connecting communication 
IF sock_id<0 THEN
IF stopcon==TRUE THEN
GOTO exit
END
GOTO con_begin
END
PRINT "Connection established"
cyc_begin:
IF stopcon==TRUE THEN
GOTO exit
END
tout_rec = 5
CALL tcp_recv;Receiving the result of processing 1 
IF rret==-34024 THEN
PRINT "Recieve timeout"
GOTO cyc_begin
END
IF rret==-34025 THEN
PRINT "Connection error"
CALL close_socket
GOTO con_begin
END
IF rret==0 THEN
PRINT $recv_buf[1]
$drink = ""
IF $recv_buf[1]=="Cappuccino\n" THEN
$drink = $recv_buf[1]
END
IF $recv_buf[1]=="Espresso\n" THEN
$drink = $recv_buf[1]
END
IF $recv_buf[1]=="Americano\n" THEN
$drink = $recv_buf[1]
END
IF $recv_buf[1]=="Latte\n" THEN
$drink = $recv_buf[1]
END
coffeemade = FALSE
IF $drink!="" THEN
MC EXECUTE coffeeroboth1
MC EXECUTE 2: coffeeroboth2
END
WAIT coffeemade==TRUE
TWAIT 4
eret = 0
$sdata[1] = "OK\n"
CALL tcp_send(eret,$sdata[1])
END
GOTO cyc_begin
;END    
exit:
CALL close_socket;Closing communication 
exit_end:
.END
.PROGRAM coft()
MC execute coffeeroboth1
MC execute 2: coffeeroboth2
.END
.PROGRAM comment___() ; Comments for IDE. Do not use.
; @@@ PROJECT @@@
; @@@ HISTORY @@@
; @@@ INSPECTION @@@
; @@@ CONNECTION @@@
; 
; 
; 
; @@@ PROGRAM @@@
; @@@ TRANS @@@
; @@@ JOINTS @@@
; @@@ REALS @@@
; @@@ STRINGS @@@
; @@@ INTEGER @@@
; @@@ SIGNALS @@@
; @@@ TOOLS @@@
; @@@ BASE @@@
; @@@ FRAME @@@
; @@@ BOOL @@@
.END
.PROGRAM commu_log(.mode_no,.$str)
;-------------------------------- 
;機能：通信制御ログ保存
;引数：送信(1)or受信(2),送受信文字列
;戻値：なし
;-------------------------------- 
; 実行タスク取得
IF TASKNO==1006 THEN
.task_no = 2; 非動作系
ELSE
.task_no = 1; 動作系
END
; 実行コマンド取得
.$buf = .$str
.$res_command = $DECODE(.$buf,",",0)
.res_command = VAL(.$res_command); 今回
; ログの保存確認
IF (log_mode[.task_no] BAND .mode_no)==FALSE THEN
IF debug.prt.log<>FALSE AND bef_res<>.res_command THEN
PRINT "commu_log()->RETURN[mode] task_no=",.task_no,", .mode_no=",.mode_no
END
GOTO end
END
; 常時実行コマンドの送信データは保存しない
IF (.task_no==2 AND (.res_command==1001 OR .res_command==1006 OR .res_command==1009 OR .res_command==1017 OR .res_command==1026)) THEN
IF debug.prt.log<>FALSE AND bef_res<>.res_command THEN
PRINT "commu_log()->RETURN[command] task_no=",.task_no,", .res_command=",.res_command
END
GOTO end
END
;
IF log_mode[.task_no]==3 THEN
IF .mode_no==1 THEN
.$mode = " SEND ->"; 送信
ELSE
.$mode = " RECV <- "; 受信
END
ELSE
IF log_mode[.task_no]==1 THEN
.$mode = ""; 送信
ELSE
.$mode = " "; 受信
END
END
.$log = $DATE(3)+" "+$TIME+" :"+.$mode+.$str; ログデータ作成
$log_commu[.task_no,log_count[.task_no]] = .$log; ログデータ保存
log_count[.task_no] = log_count[.task_no]+1; ログカウンタカウントアップ
IF log_count[.task_no]>log_max_num THEN; ログカウンタ上限超えの為リセット
log_count[.task_no] = 1
END
;
IF debug.prt.log<>FALSE THEN
PRINT "commu_log()->LOGGING task_no=",.task_no,", $log=",.$log
END
end:
bef_res = .res_command; 1つ前
RETURN
.END
.PROGRAM cont_timing()
;-------------------------------- 
;機能：マスタとスレーブのタイミングを合わせる
;引数：なし
;戻値：なし
;-------------------------------- 
.rob_no = TASKNO;実行ロボット番号
IF .rob_no==1 THEN;マスタロボット
.chk_rob = 2;相手側のロボット番号
ELSE;スレーブロボット
.chk_rob = 1;相手側のロボット番号
END
WHILE (COOPSTATUS(.chk_rob)==3 OR COOPSTATUS(.chk_rob)==4) DO;相手ロボットがMASTERまたはSLAVE状態
TWAIT ascycle;相手ロボットのALONE待ち
UTIMER @tim_aft_alone2[.rob_no] = 0;ALONE後のタイマをリセット
END
WAIT NOT (0<UTIMER(@tim_aft_alone2[.rob_no]) AND UTIMER(@tim_aft_alone2[.rob_no])<cont_time);前回のALONE後、3秒間は新たにMASTER/SLAVE宣言させない
IF .rob_no==1 THEN;マスタロボット
MASTER;協調開始（マスタ）
ELSE;スレーブロボット
SLAVE;協調開始（スレーブ）
END
ALONE;協調停止命令
TWAIT ascycle;ALONE待ち
UTIMER @tim_aft_alone2[.rob_no] = 0;ALONE後のタイマをリセット
RETURN
.END
.PROGRAM conv_buff_chk(.cv_no) ; バッファデータ動作範囲チェック
.arm_no = cv_arm_no[.cv_no];使用アーム
.jt_no = cv_jt_no[.cv_no];使用コンベア軸
check:
IF 0<cv_buff_num[.cv_no] THEN ;バッファが存在する時のみ
IF cv_llim[.cv_no]<CVPOS2:.arm_no(cv_sync_no[.cv_no,cv_work_no[.cv_no]],.jt_no)+cv_gap[.cv_no,cv_work_no[.cv_no]] THEN
ZCNTUP cv_work_no[.cv_no],cv_max_buff[.cv_no]; バッファポインタインクリメント
cv_buff_num[.cv_no] = cv_buff_num[.cv_no]-1
;      cv_thr_counter[.cv_no] = cv_thr_counter[.cv_no]+1 ;スルー数インクリメント
GOTO check
END
SIGNAL ix_cv_buff[.cv_no,1]
.now_1st = CVPOS2:.arm_no(cv_sync_no[.cv_no,cv_work_no[.cv_no]],.jt_no)+cv_gap[.cv_no,cv_work_no[.cv_no]]
cv_bno[.cv_no,1] = cv_work_no[.cv_no]
cv_buff_work[.cv_no,1] = cv_sync_no[.cv_no,cv_work_no[.cv_no]]
IF cv_vision[.cv_no]==1 THEN
cv_buff_off[.cv_no,1] = cv_gap[.cv_no,cv_work_no[.cv_no]]
ELSE
cv_buff_off[.cv_no,1] = 0
END
IF cv_ulim[.cv_no]<=.now_1st THEN
SIGNAL ix_cv_area[.cv_no,1]; 1つ目起動条件範囲内ON
ELSE
SIGNAL -ix_cv_area[.cv_no,1],-ix_cv_area[.cv_no,2]; 1つ目、2つ目起動条件範囲内OFF
END
;
IF 2<=cv_buff_num[.cv_no] THEN
.next_work_no = cv_work_no[.cv_no]
ZCNTUP .next_work_no,cv_max_buff[.cv_no]
SIGNAL ix_cv_buff[.cv_no,2];バッファ内2つ以上あり
.now_2nd = CVPOS2:.arm_no(cv_sync_no[.cv_no,.next_work_no],.jt_no)+cv_gap[.cv_no,.next_work_no];2つ目のコンベア位置
cv_bno[.cv_no,2] = .next_work_no
cv_buff_work[.cv_no,2] = cv_sync_no[.cv_no,.next_work_no]
IF cv_vision[.cv_no]==1 THEN
cv_buff_off[.cv_no,2] = cv_gap[.cv_no,.next_work_no]
ELSE
cv_buff_off[.cv_no,2] = 0
END
IF cv_ulim[.cv_no]<=.now_2nd THEN; 上流エリア内
SIGNAL ix_cv_area[.cv_no,2]; 2つ目起動条件範囲内ON
ELSE
SIGNAL -ix_cv_area[.cv_no,2]; 2つ目起動条件範囲内OFF
END
ELSE
SIGNAL -ix_cv_buff[.cv_no,2]; 2つ目起動条件範囲内OFF
SIGNAL -ix_cv_area[.cv_no,2]; 2つ目バッファワークなし
END
ELSE
SIGNAL -ix_cv_buff[.cv_no,1],-ix_cv_buff[.cv_no,2]; バッファワークなし
SIGNAL -ix_cv_area[.cv_no,1],-ix_cv_area[.cv_no,2]; 起動条件範囲内OFF
END
end:
RETURN
.END
.PROGRAM conv_clear(.cv_no) ;コンベア制御初期化プログラム
;
NOEXIST_SET_R cv_max_buff[.cv_no] = 99
FOR .arm = 1 TO 2; 下アーム、上アーム
cv_need[.arm,.cv_no] = 0
cv_comp[.arm,.cv_no] = 0
END
;
IF cv_vision[.cv_no]==1 AND TASK(1002)==1 THEN;      固定ビジョン
pc2_restart = ON
END
SIGNAL -ix_cv_buff[.cv_no,1],-ix_cv_buff[.cv_no,2]; バッファワークなし
SIGNAL -ix_cv_area[.cv_no,1],-ix_cv_area[.cv_no,2]; 起動条件範囲内OFF
SIGNAL -ix_cv_pulse[.cv_no];  リセット信号最低保持信号
SIGNAL -cv_vis_comp
cv_no_now[.cv_no] = 1;   CV番号（現在）の初期化
rslt_ng_num[.cv_no] = 0; CVごとの結果番号範囲外個数
cv_buff_num[.cv_no] = 0 ;現在バッファ個数の初期化
cv_buff_no[.cv_no] = 1 ; バッファ番号の初期化
cv_work_no[.cv_no] = 1 ; ワーク番号の初期化
cv_no_bak[.cv_no] = cv_max_buff[.cv_no] ;前回のコンベア番号
cv_thr_counter[.cv_no] = 0 ;スルー数インクリメント
FOR .i = 1 TO 2;先頭、2番目
cv_work[.cv_no,.i] = 0 ;.i番目 動作テーブルの初期化
cv_reserve[.cv_no,.i] = 0
cv_buffer[.cv_no,.i] = 0
cv_work_busy[.cv_no,.i] = OFF
cv_buff_work[.cv_no,.i] = 1
cv_bno[.cv_no,.i] = 0
cv_wno[.cv_no,.i] = 0
END
FOR .i = 1 TO cv_max_buff[.cv_no]
cv_work_exist[.cv_no,.i] = 0
END
FOR .i = 0 TO 6;BITS数
IF cv_no_now[.cv_no] BAND 2^.i THEN
SOUT (ix_cv_work_no[.cv_no,1]+.i) 
ELSE
SOUT -(ix_cv_work_no[.cv_no,1]+.i) 
END
END
NOEXIST_SET_R cv_shift_num[.cv_no,1] = 1;X方向位置生成数
NOEXIST_SET_R cv_shift_num[.cv_no,2] = 1;Y方向位置生成数
NOEXIST_SET_R cv_shift[.cv_no,1] = 0;    X方向位置生成ピッチ
NOEXIST_SET_R cv_shift[.cv_no,2] = 0;    Y方向位置生成ピッチ
cv_reset_flg[.cv_no] = OFF; コンベアリセット終了
IF 0<cv_jt_no[.cv_no] THEN
POINT conv_frm[.cv_no] = CVSLOPE:cv_arm_no[.cv_no](cv_jt_no[.cv_no])+RY(-90)
CVSET cv_arm_no[.cv_no]: cv_work_pitch[.cv_no]-100,cv_no_bak[.cv_no] ;コンベアに規定値-5[mm]のコンベア値をセット
END
RETURN
.END
.PROGRAM conv_fresh()
;
NOEXIST_SET_R flg_cv_clear = 0
IF flg_cv_clear<>0 THEN
FOR .cv_no = 1 TO cv_num
FOR .i = 1 TO 2
cv_reserve[.cv_no,.i] = OFF
cv_buffer[.cv_no,.i] = OFF
END
END
flg_cv_clear = OFF
END
.END
.PROGRAM conv_make_pos(.cv_no) ;位置作成
;-------------------------------- 
;機能：コンベアリセット信号監視
;引数：実コンベア番号
;戻値：無し
;--------------------------------
.arm_no = cv_arm_no[.cv_no];使用アーム
.jt_no = cv_jt_no[.cv_no];使用コンベア軸
NOEXIST_SET_R .now_flg[.cv_no] = OFF
;
.bak_flg[.cv_no] = .now_flg[.cv_no]
IF cv_vision[.cv_no]==1 THEN ;固定ビジョン付きコンベアの場合
;
.now_flg[.cv_no] = SIG(cv_vis_comp);                   ビジョン処理完了
IF .bak_flg[.cv_no]==OFF AND .now_flg[.cv_no]==ON THEN; ビジョン処理完了立上がり
.before_num = cv_buff_num[.cv_no]
.start_no = cv_buff_no[.cv_no]; 最終バッファ番号
FOR .vno = 1 TO v.num
CALL cv_rap_check(.cv_no,.start_no,.before_num,&vwork[cv_vision_id,.vno],.rap)
IF .rap==OFF THEN
cv_sync_no[.cv_no,cv_buff_no[.cv_no]] = cv_no_now[.cv_no] ; コンベアワーク番号
POINT cv_pos[.cv_no,cv_buff_no[.cv_no]] = conv_frm[.cv_no]+TRANS(cv_offset)-conv_frm[.cv_no]+vwork[cv_vision_id,.vno]; 計測結果位置
cv_vres[.cv_no,cv_buff_no[.cv_no]] = vwork_res[cv_vision_id,.vno];
cv_gap[.cv_no,cv_buff_no[.cv_no]] = DX(-cv_vis_frm+vwork[cv_vision_id,.vno])
cv_work_exist[.cv_no,cv_buff_no[.cv_no]] = ON;  ワークあり
ZCNTUP cv_buff_no[.cv_no],cv_max_buff[.cv_no]; バッファポインタインクリメント
cv_work_exist[.cv_no,cv_buff_no[.cv_no]] = OFF; 次ワークはありをクリア
cv_buff_num[.cv_no] = cv_buff_num[.cv_no]+1;    バッファ数インクリメント
END
END
.cv_next = cv_buff_no[.cv_no]
ZCNTUP .cv_next,cv_max_buff[.cv_no];                次回バッファポインタインクリメント
cv_work_exist[.cv_no,.cv_next] = OFF;               次ワークはありをクリア
cv_no_bak[.cv_no] = cv_no_now[.cv_no] ;             コンベア番号保存
ZCNTUP cv_no_now[.cv_no],cv_max_buff[.cv_no];      コンベアワーク番号インクリメント
;
FOR .i = 0 TO 6
IF cv_no_now[.cv_no] BAND 2^.i THEN
SOUT ix_cv_work_no[.cv_no,1]+.i 
ELSE
SOUT -(ix_cv_work_no[.cv_no,1]+.i) 
END
END
CVSET .arm_no: cv_work_pitch[.cv_no],cv_no_now[.cv_no] ;コンベアに規定値のコンベア値を強制セット
cv_reset_flg[.cv_no] = OFF; コンベアリセット終了
END
END
IF cv_vision[.cv_no]==0 THEN ;ビジョンなしコンベアの場合
.now_flg[.cv_no] = cv_reset_flg[.cv_no] ; 処理開始
IF .bak_flg[.cv_no]==OFF AND .now_flg[.cv_no]==ON THEN; コンベアリセット処理立上がり
FOR .shift_xno = 0 TO cv_shift_num[.cv_no,1]-1
FOR .shift_yno = 0 TO cv_shift_num[.cv_no,2]-1
cv_sync_no[.cv_no,cv_buff_no[.cv_no]] = cv_no_now[.cv_no] ; コンベアワーク番号
.shift_x = cv_shift[.cv_no,1]*.shift_xno
.shift_y = cv_shift[.cv_no,2]*.shift_yno
POINT cv_vis[.cv_no,cv_buff_no[.cv_no]] = TRANS(-.shift_x,.shift_y,0,0)
cv_gap[.cv_no,cv_buff_no[.cv_no]] = -.shift_x
cv_work_exist[.cv_no,cv_buff_no[.cv_no]] = ON;  ワークあり
ZCNTUP cv_buff_no[.cv_no],cv_max_buff[.cv_no]; バッファポインタインクリメント
cv_work_exist[.cv_no,cv_buff_no[.cv_no]] = OFF; 次ワークはありをクリア
cv_buff_num[.cv_no] = cv_buff_num[.cv_no]+1 ;   バッファ数インクリメント
END
END
.cv_next = cv_buff_no[.cv_no]
ZCNTUP .cv_next,cv_max_buff[.cv_no];                次回バッファポインタインクリメント
cv_work_exist[.cv_no,.cv_next] = OFF;               次ワークはありをクリア
cv_no_bak[.cv_no] = cv_no_now[.cv_no] ;             コンベア番号保存
ZCNTUP cv_no_now[.cv_no],cv_max_buff[.cv_no];      コンベアワーク番号インクリメント
FOR .i = 0 TO 6
IF cv_no_now[.cv_no] BAND 2^.i THEN
SOUT ix_cv_work_no[.cv_no,1]+.i 
ELSE
SOUT -(ix_cv_work_no[.cv_no,1]+.i) 
END
END
CVSET .arm_no: cv_work_pitch[.cv_no],cv_no_now[.cv_no] ;コンベアに規定値のコンベア値を強制セット
cv_reset_flg[.cv_no] = OFF; コンベアリセット終了
END
END
RETURN
.END
.PROGRAM conv_reset(.cv_no,.reset_sig) ;位置作成
;-------------------------------- 
;機能：コンベアリセット信号監視
;引数：実コンベア番号
;戻値：無し
;--------------------------------
.arm_no = cv_arm_no[.cv_no];使用アーム
.jt_no = cv_jt_no[.cv_no];使用コンベア軸
.pitch = cv_work_pitch[.cv_no]
;
.sig_type = INT(.reset_sig/1000); 入力信号の種類
CASE TRUE OF
VALUE .sig_type==1 OR NOT (.sig_type==2 AND sw_auto_cvreset[.cv_no]==ON):;外部コンベアリセットの場合もしくは 
IF .pitch<=CVPOS2:.arm_no(cv_no_bak[.cv_no],.jt_no) AND cv_reset_flg[.cv_no]==OFF THEN
.now_pitch = CVPOS2:.arm_no(cv_no_bak[.cv_no],.jt_no)-CVPOS2:.arm_no(cv_no_now[.cv_no],.jt_no)
IF .pitch<=.now_pitch AND -0.1<CVPOS2:.arm_no(cv_no_now[.cv_no],.jt_no) AND CVPOS2:.arm_no(cv_no_now[.cv_no],.jt_no)<cv_work_pitch[.cv_no]/3 THEN
cv_reset_flg[.cv_no] = ON;                                          コンベアリセット処理ON
END
END
VALUE (.sig_type==2 AND sw_auto_cvreset[.cv_no]==ON):;                 自動コンベアリセットの場合
IF cv_vision[.cv_no]==0 THEN;                                         ビジョンなし
IF SIG(-ix_cv_pulse[.cv_no]) AND .pitch<=CVPOS2:.arm_no(cv_no_bak[.cv_no],.jt_no) AND cv_reset_flg[.cv_no]==OFF THEN
;タスク実行遅れ分を補正したかったが、、、両アーム設定時に不適合
;        .cv_reals = CVPOS2:.arm_no(cv_no_bak[.cv_no],.jt_no)-cv_work_pitch[.cv_no];進みすぎ量を計算
;        CVSET .arm_no : .cv_reals, cv_no_now[.cv_no] ;コンベアに規定値のコンベア値を強制セット
SOUT .reset_sig    ;                     コンベアリセットOFF
PULSE ix_cv_pulse[.cv_no],cv_pulse;  リセット信号最低保持時間
END
IF cv_reset_flg[.cv_no]==OFF THEN
IF -0.1<CVPOS2:.arm_no(cv_no_now[.cv_no],.jt_no) AND CVPOS2:.arm_no(cv_no_now[.cv_no],.jt_no)<cv_work_pitch[.cv_no]/3 THEN
cv_reset_flg[.cv_no] = ON;                                          コンベアリセット処理ON
END
END
END
IF cv_vision[.cv_no]==1 THEN;                                         固定ビジョン
IF SIG(-.reset_sig) AND .pitch<=CVPOS2:.arm_no(cv_no_bak[.cv_no],.jt_no) AND cv_reset_flg[.cv_no]==OFF THEN
SIGNAL -cv_vis_comp
PULSE ix_cv_pulse[.cv_no],cv_pulse;  リセット信号最低保持時間
IF TASK(1002)<>1 THEN
cv_pc2_no = .cv_no
PCEXECUTE 2: conv_vision
END
cv_reset_flg[.cv_no] = ON;            コンベアリセット処理ON
END
END
IF SIG(.reset_sig,-ix_cv_pulse[.cv_no]) THEN;リセット信号ON、リセット信号最低保持時間経過
SOUT -.reset_sig    ;                     コンベアリセットOFF
END
END
RETURN
.END
.PROGRAM conv_set_pos(.arm,.cv_no); 動作位置セット
;
IF cv_coopjt[.arm,.cv_no]==0 GOTO end;            対象アームのコンベア軸設定なし
IF cv_need[.arm,.cv_no]==1 OR cv_need[.arm,.cv_no]==2 THEN;コンベアワーク番号要求あり
.cv_pair[1] = 2
.cv_pair[2] = 1
; 前詰め処理
FOR .i = 1 TO 2
IF cv_reserve[.cv_no,.i]==0 AND cv_buffer[.cv_no,.i]<>0 THEN
cv_reserve[.cv_no,.i] = cv_buffer[.cv_no,.i]
cv_buffer[.cv_no,.i] = 0
END
END
;
.need = cv_need[.arm,.cv_no]
.opposite = .cv_pair[.need]
IF cv_vision[.cv_no]==2 THEN
cv_work[.cv_no,.need] = 1; コンベアワーク番号
cv_wno[.cv_no,.need] = 1; バッファ番号
POINT cv_vwork[.cv_no,.need] = NULL
cv_work_off[.cv_no,.need] = 0
cv_need[.arm,.cv_no] = OFF
GOTO end
END
start:
IF cv_reserve[.cv_no,.need]==0 THEN;            要求側予約なし
IF cv_reserve[.cv_no,.opposite]==0 THEN;      反対側予約なし
cv_reserve[.cv_no,1] = cv_work_no[.cv_no];  ワーク番号バッファアドレス
.cv_2nd = cv_work_no[.cv_no]
ZCNTUP .cv_2nd,cv_max_buff[.cv_no];         バッファポインタインクリメント
cv_reserve[.cv_no,2] = .cv_2nd ;            ワーク番号バッファアドレス
ELSE
IF cv_work_busy[.cv_no,.opposite]==OFF THEN; 
cv_reserve[.cv_no,.opposite] = 0;         相手予約クリア
GOTO start
ELSE
cv_buffer[.cv_no,1] = cv_work_no[.cv_no]; 次回ワーク番号バッファアドレス
.cv_2nd = cv_work_no[.cv_no]
ZCNTUP .cv_2nd,cv_max_buff[.cv_no];       次回バッファポインタインクリメント
cv_buffer[.cv_no,2] = .cv_2nd ;           次回ワーク番号バッファアドレス
; 前詰め処理
FOR .i = 1 TO 2
IF cv_reserve[.cv_no,.i]==0 AND cv_buffer[.cv_no,.i]<>0 THEN
cv_reserve[.cv_no,.i] = cv_buffer[.cv_no,.i]
cv_buffer[.cv_no,.i] = 0
END
END
;
END
END
END
IF cv_work_exist[.cv_no,cv_reserve[.cv_no,.need]]==ON THEN; ワーク存在有無確認
cv_wno[.cv_no,.need] = cv_reserve[.cv_no,.need]; バッファ番号
cv_work[.cv_no,.need] = cv_sync_no[.cv_no,cv_reserve[.cv_no,.need]]; コンベアワーク番号
IF cv_vision[.cv_no]==1 THEN ;固定ビジョン付きコンベアの場合
; その他位置情報等セットする予定
POINT cv_vwork[.cv_no,.need] = cv_pos[.cv_no,cv_reserve[.cv_no,.need]]
cv_work_off[.cv_no,.need] = cv_gap[.cv_no,cv_reserve[.cv_no,.need]] ; CVPOS2(cv_sync_no[.cv_no,cv_work[.cv_no,.need]],.jt?)+cv_dist[.cv_no,.need]
ELSE
POINT cv_vwork[.cv_no,.need] = NULL
cv_work_off[.cv_no,.need] = 0
END
IF cv_coop_mode[.arm,.cv_no]==1 THEN;同期開始モード
cv_work_busy[.cv_no,.need] = ON
FOR .i = 1 TO 2
IF cv_reserve[.cv_no,.need]==cv_work_no[.cv_no]+(.i-1) THEN
cv_work_no[.cv_no] = cv_reserve[.cv_no,.need]
ZCNTUP cv_work_no[.cv_no],cv_max_buff[.cv_no]; バッファポインタインクリメント
cv_buff_num[.cv_no] = cv_buff_num[.cv_no]-.i
END
END
END
ELSE
cv_work[.cv_no,.need] = -.need; ワーク存在なし異常
END
cv_need[.arm,.cv_no] = OFF
END
; 終了処理
IF cv_comp[.arm,.cv_no]<>0 THEN
cv_work_exist[.cv_no,cv_reserve[.cv_no,cv_comp[.arm,.cv_no]]] = OFF
cv_work_busy[.cv_no,cv_comp[.arm,.cv_no]] = OFF
cv_reserve[.cv_no,cv_comp[.arm,.cv_no]] = 0
cv_comp[.arm,.cv_no] = 0
END
end:
RETURN
.END
.PROGRAM conv_vision()
;
.arm_no = cv_arm_no[cv_pc2_no]
start:
IF cv_both[cv_pc2_no]==ON THEN
.reset_sig = SYSDATA(DSIG.CVRESET,-1,cv_jt_no[cv_pc2_no])
ELSE
.reset_sig = SYSDATA(DSIG.CVRESET,.arm_no,cv_jt_no[cv_pc2_no])
END
.sig_type = INT(.reset_sig/1000);                            ビジョンリセット信号番号
NOEXIST_SET_R cv_reset_flg[cv_pc2_no] = 0
.vid = cv_vision_id;                                         ビジョン計測ID
.rno = 1;                                                    robot番号は未使用(1固定)
.recflg = OFF;                                               教示フラグOFF固定
;
.now_reset_flg = OFF
CALL get_vision_info(.rno,.vid,.camno,.calno,.camtype,.holdtype,.calpos,.ret)
IF .ret==err_no_error THEN
POINT cv_vis_frm = vision_frm[.camno]
POINT/OAT cv_vis_frm = conv_frm[cv_pc2_no];                ビジョンフレーム（X軸はコンベア進行軸）
WHILE ON DO
IF cv_vision[cv_pc2_no]<>1 GOTO end
.bak_reset_flg = .now_reset_flg;                         前回の状態
.now_reset_flg = cv_reset_flg[cv_pc2_no];                今回の状態
IF pc2_restart==ON THEN
pc2_restart = OFF
GOTO start
END
IF .bak_reset_flg==OFF AND .now_reset_flg==ON AND 0<.vid THEN;  処理立上がり
SOUT .reset_sig    ;                                       コンベアリセットON
CALL vision_exe(.camno,.calno,.rno,.camtype,.holdtype,.recflg,.vid,.calpos,.ret)
SIGNAL cv_vis_comp
END
TWAIT ascycle
END
ELSE
IF (g_last_error<>err_no_error) AND .ret<>err_vis_recog0 THEN
CALL update_error(.ret)
END
END
end:
RETURN
.END
.PROGRAM convert_vid(.mode,.calpos,.in_id,.out_id)
;-------------------------------- 
;機能：ビジョンID変換
;引数：mode(MODE_DEL/MODE_ADD)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正)、変換元ビジョンID
;戻値：変換後ビジョンID(変換元ビジョンIDが想定外の場合でもそのまま戻す)
;-------------------------------- 
;初期化
NOEXIST_SET_R .in_id = 0
.out_id = .in_id
CASE .mode OF
VALUE mode_add:
CASE .calpos OF
VALUE type_pos:
;そのままでOK
VALUE type_device1:
.out_id = .in_id+offset_device1n
VALUE type_device2:
.out_id = .in_id+offset_device2n
VALUE type_device3:
.out_id = .in_id+offset_device3n
END
VALUE mode_del:
IF .out_id>max_visionid_nu THEN
DO
.out_id = .out_id-max_visionid_nu
UNTIL (.out_id<max_visionid_nu)
END
END
.END
.PROGRAM cs()
TCP_CLOSE ret,sock_id
.END
.PROGRAM csv_to_real(.$str,.prm[],.num,.ret)
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
.ret = err_no_error
.num = 0
DO
.$temp = $DECODE(.$str,",",0)
.prm[.num] = VAL(.$temp)
IF .$str=="" THEN
GOTO 100
END
.$temp = $DECODE(.$str,",",1)
.num = .num+1
UNTIL .$str==""
100
IF .num==0 THEN
.ret = err_cant_conver
END
.END
.PROGRAM csv_to_str(.$str,.num,.ret)
;-------------------------------- 
;機能：CSV切出(文字列→実数変数変換)(動作プログラム実行用)
;引数：文字列
;戻値：実数、成否(最低1個カンマが無いとエラー最後がカンマの場合、その後は取り込まない)
;-------------------------------- 
.ret = err_no_error
.num = 0
DO
.$temp = $DECODE(.$str,",",0)
$prm[TASKNO,.num] = .$temp
IF .$str=="" THEN
GOTO 100
END
.$temp = $DECODE(.$str,",",1)
.num = .num+1
.length = LEN(.$temp)
IF .length>1 THEN
FOR .i = 1 TO .length-1
$prm[TASKNO,.num] = ""
.num = .num+1
END
END
UNTIL .$str==""
100
IF .num==0 THEN
.ret = err_cant_conver
END
.END
.PROGRAM ctest()
isready = FALSE
port = 52000
ip[0] = 192
ip[1] = 168
ip[2] = 0
ip[3] = 100
max_length = 255
tout_open = 60
tout_rec = 1
tout = 1
ret = 1
MC zpow on
CALL open_socket
IF sock_id<0 THEN
GOTO exit_end
END
aaa = 1
WHILE (aaa==1) DO
isready = FALSE
ret = 0
CALL tcprecv;Receiving instruction data from PC
TYPE $recv_buf[1]
IF ($recv_buf[1]!="000") THEN
$drink = $recv_buf[1]
sig1 = 0
sig2 = 0
MC execute 1:caffeeh1
MC execute 2:caffeeh2
IF ($drink=="Espresso\n") THEN
END
IF ($drink=="Americano\n") THEN
END
IF ($drink=="Cappuccino\n") THEN
END
IF ($drink=="Latte\n") THEN
END
WAIT (isready==TRUE)
TYPE ("lol");
CALL tcpsend(ret,"OK\n")
$drink = "000"
END
;      ANY : 
;    END 
;END 
END
exit:
CALL close_socket;Closing communication 
exit_end:
.END
.PROGRAM cv_init()
FOR .rno = 1 TO 2
FOR .cvno = 1 TO 2
cv_need[.rno,.cvno] = 0 ;目標ワーク（先頭/2番目）フラグ
cv_comp[.rno,.cvno] = 0 ;同期完了フラグ
END
cur_cvcoop_no[.rno] = 0
cur_cvcoop_wo[.rno] = 0
cur_cvcoop_wono[.rno] = 0
cv_norestart[.rno] = FALSE
END
FOR .cvno = 1 TO 2
FOR .work = 1 TO 2
cv_work[.cvno,.work] = 0 ;ワーク番号
END
END
flg_cv_clear = FALSE
.END
.PROGRAM cv_rap_check(.cv_no,.before_no,.before_num,.&vwork_pos,.rap)
;-------------------------------- 
;機能：ラップチェックプログラム
;引数：.cv_no(実コンベア番号)、.before_num(比較数)、.&work_pos(対象位置)
;戻値：.rap(判定結果) OFF:ラップなし ON:ラップあり
;--------------------------------
.rap = OFF; 結果クリア
.check_no = .before_no; 最終バッファ番号
;
FOR .i = 1 TO .before_num
.check_no = .check_no-1; バッファ番号デクリメント
IF .check_no<1 THEN
.check_no = .check_no+cv_max_buff[.cv_no]
END
.cv_gap = CVPOS2:cv_arm_no[.cv_no](cv_sync_no[.cv_no,.check_no],cv_jt_no[.cv_no])-CVPOS2:cv_arm_no[.cv_no](cv_no_now[.cv_no],cv_jt_no[.cv_no])
IF 500<.cv_gap GOTO end; コンベア進行量が500mm以上の場合はラップするはずがない。。。
POINT .check_pos = conv_frm[.cv_no]+TRANS(.cv_gap)-conv_frm[.cv_no]+cv_pos[.cv_no,.check_no]
.dist = DISTANCE(.vwork_pos,.check_pos)
IF ABS(.dist)<cv_rap THEN
.rap = ON
GOTO end
END
END
end:
RETURN
.END
.PROGRAM cv_sync_main() ;コンベア同期管理プログラム
;-------------------------------- 
;機能：コンベア同期に関するデータ管理
;引数：無し
;戻値：無し
;--------------------------------
;
IF flg_cvpc_stop==FALSE THEN;       コンベア監視 停止指令なし
IF flg_cvpc_run==OFF THEN;      コンベア監視実行中 OFF 
;     ■初回(設定変更後)のみ処理する
.vision_mode = 0
NOEXIST_SET_R cv_vision_id = 0; 第二階層コンベアビジョン 品種ID
NOEXIST_SET_R cv_offset = 0;    ラップチェック用オフセット(mm)
NOEXIST_SET_R cv_rap = 10;      ラップ判別距離(mm)
NOEXIST_SET_R pc2_restart = 0;  計測タスクのリセットフラグ
;
FOR .cv_no = 1 TO cv_num;       コンベア設定可能数分繰り返し
cv_both[.cv_no] = OFF
CASE TRUE OF;                    VALUE 条件成立で実行する
VALUE 0<cv_coopjt[1,.cv_no]:; アーム1コンベア.cv_no登録あり
cv_arm_no[.cv_no] = 1;
cv_jt_no[.cv_no] = cv_coopjt[1,.cv_no]
IF cv_jt_no[.cv_no]==cv_coopjt[2,.cv_no] THEN
cv_both[.cv_no] = ON
.reset_sig[.cv_no] = SYSDATA(DSIG.CVRESET,-1,cv_jt_no[.cv_no])
ELSE
.reset_sig[.cv_no] = SYSDATA(DSIG.CVRESET,cv_arm_no[.cv_no],cv_jt_no[.cv_no])
END
.check = INT(.reset_sig[.cv_no]/1000)
IF .check==2 THEN
SOUT -.reset_sig[.cv_no] 
END
VALUE 0<cv_coopjt[2,.cv_no]:; アーム2コンベア.cv_no登録あり
cv_arm_no[.cv_no] = 2
cv_jt_no[.cv_no] = cv_coopjt[2,.cv_no]
.reset_sig[.cv_no] = SYSDATA(DSIG.CVRESET,cv_arm_no[.cv_no],cv_jt_no[.cv_no])
ANY :
cv_jt_no[.cv_no] = 0
END
CALL conv_clear(.cv_no);   コンベア関連パラメータの初期化
END
;
flg_cvpc_run = ON
RETURN
END
;
;  ■毎回処理する
FOR .cv_no = 1 TO cv_num
IF 0<cv_jt_no[.cv_no] AND NOT (cv_vision[.cv_no]==1 AND cv_vision_id==OFF) THEN
CALL conv_reset(.cv_no,.reset_sig[.cv_no]);    コンベアリセットチェック
CALL conv_make_pos(.cv_no);              位置作成
CALL conv_buff_chk(.cv_no);              バッファデータ動作範囲チェック
END
FOR .arm = 1 TO 2
CALL conv_set_pos(.arm,.cv_no);          同期データ選択
END
END
CALL conv_fresh
ELSE
flg_cvpc_run = OFF
END
RETURN
.END
.PROGRAM cvaxis_check(.rno,.cvjt,.ret)
;-------------------------------- 
;機能：コンベア軸チェック
;引数：ロボット番号、軸番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF (.rno<>1 AND .rno<>2) OR (.cvjt<>9 AND .cvjt<>10) THEN
.ret = err_cv_setting
RETURN
END
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
IF .cvjt>.axis+2 THEN
.ret = err_cv_setting
RETURN
END
IF SYSDATA(JTYPE,.rno,.cvjt)<>2 THEN
.ret = err_cv_setting
RETURN
END
.END
.PROGRAM error_log(.err_code)
;-------------------------------- 
;機能：ASアプリエラーログ保存
;引数：エラーコード
;戻値：なし
;-------------------------------- 
;
IF log_error_ena==FALSE THEN; 機能が有効か確認
IF debug.prt.log<>FALSE THEN
PRINT "error_log()->RETURN[disable]"
END
RETURN
END
IF .err_code<=err_no_error THEN; エラーコード確認
IF debug.prt.log<>FALSE THEN
PRINT "error_log()->RETURN[err_code] err_code=",.err_code
END
RETURN
END
;
CALL get_error_mess(.err_code,.$err_mess); エラーコードからエラーの内容を取得
.$log = $DATE(3)+" "+$TIME+$delimiter+$ENCODE(/L,.err_code)+$delimiter+.$err_mess; ログデータ作成
$log_error[log_count[9]] = .$log; ログデータ保存
log_count[9] = log_count[9]+1; ログカウンタカウントアップ
IF log_count[9]>log_max_num THEN; ログカウンタ上限超えの為リセット
log_count[9] = 1
END
$log_error[log_count[9]] = "*"; 最新ログには「*」を書き込む（検索し易くする為）
;
IF debug.prt.log<>FALSE THEN
PRINT "error_log()->LOGGING $log=",.$log
END
RETURN
.END
.PROGRAM exec_alone(.ret)
;-------------------------------- 
;機能：ALONEコマンド実行
;引数：なし
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF (COOPSTATUS(1)==0 AND COOPSTATUS(2)==0) THEN
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中では無い TASKNO=",TASKNO
END
RETURN
END
IF TASKNO<>pg_master AND TASKNO<>pg_slave THEN
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中を検出:ZMONEXE ALONE TASKNO=",TASKNO
END
IF (SWITCH(CS ,1)==ON OR SWITCH(CS ,2)==ON) THEN
DO
IF SWITCH(CS ,1)==ON THEN
MC HOLD 1:
END
IF SWITCH(CS ,2)==ON THEN
MC HOLD 2:
END
IF debug.prt.func==TRUE THEN
PRINT "Try to execute hold command before ZONEXE."
END
TWAIT ascycle
UNTIL ((SWITCH(CS ,1)==OFF AND SWITCH(CS ,2)==OFF))
END
ZMONEXE "ALONE"
ELSE
IF debug.prt.func==TRUE THEN
PRINT "exec_alone()->協調中を検出:ALONE TASKNO=",TASKNO
END
ALONE
END
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "Can not change ALONE-mode for MASTER_ROBOT"
RETURN
END
TWAIT ascycle
UNTIL (COOPSTATUS(1)==0)
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
.ret = err_robot_cmon
PRINT "Can not change ALONE-mode for SLAVE_ROBOT"
RETURN
END
TWAIT ascycle
UNTIL (COOPSTATUS(2)==0)
.END
.PROGRAM exec_calvision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン計算実行（装置補正実行）
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_calvision()"
END
NOEXIST_SET_R data_vision_cnt[.l2num,.l3num] = 0
; calposはcalvision内で未使用
CALL calvision(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],1,.ret)
IF .ret<>err_no_error AND data_vision_cnt[.l2num,.l3num]==1 THEN
.ret = err_no_error; ビジョンNG続行フラグONの場合エラーにしない(ログはcal_visionで取っている)
END
.END
.PROGRAM exec_cend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_cend()->      同期終了"
END
sys_force_cmode = FALSE
syn_mode_end = TRUE; 同期終了処理実行フラグ
; 同期終了処理
flg_req_mamode = FALSE
POINT #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
dest_mode[2] = 9999
CALL exec_alone(.ret)
.END
.PROGRAM exec_cnt(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：カウンタ値加算実行 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;カウンタＩＤ及びカウンタタイプの有無と「0」じゃないことの確認
.$chk = "DATA_CNTID["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
IF EXISTDATA(.$chk,R)==OFF THEN
.ret = err_bat_value
RETURN
END
.$chk = "DATA_CNTTYPE["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
IF EXISTDATA(.$chk,R)==OFF THEN
.ret = err_bat_value
RETURN
END
IF data_cntid[.l2num,.l3num]==0 OR data_cnttype[.l2num,.l3num]==0 THEN
.ret = err_bat_value
RETURN
END
IF data_cntid[.l2num,.l3num]==-1 THEN
FOR .i = 1 TO max_cntnum
;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
NOEXIST_SET_R data_cntnum[.i] = 0
data_cntnum[.i] = data_cntnum[.i]+data_cnttype[.l2num,.l3num]
.maxnum = 32767
.minnum = -32768
IF data_cntnum[.i]>=.maxnum THEN
data_cntnum[.i] = .maxnum
END
IF data_cntnum[.i]<=.minnum THEN
data_cntnum[.i] = .minnum
END
END
ELSE
NOEXIST_SET_R data_cntnum[data_cntid[.l2num,.l3num]] = 0
data_cntnum[data_cntid[.l2num,.l3num]] = data_cntnum[data_cntid[.l2num,.l3num]]+data_cnttype[.l2num,.l3num]
.maxnum = 32767
.minnum = -32768
IF data_cntnum[data_cntid[.l2num,.l3num]]>=.maxnum THEN
data_cntnum[data_cntid[.l2num,.l3num]] = .maxnum
END
IF data_cntnum[data_cntid[.l2num,.l3num]]<=.minnum THEN
data_cntnum[data_cntid[.l2num,.l3num]] = .minnum
END
END
.END
.PROGRAM exec_cntset(.l2num,.l3num,.val,.ret)
;-------------------------------- 
;機能：カウンタ値設定実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)、カウンタ値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;カウンタＩＤの有無と「0」じゃないことの確認
.$chk = "DATA_CNTID["+$ENCODE(.l2num)+","+$ENCODE(.l3num)+"]"
IF EXISTDATA(.$chk,R)==OFF THEN
.ret = err_bat_value
RETURN
END
IF data_cntid[.l2num,.l3num]==0 THEN
.ret = err_bat_value
RETURN
END
.maxnum = 32767
.minnum = -32768
IF .val>=.maxnum THEN
.val = .maxnum
END
IF .val<=.minnum THEN
.val = .minnum
END
IF data_cntid[.l2num,.l3num]==-1 THEN
FOR .i = 1 TO max_cntnum
;DATA_CNTNUM[カウンタ番号]=1〜MAX_CNTNUM
data_cntnum[.i] = .val
END
ELSE
data_cntnum[data_cntid[.l2num,.l3num]] = .val
END
.END
.PROGRAM exec_cstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：同期開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_cstart()->      同期開始"
END
BREAK; 同期開始の為BREAK
sys_force_cmode = TRUE
syn_mode_start = TRUE; 同期開始処理実行フラグ
.END
.PROGRAM exec_cvwait(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：コンベア待ち処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_cvwait()"
END
.rno = data_robottype[.l2num,.l3num]; ロボット番号取得
.cvno = data_wait_cvno[.l2num,.l3num]; コンベア番号取得
.cvwork = data_wait_cvwo[.l2num,.l3num]; ワーク先頭/2番目
.cvrno = 0
.cvjtno = 0
IF cv_norestart[.rno]==FALSE THEN
cv_norestart[.rno] = TRUE ;再開不可
.cvcoop = FALSE
ELSE
.cvcoop = TRUE
END
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
WAIT cv_norestart[.rno]==FALSE
END
CALL cvaxis_check(.rno,cv_coopjt[.rno,.cvno],.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
WAIT cv_norestart[.rno]==FALSE
END
.cvrno = .rno
.cvjtno = cv_coopjt[.rno,.cvno]
IF .cvrno==0 OR .cvjtno==0 THEN
CALL update_error(err_cv_setting)
WAIT cv_norestart[.rno]==FALSE
END
.cvworkno = FALSE
UTIMER .@nowtime = 0
WHILE (TRUE) DO
exout_start_fla = TRUE
IF .cvworkno<1 THEN
CALL change_cvcoop(.cvrno,.cvno,.cvwork,cv_mode_ifchk,.cvjtno,.cvworkno,.ret)
ELSE
.cvpos = ((CVPOS2:.cvrno(.cvworkno,.cvjtno))+cv_work_off[.cvno,.cvwork])
IF (.cvpos>data_wait_cvll[.l2num,.l3num]) THEN
;コンベア行き過ぎエラー
exout_start_fla = FALSE
CALL update_error(err_cv_wait)
WAIT cv_norestart[.rno]==FALSE
ELSE
IF (.cvpos>=data_wait_cvul[.l2num,.l3num]) AND (.cvpos<=data_wait_cvll[.l2num,.l3num]) THEN
;正常処理
exout_start_fla = FALSE
IF .cvcoop==FALSE THEN
cv_norestart[.rno] = FALSE
END
.ret = err_no_error
RETURN
END
END
END
IF data_wait_cvto[.l2num,.l3num]>0 THEN ;タイムアウトエラー
IF UTIMER(.@nowtime)>data_wait_cvto[.l2num,.l3num]/1000 THEN
exout_start_fla = FALSE
CALL update_error(err_cv_timeout)
WAIT cv_norestart[.rno]==FALSE
END
END
TWAIT ascycle
END
.END
.PROGRAM exec_hand(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ハンド操作実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_hand()->ハンド操作実行"
END
NOEXIST_SET_R data_hand_sol[.l2num,.l3num] = 1
CALL hand(data_robottype[.l2num,.l3num],data_hand_ctl[.l2num,.l3num],data_hand_sol[.l2num,.l3num],.ret)
.END
.PROGRAM exec_ifchk(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO成立条件判定
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：JUMP可否(FALSE:JUMP不可、TRUE:JUMP可)
;-------------------------------- 
.ret = FALSE
.rno = data_robottype[.l2num,.l3num]
IF debug.prt.act==TRUE THEN
PRINT "exec_ifchk()-> Condition number is DATA_L3IFGOTO_ID[",.l2num,",",.l3num,"]=",data_l3ifgoto_i[.l2num,.l3num]
END
;DATA_IFCONTBLNUM:条件総数
IF data_l3ifgoto_i[.l2num,.l3num]<=0 THEN
;条件が存在しない場合はJUMPしない
RETURN
END
;条件成立数カウント(このチェックの瞬間に全条件が揃ってる場合のみJUMPする)
.cnt = 0
FOR .i = 1 TO data_l3ifgoto_i[.l2num,.l3num]
NOEXIST_SET_R data_ifcnt2[.l2num,.l3num,.i] = 0
NOEXIST_SET_R data_ifcnt3[.l2num,.l3num,.i] = 0
CASE data_ifmode[.l2num,.l3num,.i] OF
VALUE ifcon_cnt:
CASE data_iftype[.l2num,.l3num,.i] OF
VALUE ineq_sign_eq:
;[=]equal
IF data_cntnum[data_ifitem[.l2num,.l3num,.i]]==data_ifcnt[.l2num,.l3num,.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_noteq:
;[<>]not equal
IF data_cntnum[data_ifitem[.l2num,.l3num,.i]]<>data_ifcnt[.l2num,.l3num,.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_lteq:
;[<=]less than or equal
IF data_cntnum[data_ifitem[.l2num,.l3num,.i]]<=data_ifcnt[.l2num,.l3num,.i] THEN
.cnt = .cnt+1
END
VALUE ineq_sign_gteq:
;[>=]greater than or equal
IF data_cntnum[data_ifitem[.l2num,.l3num,.i]]>=data_ifcnt[.l2num,.l3num,.i] THEN
.cnt = .cnt+1
END
END
VALUE ifcon_io:
;OFF=0,ON=0以外
IF data_iftype[.l2num,.l3num,.i]<>OFF THEN
IF SIG(data_ifitem[.l2num,.l3num,.i])<>OFF THEN
.cnt = .cnt+1
END
ELSE
IF SIG(data_ifitem[.l2num,.l3num,.i])==OFF THEN
.cnt = .cnt+1
END
END
VALUE ifcon_flg:
;0以外の数値をDATA_IFITEMに設定している場合、符号を無視してTRUE扱い
IF data_iftype[.l2num,.l3num,.i]<>0 THEN
.cnt = .cnt+1
END
VALUE ifcon_cv:
.first_exec = TRUE
recheck:
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
cv_norestart[.rno] = TRUE ;再開不可
CALL update_error(.ret)
WAIT cv_norestart[.rno]==FALSE
END
.cvno = data_iftype[.l2num,.l3num,.i]
.cvwork = data_ifitem[.l2num,.l3num,.i]
CALL change_cvcoop(.rno,.cvno,.cvwork,cv_mode_wait,.cvjt,.cvworkno,.ret)
IF .ret==0 OR .ret==err_cv_nowork THEN ;ワーク番号有りまたは無しの場合
IF .ret==0 THEN ;ワーク番号有りの場合
.cvpos = ((CVPOS2:.rno(.cvworkno,.cvjt))+cv_work_off[.cvno,.cvwork])
IF ((data_ifcnt2[.l2num,.l3num,.i]<=.cvpos) AND (data_ifcnt3[.l2num,.l3num,.i]=>.cvpos))==-data_ifcnt[.l2num,.l3num,.i] THEN
.cnt = .cnt+1
END
ELSE ;ワーク番号無しの場合
IF data_ifcnt[.l2num,.l3num,.i]==FALSE THEN
.cnt = .cnt+1
END
END
GOTO chkfin
END
IF .ret==err_cvcoop AND .first_exec==TRUE THEN ;ワーク番号範囲外かつ初回の場合
.firt_exec = FALSE
GOTO recheck
END
cv_norestart[.rno] = TRUE ;再開不可
CALL update_error(err_cv_setting)
WAIT cv_norestart[.rno]==FALSE
END
END
chkfin:
IF .cnt==data_l3ifgoto_i[.l2num,.l3num] THEN
;JUMP条件数OK
.ret = TRUE
RETURN
END
.END
.PROGRAM exec_ifgoto(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTO動作コア 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL exec_ifchk(.l2num,.l3num,.jump_flg)
IF .jump_flg==TRUE THEN
CALL exec_ifjump(.l2num,.l3num,.ret)
END
.END
.PROGRAM exec_ifjump(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IFGOTOJUMP動作 
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;指定L2階層内でラベルが見つかった場合.l3num数を更新する
IF debug.prt.act==TRUE THEN
PRINT "exec_ifjump()-> Start serch for DATA_L3IFGOTO_LABEL[",.l2num,",",.l3num,"]=",data_l3ifgoto_l[.l2num,.l3num]
END
FOR .i = 1 TO data_l3num[.l2num]
IF data_l3type[.l2num,.i]==l3type_iflabel THEN
;探索指定文字列    =$DATA_L3IFGOTO_LABEL[IFGOTO第2階層,IFGOT第3階層]
;ラベル設定済文字列=$DATA_L3LABEL[LABEL第2階層,LABEL第3階層]
IF data_l3ifgoto_l[.l2num,.l3num]==data_l3label[.l2num,.i] THEN
.l3num = .i
now_move_l3num[TASKNO] = .l3num
IF TASKNO==robot_master THEN
IF sys_force_cmode==TRUE OR flg_slave_paral==FALSE THEN
now_move_l3num[robot_slave] = 0; 協調動作または単体動作の時はスレーブ側の記憶は消去
END
END
IF debug.prt.act==TRUE THEN
PRINT "exec_ifjump()-> Target-label was found in .l2num=",.l2num,",.l3num=",.l3num
END
RETURN
END
END
END
IF debug.prt.act==TRUE THEN
PRINT "exec_ifjump()-> Target-label wasn\'t found in .l2num=",.l2num
END
.END
.PROGRAM exec_iochange(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO変更処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_iochange()"
END
IF data_signum[.l2num,.l3num]<=0 THEN
;エラーにするかは上位の実装を考慮したほうが良い
;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
RETURN
END
IF data_wait_befor[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",data_wait_befor[.l2num,.l3num]
END
TWAIT data_wait_befor[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
IF debug.prt.act==TRUE THEN
PRINT "CHANGEING SIGNAL DATA_SIGNUM[.l2num,.l3num]=",data_signum[.l2num,.l3num]," DATA_SIGSTATUS[.l2num,.l3num]=",data_sigstatus[.l2num,.l3num]
END
CALL iochange(data_signum[.l2num,.l3num],data_sigstatus[.l2num,.l3num],data_keep_wait[.l2num,.l3num],.ret)
IF data_wait_after[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",data_wait_after[.l2num,.l3num]
END
TWAIT data_wait_after[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
.END
.PROGRAM exec_iowait(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：IO待ち処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_iowait()"
END
IF data_signum[.l2num,.l3num]<=0 THEN
;エラーにするかは上位の実装を考慮したほうが良い
;信号状態はDATA_SIGSTATUSに分離管理しているのでDATA_SIGNUM負値は存在しない
RETURN
END
IF data_wait_befor[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_BEFORE[.l2num,.l3num]=",data_wait_befor[.l2num,.l3num]
END
TWAIT data_wait_befor[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
IF debug.prt.act==TRUE THEN
PRINT "START WAITING DATA_SIGNUM[.l2num,.l3num]=",data_signum[.l2num,.l3num]
END
.rno = data_robottype[.l2num,.l3num]; ロボット番号取得
SIGNAL -ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＦＦ
NOEXIST_SET_R data_wait_tocon[.l2num,.l3num] = 0
flg_wait_end = FALSE
UTIMER .@nowtime = 0
WHILE (TRUE) DO
exout_start_fla = TRUE
IF flg_wait_end==TRUE THEN
flg_wait_end = FALSE
exout_start_fla = FALSE
RETURN
END
IF data_wait_timeo[.l2num,.l3num]>0 AND (SIG(data_signum[.l2num,.l3num])<>-(data_sigstatus[.l2num,.l3num])) AND flg_iowait_debu<>TRUE THEN
IF UTIMER(.@nowtime)>data_wait_timeo[.l2num,.l3num]/1000 THEN  ; @@@ 20140926 m ミリ秒に変更 A.Kobayashi
IF debug.prt.act==TRUE THEN
PRINT "TIMEOUT"
END
SIGNAL ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＮ
IF data_wait_tocon[.l2num,.l3num]==1 THEN; 信号待ちＮＧ(タイムアウト)続行フラグＯＮの場合はエラーにしない
RETURN
END
data_execute = FALSE     ; @@@ 20140926 A.Kobayashi
exout_start_fla = FALSE
timeout_signum = data_signum[.l2num,.l3num]
CALL update_error(err_sig_timeout)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
SIGNAL -ix_iowait_to[.rno]; 信号待ちＮＧ(タイムアウト)信号ＯＦＦ
;タイマーリセット
UTIMER .@nowtime = 0
flg_exec_first_ = TRUE
END
END
IF SIG(data_signum[.l2num,.l3num])==-(data_sigstatus[.l2num,.l3num]) THEN
IF debug.prt.act==TRUE THEN
PRINT "DETECTED INPUT SIGNAL=",data_signum[.l2num,.l3num]," CHANGE TO =",-(data_sigstatus[.l2num,.l3num])
END
IF data_wait_after[.l2num,.l3num]>=1 THEN
IF debug.prt.act==TRUE THEN
PRINT "WEAITING...DATA_WAIT_AFTER[.l2num,.l3num]=",data_wait_after[.l2num,.l3num]
END
TWAIT data_wait_after[.l2num,.l3num]/1000     ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
exout_start_fla = FALSE
RETURN
END
TWAIT ascycle
END
.END
.PROGRAM exec_main(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：作業シーケンス実行処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l3type = data_l3type[.l2num,.l3num]
CASE .l3type OF
VALUE l3type_move,l3type_io_wait,l3type_io_chang,l3type_vision,l3type_hand_cha,l3type_return,l3type_ifgoto,l3type_colchk,l3type_cnt,l3type_cntset,l3type_stop,l3type_calvisio,l3type_call,l3type_cvwait,l3type_cvstart,l3type_cvcomp,l3type_shift:
;ロボット別にコマンドを処理したい場合は↑VALUEに追加
IF flg_slave_paral==TRUE THEN
CALL selfcheck(.l2num,.l3num,.ret)
IF .l3type==l3type_hand_cha THEN
IF (TASKNO==pg_master) AND (data_robottype[.l2num,.l3num]==robot_all) THEN
;ハンド操作の場合、両アーム指定はスキップしない
.ret = err_no_error
END
END
IF .ret<>err_no_error THEN
;スキップは正常扱いにする
.ret = err_no_error
RETURN
END
END
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend:
;マスター専用コマンドとして扱いたい場合は↑VALUEに追加
IF (TASKNO==pg_slave) AND (.l3type==l3type_wend) THEN
.ret = err_slave_acten
RETURN
END
;マスター専用
IF TASKNO<>pg_master THEN
RETURN
END
END
;登録作業実行
CASE .l3type OF
VALUE l3type_move,l3type_shift:
IF flg_exec_first_==TRUE THEN
IF slowlimit_ena<>FALSE AND flg_single_move<>TRUE THEN
UTIMER @slowlimit_timer = 0
flg_slowlimit = TRUE
ELSE
flg_slowlimit = FALSE
END
flg_exec_first_ = FALSE
END
flg_slave_call = FALSE
CALL exec_move(.l2num,.l3num,.ret)
VALUE l3type_io_wait:
CALL exec_iowait(.l2num,.l3num,.ret)
IF debug.prt.item==TRUE THEN
PRINT "TASKNO=",TASKNO,", iowait()->Signal Number=",data_signum[.l2num,.l3num],", Signal Status=",-(data_sigstatus[.l2num,.l3num]),", Time= ",$TIME
END
VALUE l3type_io_chang:
CALL exec_iochange(.l2num,.l3num,.ret)
VALUE l3type_vision:
CALL exec_vision(.l2num,.l3num,.ret)
VALUE l3type_cstart:
IF flg_slave_paral==FALSE THEN
CALL exec_cstart(.l2num,.l3num,.ret)
END
VALUE l3type_cend:
IF flg_slave_paral==FALSE THEN
CALL exec_cend(.l2num,.l3num,.ret)
END
VALUE l3type_wstart:
CALL exec_wstart(.l2num,.l3num,.ret)
VALUE l3type_wend:
CALL exec_wend(.l2num,.l3num,.ret)
VALUE l3type_l2reset:
data_l2status[data_l2resetnum[.l2num,.l3num]] = FALSE
VALUE l3type_hand_cha:
CALL exec_hand(.l2num,.l3num,.ret)
VALUE l3type_calvisio:
CALL exec_calvision(.l2num,.l3num,.ret)
VALUE l3type_colchk:
IF data_colchk[.l2num,.l3num]==FALSE THEN
;アーム間干渉チェック機能無効化
INTFCHK OFF
ELSE
;アーム間干渉チェック機能有効化
INTFCHK ON
END
IF debug.prt.item==TRUE THEN
PRINT "TASKNO=",TASKNO,", intfchk()->Check Status=",data_colchk[.l2num,.l3num],", INTFCHK=",SWITCH(INTFCHK),", Time= ",$TIME
END
VALUE l3type_return:
IF flg_slave_paral==FALSE THEN
.ret = err_l3_actend
END
VALUE l3type_ifgoto:
CALL exec_ifgoto(.l2num,.l3num,.ret)
VALUE l3type_iflabel:
;何もしない
VALUE l3type_cnt:
CALL exec_cnt(.l2num,.l3num,.ret)
VALUE l3type_cntset:
;カウンタ値セットはカウンタ値リセットと兼用
;全カウンタリセット時はexec_cntset関数に[.l2num,.l3num,.val]を0指定
NOEXIST_SET_R data_cntval[.l2num,.l3num] = 0
.val = data_cntval[.l2num,.l3num]
CALL exec_cntset(.l2num,.l3num,.val,.ret)
VALUE l3type_stop:
BREAK
data_execute = FALSE
IF data_restart_fl[.l2num,.l3num]==0 THEN
;再開不可
no_restart_flg = TRUE
END
CALL update_error(err_l3type_stop)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
VALUE l3type_call:
IF EXISTDATA($data_callname[.l2num,.l3num],G)<>-1 THEN;指定プログラムが存在しない場合
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(err_noexist_pg)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
IF TASKNO==pg_master AND sys_force_cmode==TRUE AND syn_mode_start<>FALSE THEN;協調フラグONで協調状態でない場合
;協調モードに移行
CALL change_ms_mode(slave_timeout,.ret)
IF .ret<>err_no_error THEN
;終了処理
flg_req_mamode = FALSE
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(.ret)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
END
.rno = TASKNO
coopsta[.rno] = COOPSTATUS(.rno)
flg_exec_first_ = FALSE;初回動作フラグOFF
flg_slowlimit = FALSE;スロースタートフラグOFF
flg_nonbreak[.rno] = OFF;BREAK無しフラグOFF
CALL chk_break(.l2num,.l3num,.bflag)
CALL setl3speed(0,TRUE)
SPEED 100 ALWAYS;プログラム速度を最高速にする
CALL reset_mon_sp(robot_all); モニタ速度を変更している場合は元に戻す
CASE data_robottype[.l2num,.l3num] OF
VALUE robot_master:
flg_call_now[robot_master] = TRUE
now_move_l3num[robot_master] = .l3num
IF sys_force_cmode==TRUE OR flg_slave_paral==FALSE THEN
now_move_l3num[robot_slave] = 0; 協調動作または単体動作の時はスレーブ側の記憶は消去
END
POINT #dest_pos[1] = #PPOINT(9999,9999,9999,9999)
dest_mode[1] = 9999
SCALL $data_callname[.l2num,.l3num]
VALUE robot_slave:
IF TASKNO==pg_master THEN
flg_slave_call = TRUE
$gs_callname = $data_callname[.l2num,.l3num]
gs_bflag = .bflag
;スレーブ動作実行
now_move_l3num[robot_master] = .l3num
now_move_l3num[robot_slave] = 0
CALL slave_run(slave_timeout,.ret)
DO
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
ELSE
flg_call_now[robot_slave] = TRUE
now_move_l3num[robot_slave] = .l3num
POINT #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
dest_mode[2] = 9999
SCALL $data_callname[.l2num,.l3num]
END
END
IF flg_nonbreak[.rno]==OFF OR .bflag==TRUE THEN
BREAK
ELSE
flg_nonbreak[.rno] = OFF
END
flg_call_now[.rno] = FALSE
IF coopsta[.rno]<>COOPSTATUS(.rno) THEN;マクロPG実行後に協調状態が変わった場合
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(err_coop_chg)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
VALUE l3type_cvwait:
CALL exec_cvwait(.l2num,.l3num,.ret)
VALUE l3type_cvstart:
.rno = data_robottype[.l2num,.l3num]
.cvno = data_cvcoop_no[.l2num,.l3num]
.cvwork = data_cvcoop_wo[.l2num,.l3num]
cv_norestart[.rno] = TRUE ;再開不可
IF cur_cvcoop_no[.rno]<>0 OR cur_cvcoop_wo[.rno]<>0 OR cur_cvcoop_wono[.rno]<>0 THEN
;前回のコンベア同期終了処理が正常に行われていない可能性がある
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
; コンベア同期開始設定
CALL change_cvcoop(.rno,.cvno,.cvwork,cv_mode_move,.cvjt,.cvworkno,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
WAIT cv_norestart[.rno]==FALSE
END
cur_cvcoop_no[.rno] = .cvno
cur_cvcoop_wo[.rno] = .cvwork
cur_cvcoop_wono[.rno] = cv_work[.cvno,.cvwork]
VALUE l3type_cvcomp:
;コンベア同期終了処理
BREAK
.rno = data_robottype[.l2num,.l3num]
.cvno = data_cvcoop_no[.l2num,.l3num]
.cvwork = data_cvcoop_wo[.l2num,.l3num]
.cvwork2 = data_cvcoop_wo2[.l2num,.l3num]
IF (.cvno<>1 AND .cvno<>2) OR (.cvno<>1 AND .cvno<>2) THEN
;前回のコンベア同期開始ステップがない
cv_norestart[.rno] = TRUE
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
IF cur_cvcoop_no[.rno]==0 OR cur_cvcoop_wo[.rno]==0 OR cur_cvcoop_wono[.rno]==0 THEN
;前回のコンベア同期開始処理が正常に行われていない可能性がある
cv_norestart[.rno] = TRUE
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
cv_comp[.rno,.cvno] = .cvwork
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
TWAIT ascycle
UNTIL (cv_comp[.rno,.cvno]==FALSE)
cv_work[.cvno,.cvwork] = 0
cur_cvcoop_no[.rno] = 0
cur_cvcoop_wo[.rno] = 0
cur_cvcoop_wono[.rno] = 0
POINT #dest_pos[.rno] = #PPOINT(9999,9999,9999,9999);コンベア同期終了時は目標値をリセットする
IF .cvwork2<>0 THEN
;協調動作時両アーム同期終了の場合
cv_comp[robot_slave,.cvno] = .cvwork2
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
CALL update_error(err_cvcoop)
WAIT cv_norestart[robot_slave]==FALSE
END
TWAIT ascycle
UNTIL (cv_comp[robot_slave,.cvno]==FALSE)
cv_work[.cvno,.cvwork2] = 0
cur_cvcoop_no[robot_slave] = 0
cur_cvcoop_wo[robot_slave] = 0
cur_cvcoop_wono[robot_slave] = 0
cv_norestart[robot_slave] = FALSE ;協調で同期終了時のSLAVEのフラグはここでOFFする
POINT #dest_pos[robot_slave] = #PPOINT(9999,9999,9999,9999);コンベア同期終了時は目標値をリセットする
END
END
IF (.ret<>err_no_error) AND (.ret<>err_l3_actend) THEN
IF debug.prt.act==TRUE THEN
PRINT "detected error. tho.. sopping mainexe() .ret=",.ret
END
CALL update_error(.ret)
RETURN
END
.END
.PROGRAM exec_move(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：移動処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_move()"
END
.l3type = data_l3type[.l2num,.l3num]
IF TRUE THEN
;IF flg_single_move==FALSE THEN
.sp = data_repspeed[.l2num,.l3num]
NOEXIST_SET_R data_accel[.l2num,.l3num] = data_acc
NOEXIST_SET_R data_decel[.l2num,.l3num] = data_dec
NOEXIST_SET_R data_accuracy[.l2num,.l3num] = data_accu
NOEXIST_SET_R data_abssp_mode[.l2num,.l3num] = 0
.acc = data_accel[.l2num,.l3num]
.dec = data_decel[.l2num,.l3num]
.accu = data_accuracy[.l2num,.l3num]
.sp_mode = data_abssp_mode[.l2num,.l3num]
ELSE ; 個別実行の時は速度固定
.sp = safty_move_sp
.acc = data_acc
.dec = data_dec
.accu = data_accu
.sp_mode = 3
END
NOEXIST_SET_R data_move_jt[.l2num,.l3num] = 0
NOEXIST_SET_R data_cv_no[.l2num,.l3num] = 0
NOEXIST_SET_R data_cv_work[.l2num,.l3num] = 0
NOEXIST_SET_R data_pos9[.l2num,.l3num] = 0
.rno = data_robottype[.l2num,.l3num]
.temp_rno = .rno
.move = data_move_jt[.l2num,.l3num]
.cvno = data_cv_no[.l2num,.l3num]
.cvwork = data_cv_work[.l2num,.l3num]
IF .cvno<>0 AND .cvwork<>0 THEN
.cvworkno = cur_cvcoop_wono[.rno]
IF cur_cvcoop_no[.rno]<>.cvno OR cur_cvcoop_wo[.rno]<>.cvwork OR cur_cvcoop_wono[.rno]==0 OR cv_norestart[.rno]==FALSE THEN
;コンベア同期開始処理が正常にされていない可能性がある
cv_norestart[.rno] = TRUE
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
POINT .cvslop = CVSLOPE:.rno(cv_coopjt[.rno,.cvno])+RY(-90)
ELSE
.cvworkno = 0
IF cur_cvcoop_no[.rno]<>0 OR cur_cvcoop_wo[.rno]<>0 OR cur_cvcoop_wono[.rno]<>0 THEN
;コンベア同期終了処理が正常にされていない可能性がある
CALL update_error(err_cvcoop)
WAIT cv_norestart[.rno]==FALSE
END
END
POINT .#cvpos = #PPOINT(data_pos9[.l2num,.l3num],data_pos9[.l2num,.l3num],0,0,0,0)
;前待ち時間待機
IF data_wait_befor[.l2num,.l3num]>=1 THEN
TWAIT data_wait_befor[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
;基準位置の作成
IF .l3type==l3type_shift THEN ;基準位置シフトステップの場合
.l3ref = data_refpos[.l2num,.l3num];基準位置の番号
IF .l3ref==0 THEN ;基準位置が現在位置
BREAK
.mode = mode_xyzr1ext1
CALL getcurrentpos(.temp_rno,.mode,.#pos,.ret)
;コンベア値を現在値に置き換える
DECOMPOSE .pos[1] = .#pos
IF .cvno<>0 AND .cvwork<>0 THEN
.cvpos = CVPOS2:.rno(.cvworkno,cv_coopjt[.rno,.cvno]);+cv_work_off[.cvno,.cvwork])
END
NOEXIST_SET_R .cvpos = 0
POINT .#cvpos = #PPOINT(.cvpos,.cvpos,0,0,0,0)
ELSE ;基準位置が現在位置ではない
NOEXIST_SET_R data_l3type[.l2num,.l3ref] = 9999
IF data_l3type[.l2num,.l3ref]<>l3type_move THEN
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(err_bad_l3type)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
.ref_move = data_move_jt[.l2num,.l3ref] ;基準位置の移動軸指定
;シフト移動軸が基軸のみ、基準位置が外部軸のみの場合または、シフト移動軸が外部軸のみ、基準位置が基軸のみの場合は基準位置を現在値とする。
IF ((.move==2) AND (.ref_move==0)) OR ((.move==0) AND (.ref_move==2)) THEN
BREAK
.mode = mode_xyzr1ext1 ;動作方法を変換値にする
;コンベア値を現在値に置き換える
DECOMPOSE .pos[1] = .#pos
IF .cvno<>0 AND .cvwork<>0 THEN
.cvpos = CVPOS2:.rno(.cvworkno,cv_coopjt[.rno,.cvno]);+cv_work_off[.cvno,.cvwork])
END
NOEXIST_SET_R .cvpos = 0
POINT .#cvpos = #PPOINT(.cvpos,.cvpos,0,0,0,0)
.l3ref = 0 ;基準位置番号を現在位置にする
CALL getcurrentpos(.temp_rno,.mode,.#pos,.ret)
ELSE
CALL getposdata(.l2num,.l3ref,.mode,.type,.#pos,.ret)
IF (.ref_move==2) OR (.move==2 AND .ref_move==1) THEN ;コンベア値を現在値に置き換える
IF .cvno<>0 AND .cvwork<>0 THEN
.cvpos = CVPOS2:.rno(.cvworkno,cv_coopjt[.rno,.cvno]);+cv_work_off[.cvno,.cvwork])
END
NOEXIST_SET_R .cvpos = 0
POINT .#cvpos = #PPOINT(.cvpos,.cvpos,0,0,0,0)
END
END
END
.type = data_postype[.l2num,.l3num]
ELSE ;移動ステップの場合
CALL getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
END
;最終位置の計算
IF .ret==err_no_error THEN
IF sys_force_cmode==TRUE THEN
.rno = 0
IF debug.prt.act==TRUE THEN
PRINT "exec_move()->強制協調動作モード"
END
END
;ビジョン処理結果反映
IF .l3type<>l3type_shift THEN ;移動ステップの場合
CALL update_vspos(.l2num,.l3num,.#pos,.#outpos,.cvno,.cvwork,.cvworkno,data_pos9[.l2num,.l3num],.&cvslop,.ret)
ELSE ;基準位置シフトの場合、基準位置のビジョン処理結果を使用
IF .l3ref<>0 THEN ;現在値の場合はビジョン処理結果は反映しない
CALL update_vspos(.l2num,.l3ref,.#pos,.#outpos,.cvno,.cvwork,.cvworkno,data_pos9[.l2num,.l3num],.&cvslop,.ret)
ELSE
POINT .temp_rno: .#outpos = .#pos
END
END
IF .ret<>err_no_error THEN
; 再開不可エラーとする
RETURN
END
IF .l3type==l3type_shift THEN ;シフトステップの場合
POINT .temp_rno: .#inpos = .#outpos
CALL shift_posmake(.temp_rno,.l2num,.l3num,.move,.mode,.#inpos,.#outpos,.ret)
END
; 動作中作業番号記憶用
IF .rno==robot_slave THEN
tmp_move_l3num[robot_slave] = .l3num
POINT robot_slave: #dest_pos[robot_slave] = .#outpos
dest_mode[robot_slave] = .mode
ELSE
tmp_move_l3num[robot_master] = .l3num
POINT robot_master: #dest_pos[robot_master] = .#outpos
dest_mode[robot_master] = .mode
END
; 動作後break有無確認
IF .accu<=1 THEN; 精度が1mm以下の場合はBREAK有
.bflag = TRUE
ELSE
; 先読み防止のための動作後BREAK有無確認
CALL chk_break(.l2num,.l3num,.bflag)
END
;movepos関数のBREAK有無フラグをFALSEにしてBREAK無しで実行する
CALL movepos(.rno,.#cvpos,.mode,.type,.#outpos,.bflag,.sp,.acc,.dec,.accu,.sp_mode,.cvno,.cvwork,.cvworkno,.ret)
IF data_wait_after[.l2num,.l3num]>=1 THEN
;完全停止後に待ち始める
BREAK
TWAIT data_wait_after[.l2num,.l3num]/1000  ; @@@ ミリ秒に変換 20140926 A.kobayashi
BREAK
END
ELSE
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(.ret)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
.END
.PROGRAM exec_pg(.ret)
;-------------------------------- 
;機能：プログラム実行
;引数：無し
;戻値：成否
;--------------------------------
.ret = err_no_error
CALL check_exec_pg(.flg_exec_main)
IF .flg_exec_main==TRUE THEN
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Start execute program automatically."
END
CALL execmain(robot_mode,robot_mode_flg,.ret)
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>5 THEN
.ret = err_main_start
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() ExecMain timeout occured."
END
RETURN
END
TWAIT ascycle
UNTIL (.ret<>err_no_error OR (((flg_main_run==TRUE) OR (flg_direct_run==TRUE)) AND (SWITCH(CS ,1)==ON AND flg_master_move==FALSE) AND (SWITCH(CS ,2)==ON) AND flg_slave_move==FALSE))
IF .ret<>err_no_error THEN
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Can not executed program."
END
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Executed program successfully."
END
END
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->exec_pg() Skipped executed program."
END
END
.END
.PROGRAM exec_vision(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：ビジョン処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_vision()"
END
;
CALL vcom_init;                              ビジョン変数初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+1; インターロックタイムアウト時間(sec)
.rno = data_robottype[.l2num,.l3num];        ロボット番号取得
IF .rno==1 THEN
SIGNAL ix_vloc_mas;                           マスター計測処理中ON
TWAIT ascycle;                            インターロック信号用
UTIMER @vtime_mas = 0;                    タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vloc_sla)==ON GOTO loc;       スレーブ側が計測していなければ
IF SIG(ix_vloc_now)==ON GOTO loc;        スレーブ側がロック確認中（デッドロックになったらマスター優先で抜ける）
TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_mas)>=.vtimeout;      タイムアウトするまで
.ret = err_vis_locmas;                     インターロックタイムアウトエラー(マスター)
SIGNAL -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
SIGNAL ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
RETURN;
ELSE
SIGNAL ix_vloc_sla,ix_vloc_now;               スレーブ計測処理中ON,スレーブロック確認中ON
TWAIT ascycle;                            インターロック信号用
UTIMER @vtime_sla = 0;                    タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vloc_mas)==ON GOTO loc;       マスター側が計測していなければ 
TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_sla)>=.vtimeout;      タイムアウトするまで
.ret = err_vis_locsla;                     インターロックタイムアウトエラー(スレーブ) 
SIGNAL -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
SIGNAL ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
RETURN;
END
loc:
IF .rno==2 THEN
SIGNAL -ix_vloc_now;                          スレーブロック確認中OFF
END
;
retry:
NOEXIST_SET_R data_vision_cnt[.l2num,.l3num] = 0
;作業実行時はマスター登録フラグは常にOFF
.recflg = FALSE
CALL get_vision_info(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.ret)
IF .ret==err_no_error THEN
CALL vision_main(data_robottype[.l2num,.l3num],data_vision_id[.l2num,.l3num],.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
IF .ret<>err_no_error AND data_vision_cnt[.l2num,.l3num]==1 THEN
.ret = err_no_error; ビジョンNG続行フラグONの場合エラーにしない(ログはvision_exeで取っている)
END
END
IF .ret<>err_no_error THEN
data_execute = FALSE
CALL update_error(.ret)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
flg_exec_first_ = TRUE
GOTO retry; エラー停止/再開
END
;
IF .rno==1 THEN
SIGNAL -ix_vloc_mas;                          マスター処理完了
ELSE
SIGNAL -ix_vloc_sla;                          スレーブ処理完了
END
.END
.PROGRAM exec_wend(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行終了処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_wcmd==TRUE THEN
RETURN
END
DO
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_wend()-> ....waiting SLAVE actioon"
END
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO," ,exec_wend()->      マスター・スレーブ並列動作終了"
END
;連続動作要求
flg_slave_paral = FALSE
.END
.PROGRAM exec_wstart(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：並列実行開始処理実行
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF disable_wcmd==TRUE THEN
RETURN
END
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,", exec_wstart()->      マスター・スレーブ並列動作開始"
END
BREAK; 並列動作開始の為BREAK
;連続動作要求
flg_slave_paral = TRUE
gs_l2num = .l2num
gs_l3num = .l3num
data_cur_l2rec[robot_slave] = .l2num
data_cur_l3rec[robot_slave] = .l3num
;動作開始指示
flg_slave_move = TRUE
.END
.PROGRAM execmain(.robot_mode,.robot_mode_flg,.ret)
;-------------------------------- 
;動作プログラム実行(初期化)
;引数：ロボットモード(0:タブレット、1:ダイレクト)、プログラム実行要否フラグ(ON/OFF)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;エラー状態を一旦解除する
g_last_error = err_no_error
;作業継続要求を一旦解除する
flg_master_con = FALSE
;ロボット状態初期化
CALL resetctrllinfo
;動作プログラム実行準備
CALL rdyboot(TRUE,.ret)
IF .ret<>err_no_error THEN
PRINT "RdyBoot()-> Error ocured,When called RdyBoot(TRUE,.ret)-function"
RETURN
END
UTIMER .@nowtime = 0
.exec_pg = FALSE
IF (.robot_mode==mode_direct) AND (.robot_mode_flg<>FALSE) THEN
MC EXECUTE 1: savmod
;ロボット状態遷移
robot_status = sta_direct
.exec_pg = TRUE
END
IF (.robot_mode<>mode_direct) THEN
MC EXECUTE 1: kof_main
;ロボット状態遷移
IF .robot_mode_flg<>FALSE THEN
robot_status = sta_tablet
END
.exec_pg = TRUE
END
IF .exec_pg==FALSE THEN
PRINT "ExecMain()-> MASTER-ROBOT dont execute program."
GOTO 10
END
DO
TWAIT ascycle
UNTIL ((SWITCH(CS ,1)==ON) OR UTIMER(.@nowtime)>.time_out)
;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
;MC/ERR .err_code = MC EXECUTE 1: main
;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
IF SWITCH(CS ,1)==OFF THEN
PRINT "Can NOT execute program on MASTER-ROBOT."
.ret = err_main_start
CALL update_error(.ret)
RETURN
END
10
UTIMER .@nowtime = 0
IF (.robot_mode==mode_direct) AND (.robot_mode_flg<>FALSE) THEN
MC EXECUTE 2: savmod
.exec_pg = TRUE
END
IF (.robot_mode<>mode_direct) THEN
MC EXECUTE 2: kof_sub
.exec_pg = TRUE
END
IF .exec_pg==FALSE THEN
PRINT "ExecMain()-> SLAVE-ROBOT dont execute program."
RETURN
END
DO
TWAIT ascycle
UNTIL ((SWITCH(CS ,2)==ON) OR UTIMER(.@nowtime)>.time_out)
;(P0111) 指定した指令（命令）はここでは受け付けられません。 No = 1001 
;MC/ERR .err_code = MC EXECUTE 2: sub 
;注意；本来はEXECUTEでエラーが発生しないように制御する実装のため無理やりスキップしても効果があるか不明
IF SWITCH(CS ,2)==OFF THEN
PRINT "Can NOT execute program on SLAVE-ROBOT."
.ret = err_main_start
CALL update_error(.ret)
RETURN
END
.END
.PROGRAM extout_ctl()
;-------------------------------- 
;機能：ランプ制御
;引数：無し
;戻値：無し
;--------------------------------
;    CHECK_LAMP_TIME = 0.5; 点滅間隔(sec)
;    CHECK_LAMP_CNT = 3; 接続確認点滅回数
;    CHECK_LAMP_MODE = 0; 点滅モード
NOEXIST_SET_R .flash_cnt = 0
;
IF exout_both_flas==TRUE THEN
;ﾀﾌﾞﾚｯﾄ通信確認
.flash_time = check_lamp_time
IF .flash_cnt==0 THEN
CASE check_lamp_mode OF
VALUE 1:;交互点滅
IF (SIG(extout_start_bu) XOR SIG(extout_stop_but))==FALSE THEN
SIGNAL extout_start_bu,-extout_stop_but
.flash_cnt = 1
UTIMER @lamp_flash = 0
END
ANY :;同時点滅
IF (SIG(extout_start_bu) XOR SIG(extout_stop_but)) THEN
SIGNAL extout_start_bu,extout_stop_but
.flash_cnt = 1
UTIMER @lamp_flash = 0
END
END
END
IF check_lamp_cnt*2<.flash_cnt THEN
exout_both_flas = FALSE
SIGNAL -extout_start_bu,-extout_stop_but
.flash_cnt = 0
END
IF .flash_time<UTIMER(@lamp_flash) THEN
CASE check_lamp_mode OF
VALUE 1:;交互点滅
IF SIG(extout_start_bu)==ON AND SIG(extout_stop_but)==OFF THEN
SIGNAL -extout_start_bu,extout_stop_but
ELSE
SIGNAL extout_start_bu,-extout_stop_but
END
ANY :;同時点滅
IF SIG(extout_start_bu)==ON AND SIG(extout_stop_but)==ON THEN
SIGNAL -extout_start_bu,-extout_stop_but
ELSE
SIGNAL extout_start_bu,extout_stop_but
END
END
.flash_cnt = .flash_cnt+1
UTIMER @lamp_flash = 0
END
ELSE
;ロボット状態遷移情報
IF g_last_error<>err_no_error OR (SWITCH(ERROR ,1)==ON) OR (SWITCH(ERROR ,2)==ON) THEN
IF g_last_error==err_no_error THEN
IF (SYSDATA(ERROR.CODE,1)<>OFF) AND (SYSDATA(ERROR.CODE,2)<>OFF) THEN;2台同時にエラーコード有り
g_last_error = err_roboterror[0];ロボット本体異常発生中（2台同時発生中）
ELSE
IF SYSDATA(ERROR.CODE,1)<>OFF THEN;マスタロボットで発生中
g_last_error = err_roboterror[1];下アーム異常発生中
ELSE
g_last_error = err_roboterror[2];上アーム異常発生中
END
END
END
robot_status_ou = sta_error
ELSE
CASE robot_status OF
VALUE sta_exe,sta_l2exe,sta_gen,sta_direct,sta_tablet,sta_gravityadj,sta_vscalib:
IF (SWITCH(CS ,1)==ON OR TASK(1)==1) OR (SWITCH(CS ,2)==ON OR TASK(2)==1) THEN
robot_status_ou = robot_status
ELSE
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
robot_status_ou = sta_hold
ELSE
robot_status_ou = sta_nomove
END
END
ANY :
robot_status_ou = robot_status
END
END
FOR .i = 0 TO robot_status_ma
IF .i<>robot_status_ou THEN
IF flg_extout_stat[.i]<>FALSE THEN
SIGNAL -sig_extout_stat[.i]
END
END
END
IF flg_extout_stat[robot_status_ou]<>FALSE THEN
SIGNAL sig_extout_stat[robot_status_ou]
END
;ロボットモード状態によって点灯パターン別け
IF g_last_error<>err_no_error OR robot_status_ou==sta_error THEN
;エラー発生中
.flash_time = extout_flashtim
SIGNAL -extout_start_bu
IF .flash_time<UTIMER(@lamp_flash) THEN
IF SIG(extout_stop_but)==ON THEN
SIGNAL -extout_stop_but
ELSE
SIGNAL extout_stop_but
END
UTIMER @lamp_flash = 0
END
ELSE
CASE robot_status_ou OF
VALUE sta_nomove:
SIGNAL -extout_start_bu,extout_stop_but
VALUE sta_exe,sta_l2exe,sta_direct,sta_tablet,sta_vscalib,sta_gravityadj:
.flash_time = extout_flashtim
SIGNAL -extout_stop_but
IF ((flg_l2chk_wait<>FALSE) AND (robot_status_ou==sta_exe OR robot_status_ou==sta_l2exe)) THEN
;実行条件待ちの場合
IF .flash_time<UTIMER(@lamp_flash) THEN
IF SIG(extout_start_bu)==ON THEN
SIGNAL -extout_start_bu
ELSE
SIGNAL extout_start_bu
END
UTIMER @lamp_flash = 0
END
ELSE
SIGNAL extout_start_bu,-extout_stop_but
END
VALUE sta_hold:
.flash_time = extout_flashtim
SIGNAL extout_stop_but
IF .flash_time<UTIMER(@lamp_flash) THEN
IF SIG(extout_start_bu)==ON THEN
SIGNAL -extout_start_bu
ELSE
SIGNAL extout_start_bu
END
UTIMER @lamp_flash = 0
END
VALUE sta_gen:
.flash_time = extout_flashtim
SIGNAL extout_start_bu
IF .flash_time<UTIMER(@lamp_flash) THEN
IF SIG(extout_stop_but)==ON THEN
SIGNAL -extout_stop_but
ELSE
SIGNAL extout_stop_but
END
UTIMER @lamp_flash = 0
END
END
END
END
;動作中のスイッチ切替
IF flg_tglsw_repea==FALSE THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (data_execute==TRUE) OR (flg_master_move==TRUE) OR (flg_slave_move==TRUE) THEN
IF flg_tglsw_chger<>FALSE THEN
CALL update_error(err_extio_chang)
END
$prm[TASKNO,1] = "-1"
CALL cmdabort(.ret)
END
;作業再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
;ロボット状態遷移
robot_status = sta_nomove
;強制的にロボットモード変更
robot_mode = mode_tablet
robot_mode_flg = OFF
flg_tglsw_repea = TRUE
END
ELSE
IF SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
IF (SWITCH(CS ,1)==ON) OR (SWITCH(CS ,2)==ON) OR (data_execute==TRUE) OR (flg_master_move==TRUE) OR (flg_slave_move==TRUE) THEN
IF flg_tglsw_chger<>FALSE THEN
CALL update_error(err_extio_chang)
END
$prm[TASKNO,1] = "-1"
CALL cmdabort(.ret)
END
;作業再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
;ロボット状態遷移
robot_status = sta_nomove
;強制的にロボットモード変更
robot_mode = mode_tablet
robot_mode_flg = OFF
flg_tglsw_repea = FALSE
END
END
.END
.PROGRAM extout_home()
;-------------------------------- 
;機能：アームが原点位置に所在する場合は外部信号を出力
;引数：無し
;戻値：無し
;-------------------------------- 
.dsig_home[1] = SYSDATA(DSIG.HOME1,robot_master)
.dsig_home[2] = SYSDATA(DSIG.HOME1,robot_slave)
.dsig_home[3] = SYSDATA(DSIG.HOME2,robot_master)
.dsig_home[4] = SYSDATA(DSIG.HOME2,robot_slave)
FOR .i = 1 TO 4
IF .dsig_home[.i]<>0 THEN
.home_sta[.i] = SIG(.dsig_home[.i])
ELSE
.home_sta[.i] = 0
END
END
IF flg_extout_home[1]<>FALSE THEN
IF .home_sta[1]==ON THEN
SIGNAL sig_extout_home[1]
ELSE
SIGNAL -sig_extout_home[1]
END
IF .home_sta[2]==ON THEN
SIGNAL sig_extout_home[2]
ELSE
SIGNAL -sig_extout_home[2]
END
END
IF flg_extout_home[2]<>FALSE THEN
IF .home_sta[3]==ON THEN
SIGNAL sig_extout_home[3]
ELSE
SIGNAL -sig_extout_home[3]
END
IF .home_sta[4]==ON THEN
SIGNAL sig_extout_home[4]
ELSE
SIGNAL -sig_extout_home[4]
END
END
.END
.PROGRAM gen(.ret)
;-------------------------------- 
;機能：ホーム移動
;引数：動作速度(.sp)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() .rno=",$prm[TASKNO,1]
END
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
INTFCHK ON
ELSE
IF kroset==TRUE THEN
INTFCHK ON
END
END
CASE VAL($prm[TASKNO,1]) OF
VALUE robot_all:
flg_slave_move = TRUE
IF debug.prt.main==ON THEN
PRINT "TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
END
;原点番号設定
.home_no = VAL($prm[TASKNO,3])
;ロボット番号設定
.rno = robot_all
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
END
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
END
END
TWAIT ascycle
END
VALUE robot_master:
;原点番号設定
.home_no = VAL($prm[TASKNO,3])
;ロボット番号設定
.rno = robot_master
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() MASTER robot moved to HOME-POSITION."
END
VALUE robot_slave:
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() Slave robot moved to HOME-POSITION."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdgen() WAITING Slave robot move to HOME-POSITION."
END
END
TWAIT ascycle
END
END
BREAK
.END
.PROGRAM gen_core(.rno,.home_no,.sp,.ret)
;-------------------------------- 
;機能：ホーム移動コア処理
;引数：ホーム番号、動作速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.gen==ON THEN
PRINT "gen_core()-> TASKNO=",TASKNO,".rno=",.rno,".home_no=",.home_no,",.sp=",.sp
END
CALL chg_sp(.sp,.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
IF zsw_mode_home==ON AND .rno<>robot_master AND .rno<>robot_slave THEN ;ZSW_MODE_HOME=-1
IF TASKNO==pg_master THEN ;マスターの処理
CALL gohome_main(.home_no,.ret);原点復帰ﾊﾟﾀｰﾝ選択
CALL cont_timing;マスタとスレーブのタイミングを合わせ
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
CALL gohome_move(pg_master,gohome_ptn,.home_no,.ret);BASE引き動作
ELSE ;スレーブの処理
CALL cont_timing;マスタとスレーブのタイミングを合わせ
IF gohome_ptn==0 THEN
RETURN
END
CALL gohome_move(pg_slave,gohome_ptn,.home_no,.ret);BASE引き動作
END
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
ELSEIF zsw_mode_home==-2 AND .rno<>robot_master AND .rno<>robot_slave THEN
IF .rno==robot_all AND EXISTDATA("gohome_mcr",G)==TRUE THEN
CALL gohome_mcr(.home_no,.ret)
ELSE
.ret = err_noexist_pg ;ﾌﾟﾛｸﾞﾗﾑが存在しない
CALL update_error(.ret)
RETURN
END
ELSEIF zsw_mode_home==OFF OR .rno==robot_master OR .rno==robot_slave THEN ;ZSW_MODE_HOME=0または片ｱｰﾑ指定
.armno = TASKNO
.axis = SYSDATA(ZROB.NOWAXIS,.armno)
DECOMPOSE .armno: .jho[1] = #HOME(.home_no)
DECOMPOSE .armno: .jhe[1] = #S_HERE(.armno)
FOR .i = 4 TO 8
NOEXIST_SET_R .jho[.i] = 0
NOEXIST_SET_R .jhe[.i] = 0
IF SYSDATA(JTEXIST,.armno,.i)<>FALSE THEN
IF SYSDATA(HOME_CHK,.armno,.i)<>FALSE THEN
.temp[.i] = .jho[.i]
ELSE
.temp[.i] = .jhe[.i]
END
ELSE
.temp[.i] = .jhe[.i]
END
END
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6]);原点対象の軸のみ原点に戻す
VALUE 5:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6],.temp[7]);原点対象の軸のみ原点に戻す
VALUE 6,7,8:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6],.temp[7],.temp[8]);原点対象の軸のみ原点に戻す
END
ELSE
.ret = err_bat_value ;不正な指定
CALL update_error(.ret)
RETURN
END
.END
.PROGRAM get_cnt_status(.no,.num)
;-------------------------------- 
;機能：カウンタの状態を取得
;引数：開始カウンタ番号、カウンタ数
;戻値：カウンタ値(配列)
;-------------------------------- 
; 初期化
FOR .i = 1 TO 5
disp_cntnum[.i] = 0
END
; 入力値確認
IF .num<=0 OR 5<.num THEN; カウンタ数が範囲外か確認
IF .num<=0 THEN
.num = 1; 最小
ELSE
.num = 5; 最大
END
END
IF .no<=0 OR max_cntnum<(.no+.num-1) THEN; カウンタ番号が範囲外か確認
IF .no<=0 THEN
.no = 1
ELSE
.no = max_cntnum-(.num-1)
END
END
; カウンタ読み取り
FOR .i = 1 TO .num
disp_cntnum[.i] = data_cntnum[.no+(.i-1)]
END
.END
.PROGRAM get_cominfo(.type,.tcp_port,.tcp_sid,.tcp_sid_num,.udp_port)
;-------------------------------- 
;機能：通信ターゲット情報取得
;引数：なし
;戻値：受信文字列、成否
;-------------------------------- 
.tcp_port = -1
.tcp_sid = -1
.tcp_sid_num = -1
.udp_port = -1
.task_no = TASKNO
CASE .type OF
VALUE type_open:
IF .task_no==pg_com_act THEN
;動作命令用(PCプログラム)
.tcp_port = tcp_listen_port[0]
.tcp_sid_num = 0
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.tcp_port = tcp_listen_port[1]
.tcp_sid_num = 1
ELSE
PRINT "TYPE_OPEN -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
RETURN
END
END
VALUE type_recv:
IF .task_no==pg_com_act THEN
;動作命令用(PCプログラム)
.udp_port = port_udp[1]
.tcp_sid = tcp_sid[0]
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.udp_port = port_udppc[1]
.tcp_sid = tcp_sid[1]
ELSE
PRINT "TYPE_RECV -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
END
END
VALUE type_send:
IF .task_no==pg_master OR .task_no==pg_slave OR .task_no==pg_com_act OR .task_no==1001 THEN
;動作命令用(メインプログラム、もしくはPCプログラム)
.udp_port = port_udp[0]
.tcp_sid = tcp_sid[0]
ELSE
IF .task_no==pg_com_noact THEN
;非動作命令用(PCプログラム)
.udp_port = port_udppc[0]
.tcp_sid = tcp_sid[1]
ELSE
PRINT "TYPE_SEND -> CALL-STATUS is TOO BAD! FROM WHERE are YOU CALLING THIS PROGRAM? TASKNO=",TASKNO
END
END
END
.END
.PROGRAM get_cwstatus(.l2num,.l3num,.req_cstart,.req_wstart)
;-------------------------------- 
;機能：データを遡って協調開始コマンド、並列実行コマンドが無いかチェックする
;引数：第2階層、第3階層
;戻値：並列実行再要求フラグ、協調動作再実行フラグ
;-------------------------------- 
.req_cstart = FALSE
.req_wstart = FALSE
FOR .i = .l3num TO 1 STEP -1
IF data_l3type[.l2num,.i]==l3type_cend THEN
;STARTの前にENDを見つけたら探索中断、再実行不要
GOTO 10
END
IF data_l3type[.l2num,.i]==l3type_cstart THEN
;再度必要
.req_cstart = TRUE
GOTO 10
END
END
10
FOR .i = .l3num TO 1 STEP -1
IF data_l3type[.l2num,.i]==l3type_wend THEN
;STARTの前にENDを見つけたら探索中断、再実行不要
IF data_cur_l2rec[robot_slave]<>0 AND data_cur_l3rec[robot_slave] THEN
;スレーブロボット動作中のため再度必要
.req_wstart = TRUE
END
GOTO 20
END
IF data_l3type[.l2num,.i]==l3type_wstart THEN
;再度必要
.req_wstart = TRUE
GOTO 20
END
END
20
IF .req_wstart==TRUE THEN
IF data_l3type[.l2num,.l3num]==l3type_call THEN
;マクロPG実行中に停止している場合、協調状態を確認
.coops[1] = COOPSTATUS(robot_master)
.coops[2] = COOPSTATUS(robot_slave)
IF (.coops[1]>=3 AND .coops[2]>=3) THEN
;マクロPG実行中で協調状態になっている場合、CONTINUEする
.req_cstart = TRUE
END
END
END
.END
.PROGRAM get_error_mess(.err_code,.$err_mess)
;-------------------------------- 
;機能：エラーの内容を取得
;引数：エラーコード
;戻値：エラーメッセージ
;-------------------------------- 
;
CASE .err_code OF
VALUE err_no_error:; 0
.$err_mess = ""
VALUE err_robot_busy:; 1000
.$err_mess = "動作中に実行できないコマンドを受信した  Received inexecutable command during operation."
VALUE err_poweron:; 1001
.$err_mess = "モータ電源をONにできないので自動運転できない  Motor power cannot be turned ON. Auto operation is disabled."
VALUE err_teach_lock:; 1002
.$err_mess = "ティーチロックがONなので自動運転できない  Teach lock is ON. Auto operation is disabled."
VALUE err_repeat:; 1003
.$err_mess = "リピートモードで無い  Not in repeat mode. "
VALUE err_pccom_start:; 1007
.$err_mess = "通信プログラムを開始できない  Communication program cannot be started."
VALUE err_motor_off:; 1011
.$err_mess = "モータ電源をOFFにできない  Motor power cannot be turned OFF."
VALUE err_cs_off:; 1012
.$err_mess = "実行中作業が不正に停止した  Execution stopped abnormally"
VALUE err_main_stop:; 1013
.$err_mess = "実行中作業停止異常  Running program terminated/stopped abnormally."
VALUE err_main_start:; 1014
.$err_mess = "作業実行開始異常  Start execution error. "
VALUE err_robotmode:; 1015
.$err_mess = "実行可能条件が未成立  Unsatisfied execution conditions"
VALUE err_extio_unkno:; 1016
.$err_mess = "操作パネルのモード切替スイッチ状態が不明  Mode switch state unknown"
VALUE err_extio_disab:; 1017
.$err_mess = "操作パネルのモード切替スイッチ状態が不適  Mode change switch on control panel is not appropriate state"
VALUE err_extio_chang:; 1018
.$err_mess = "操作パネルのモード切替スイッチが動作中に切り替わった  Mode switch on the operation panel switched during operation."
VALUE err_roboterror[0]:; 1020
CALL get_error_robot(1,.$err_rob); ロボット本体のエラーの内容を取得
.$err_mess = "ロボット本体異常発生中（2台同時発生中）  Robot is in abnormal state. (Both arms are in abnormal state.) "+.$err_rob
VALUE err_roboterror[1]:; 1021
CALL get_error_robot(1,.$err_rob); ロボット本体のエラーの内容を取得
.$err_mess = "下アーム異常発生中  Lower arm is in abnormal state. "+.$err_rob
VALUE err_roboterror[2]:; 1022
CALL get_error_robot(2,.$err_rob); ロボット本体のエラーの内容を取得
.$err_mess = "上アーム異常発生中  Upper arm is in abnormal state. "+.$err_rob
VALUE err_emg_stop:; 1023
.$err_mess = "動作中にモータ電源がOFFした  Motor power OFF while in operation"
VALUE err_out_range:; 1024
.$err_mess = "動作目標位置が範囲外の為移動不可  Target out of range. Unable to move."
VALUE err_mem_value:; 1025
.$err_mess = "メモリ残量不足異常"
VALUE err_not_load:; 1026
.$err_mess = "作業データ転送未完了"
VALUE err_cant_conver:; 2000
.$err_mess = "文字列を実数配列または文字列配列に切り出せない  Cannot split string to arrays"
VALUE err_sig_timeout:; 2002
.$err_mess = "信号がタイムアウト  Signal timed out."
VALUE err_exe_name:; 2003
.$err_mess = "実行ファイル名が不正  File name is invalid."
VALUE err_emg_on:; 2004
.$err_mess = "非常停止がON中でコマンドを実行できない  Emergency stop is ON. Cannot execute command."
VALUE err_bad_axesno:; 2009
.$err_mess = "軸番号に不正値を指定した  Inappropriate Joint number "
VALUE err_bad_areano:; 2010
.$err_mess = "低速動作エリア番号に不正値を指定した  Inappropriate (low speed) area number"
VALUE err_bad_positio:; 2011
.$err_mess = "現在位置からは実行・再開できません。  Cannot execute or restart in the current position."
VALUE err_gravityadj:; 2012
.$err_mess = "重力補償自動設定に失敗しました。手動で設定して下さい  Failed in auto gravity compensation setting. Set manually. "
VALUE err_l3type_stop:; 2013
.$err_mess = "作業停止した  It stopped working."
VALUE err_coop_chg:; 2014
.$err_mess = "協調状態が変更された"
VALUE err_noexist_pg:; 2015
.$err_mess = "指定したプログラムが存在しない"
VALUE err_mcrpos_ng:; 2016
.$err_mess = "教示位置生成ができなかった"
VALUE err_gen_noptn:;2030
.$err_mess = "原点復帰条件未成立  Conditions for returning to home pose are not satisfied."
VALUE err_gen_jt1:;2031
.$err_mess = "1軸回転量異常  JT1 over rotated."
VALUE err_gen_jt2:;2032
.$err_mess = "2軸回転量異常  JT2 over rotated."
VALUE err_gen_base[1]:;2033
.$err_mess = "下ｱｰﾑが安全距離まで引けてない  Lower arm is outside the safe area."
VALUE err_gen_base[2]:;2034
.$err_mess = "上ｱｰﾑが安全距離まで引けてない  Upper arm is outside the safe area."
VALUE err_gen_pos:;2035
.$err_mess = "原点姿勢異常  Abnormal home pose "
VALUE err_bat_value:;2036
.$err_mess = "設定値が範囲外です  Set value out of range"
VALUE err_work_set:;2037
.$err_mess = "作業グルーピン設定異常  invalid operation setting"
VALUE err_work_unmatc:;2038
.$err_mess = "作業グループ番号不一致異常  operation setting number mismatch"
VALUE err_cv_setting:;2040
.$err_mess = "コンベア関連設定が不正"
VALUE err_cv_timeout:;2041
.$err_mess = "コンベア待ちタイムアウト"
VALUE err_cv_wait:;2042
.$err_mess = "コンベア上のワークが行き過ぎです"
VALUE err_cvpc_ready:;2043
.$err_mess = "コンベア同期監視プログラム異常"
VALUE err_cvcoop:;2044
.$err_mess = "コンベア同期処理に失敗しました"
VALUE err_cv_nowork:;2045
.$err_mess = "コンベア上に対象のワークがありません"
VALUE err_cmd_type:; 3000
.$err_mess = "コマンドIDにサポート外の番号を指定した  Unsupported number is specified for command ID."
VALUE err_cmd_prmnum:; 3001
.$err_mess = "タブレットからの指令受信異常(01)  Command receiving error from Tablet(01)."
VALUE err_bad_mode:; 3003
.$err_mess = "タブレットからの指令受信異常(03)  Command receiving error from Tablet(03)."
VALUE err_bad_ptype:; 3004
.$err_mess = "タブレットからの指令受信異常(04)  Command receiving error from Tablet(04)."
VALUE err_bad_name:; 3005
.$err_mess = "タブレットからの指令受信異常(05)  Command receiving error from Tablet(05)."
VALUE err_bad_num:; 3006
.$err_mess = "タブレットからの指令受信異常(06)  Command receiving error from Tablet(06)."
VALUE err_bad_l3type:; 3007
.$err_mess = "タブレットからの指令受信異常(07)  Command receiving error from Tablet(07)."
VALUE err_bad_rno:; 3008
.$err_mess = "タブレットからの指令受信異常(08)  Command receiving error from Tablet(08)."
VALUE err_cmd_timeout:; 3009
.$err_mess = "コマンドがタイムアウトした  Command timed out."
VALUE err_srobot_time:; 3010
.$err_mess = "上アームが協調動作を開始できなかった  Upper arm failed to start cooperative motion. "
VALUE err_srobot_erro:; 3011
.$err_mess = "上アームが協調動作を終了できなかった  Upper arm failed to stop cooperative motion. "
VALUE err_bad_homeno:; 3012
.$err_mess = "ホーム番号に不正値を指定した  Invalid value is specified for home pose number."
VALUE err_bad_signo:; 3013
.$err_mess = "信号番号に不正値を指定した  Invalid value is specified for signal number."
VALUE err_bad_tableno:; 3014
.$err_mess = "タブレットからの指令受信異常(09)  Command receiving error from Tablet(09)."
VALUE err_bad_speed:; 3015
.$err_mess = "速度指定値に不正値を指定した  Invalid value is specified for speed settings."
VALUE err_bad_handio:; 3016
.$err_mess = "ハンドIO番号に不正値を指定した  Invalid value is specified for hand IO number."
VALUE err_robot_cmon:; 3018
.$err_mess = "協調解除処理に失敗した  Failed to cancel cooperation."
VALUE err_chg_sp:; 3019
.$err_mess = "速度変更に失敗した  Failed to change speed. "
VALUE err_bad_visionn:; 3020
.$err_mess = "ビジョンIDテーブルの状態が不正  Inappropriate vision ID"
VALUE err_still_worki:; 3021
.$err_mess = "ロボットが動作中のためコマンド実行に失敗した  Robot in operation. Command execution failed."
VALUE err_vis_cmd:; 4001
.$err_mess = "ビジョン通信コマンド異常  Vision communication command error."
VALUE err_vis_cam:; 4002
.$err_mess = "カメラ画像取込異常  Camera image loading error."
VALUE err_vis_setting:; 4003
.$err_mess = "計測設定異常  Measurement settings error."
VALUE err_vis_measure:; 4004
.$err_mess = "想定外の計測異常  Unexpected measurement error."
VALUE err_vis_nocalib:; 4005
.$err_mess = "キャリブレーション未実施  Calibration was not executed."
VALUE err_vis_recog0:; 4006
.$err_mess = "認識個数0個異常  No items are recognized. "
VALUE err_vis_teach:; 4020
.$err_mess = "マスター登録時複数個認識  Multiple workpices are recognized at master registration. "
VALUE err_vis_outom:; 4030
.$err_mess = "ビジョン受信文字列異常 Vision receive command error."
VALUE err_vis_jgom:; 4031
.$err_mess = "検出ワーク判定NG Detected work judge error."
VALUE err_vis_mesom:; 4032
.$err_mess = "ビジョン検査設定異常 Vision inspecsion setting error."
VALUE err_vis_oorom:; 4033
.$err_mess = "検出ワーク領域外 Work is out of region."
VALUE err_vis_calom:; 4034
.$err_mess = "キャリブレーション１回目未実施 Calibration first is no-execution."
VALUE err_vis_lesspos:; 4050
.$err_mess = "装置補正計測点数不足  Pallet calibration measurement points are not enough. "
VALUE err_vis_poschk:; 4051
.$err_mess = "装置位置ズレ異常  Position deviation error."
VALUE err_vis_distchk:; 4052
.$err_mess = "装置2点間距離異常  The distance between the two points error."
VALUE err_vis_calst:; 4061
.$err_mess = "キャリブレーション開始エラー  Camera calibration start error."
VALUE err_vis_calmeas:; 4062
.$err_mess = "キャリブレーション計測エラー  Camera calibration measurement error."
VALUE err_vis_calend:; 4063
.$err_mess = "キャリブレーション完了エラー  Camera calibration completion error."
VALUE err_vis_chkng:; 4064
.$err_mess = "キャリブレーション精度チェックエラー  Callibration accuracy check failed"
VALUE err_vis_cvcal:; 4065
.$err_mess = "キャリブティーチ3点間の距離が近すぎます  Callibration teaching points are too near"
VALUE err_vis_contng:; 4070
.$err_mess = "ビジョン補正作業続行不可  Vision correction unable to continue"
VALUE err_vis_locmas:; 4080
.$err_mess = "並列作業インターロックタイムアウトエラー（マスター）  Parallel work interlock timeout error (master)"
VALUE err_vis_locsla:; 4081
.$err_mess = "並列作業インターロックタイムアウトエラー（スレーブ）  Parallel work interlock timeout error (slave)"
VALUE err_vis_only:; 4088
.$err_mess = "片方向通信モードエラー  Oneway communication mode error"
VALUE err_vis_unknow:; 4089
.$err_mess = "不明な通信エラー  Unknown communication error"
VALUE err_vis_send:; 4091
.$err_mess = "送信エラー  Sending error"
VALUE err_vis_recv:; 4092
.$err_mess = "受信エラー  Receiving error"
VALUE err_vis_tout1:; 4093
.$err_mess = "受信開始待ちタイムアウトエラー  Reception start wait time out error."
VALUE err_vis_tout2:; 4094
.$err_mess = "受信完了待ちタイムアウトエラー  Reception completion wait time out error."
VALUE err_vis_tout3:; 4095
.$err_mess = "受信ＰＧ起動待ちタイムアウトエラー  Reception PG start wait time out error."
VALUE err_vis_tout4:; 4096
.$err_mess = "送信ＰＧ起動待ちタイムアウトエラー  Sending PG start wait time out error."
VALUE err_vis_tout5:; 4097
.$err_mess = "通信完了(実行中)待ちタイムアウトエラー  Communication completion wait time out error."
VALUE err_vis_tout6:; 4098
.$err_mess = "送信ＰＧ実行待ちタイムアウトエラー  Sending PG execution wait time out error."
VALUE err_vis_tout7:; 4099
.$err_mess = "通信完了待ちタイムアウトエラー  Communication completion wait time out error."
VALUE err_slave_acten:; 5001
.$err_mess = "5001"
VALUE err_l3_actend:; 5002
.$err_mess = "5002"
ANY :
.$err_mess = "Unknown error :ID="+$ENCODE(.err_code)
END
.END
.PROGRAM get_error_robot(.rob_no,.$err_rob)
;-------------------------------- 
;機能：ロボット本体のエラーの内容を取得
;引数：ロボット番号
;戻値：エラーコード＋エラーメッセージ
;-------------------------------- 
;
.$err_rob = ""
.err_code = SYSDATA(ERROR.CODE,.rob_no); 指定されたロボットで発生しているエラーの番号を取得
IF .err_code<>err_no_error THEN
.$err_msg = $ERROR(.err_code); エラーの番号からメッセージを取得
;
.err_axis = SYSDATA(ERROR.AXIS,.rob_no); 指定されたロボットで発生しているエラーの軸番号を取得
IF .err_axis<>0 THEN; エラー発生中の軸がある場合
.$axis = ""
FOR .jt_no = 1 TO 4
IF .err_axis BAND 2^(.jt_no-1) THEN
IF .$axis=="" THEN
.$axis = $ENCODE(/L,.jt_no)
ELSE
.$axis = .$axis+","+$ENCODE(/L,.jt_no)
END
END
END
.$err_msg = $REPLACE(.$err_msg,"%-M",.$axis,-1) ;軸番号に置き換え
.$err_msg = $REPLACE(.$err_msg,"%-ld",.$axis,-1) ;軸番号に置き換え
.$err_msg = $REPLACE(.$err_msg,"%-d",.$axis,-1) ;軸番号に置き換え
.$err_msg = $REPLACE(.$err_msg,"%ld",.$axis,-1) ;軸番号に置き換え
.$err_msg = $REPLACE(.$err_msg,"%d",.$axis,-1) ;軸番号に置き換え
END
;
.$str_code = $ENCODE(/L,.err_code)
.err_type = INT(.err_code/10000)
CASE .err_type OF
VALUE -4:
.$err_code = "D"+$RIGHT(.$str_code,4)
VALUE -3:
.$err_code = "E"+$RIGHT(.$str_code,4)
VALUE -2:
.$err_code = "W"+$RIGHT(.$str_code,4)
VALUE -1:
.$err_code = "P"+$RIGHT(.$str_code,4)
ANY :
.$err_code = .$str_code
END
.$err_rob = " >>> ("+.$err_code+")"+.$err_msg
END
.END
.PROGRAM get_io_status(.no,.num,.bit_io)
;-------------------------------- 
;機能：I/Oの状態を取得
;引数：開始信号番号、信号数
;戻値：信号状態
;-------------------------------- 
; 初期化
.bit_io = 0
; 信号数取得
.ox_num = SYSDATA(ZSIGSPEC.DO); 出力信号
.wx_num = SYSDATA(ZSIGSPEC.DI); 入力信号
.ix_num = SYSDATA(ZSIGSPEC.INT); 内部信号
; 汎用フィールドバスI/O設定取得
.fb_io = ZOPTION(13,2)
IF .fb_io<>OFF THEN
.ox_num = .ox_num+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
.wx_num = .wx_num+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
END
; 入力値確認
IF .num<=0 OR 16<.num THEN; 信号数が範囲外か確認
IF .num<=0 THEN
.num = 1; 最小
ELSE
.num = 16; 最大
END
END
IF .no<=0 OR (.ox_num<(.no+.num-1) AND .no<=1000) OR ((1000+.wx_num)<(.no+.num-1) AND .no<=2000) OR ((2000+.ix_num)<(.no+.num-1)) THEN; 信号番号が範囲外か確認
IF .no<=0 THEN
.no = 1
ELSE
IF (.ox_num<(.no+.num-1) AND .no<=1000) THEN; 出力信号範囲外の時
.no = .ox_num-(.num-1)
ELSE
IF ((1000+.wx_num)<(.no+.num-1) AND .no<=2000) THEN; 入力信号範囲外の時
.no = 1000+.wx_num-(.num-1)
ELSE
IF ((2000+.ix_num)<(.no+.num-1)) THEN; 内部信号範囲外の時
.no = 2000+.ix_num-(.num-1)
ELSE
.no = 1
END
END
END
END
END
; 信号状態読み取り
.bit_io = BITS(.no,.num)
.END
.PROGRAM get_iotype(.signo,.sigtype,.ret)
;-------------------------------- 
;機能：IO種類取得(信号設定範囲外の場合はエラー)
;引数：信号番号
;戻値：IO種類、成否
;-------------------------------- 
.ret = err_no_error
.sigtype = io_unknown
.fb_io = ZOPTION(13,2);汎用フィールドバスI/O設定
IF (0<.signo) AND (.signo<1000) THEN
IF .fb_io<>OFF THEN;汎用FB設定ON
.out_sig_num = SYSDATA(ZSIGSPEC.DO)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
.out_sig_num = SYSDATA(ZSIGSPEC.DO)
END
IF .signo<=.out_sig_num THEN
.sigtype = io_do
RETURN
END
END
IF (1000<.signo) AND (.signo<2000) THEN
IF .fb_io<>OFF THEN;汎用FB設定ON
.in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
.in_sig_num = 1000+SYSDATA(ZSIGSPEC.DI)
END
IF .signo<=.in_sig_num THEN
.sigtype = io_di
RETURN
END
END
IF (2000<.signo) AND (.signo<3000) THEN
IF .signo<=(2000+SYSDATA(ZSIGSPEC.INT)) THEN
.sigtype = io_int
RETURN
END
END
.ret = err_bad_signo
IF debug.prt.cmd==TRUE THEN
IF .fb_io<>OFF THEN;汎用FB設定ON
PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT),SYSDATA(ZSIGSPEC.MAS),SYSDATA(ZSIGSPEC.SLA)
ELSE;汎用FB設定OFF
PRINT "TASKNO=",TASKNO,", get_iotype()->",.signo,"=err_bad_signo",SYSDATA(ZSIGSPEC.DO),SYSDATA(ZSIGSPEC.DI),SYSDATA(ZSIGSPEC.INT)
END
END
.END
.PROGRAM get_jttype(.rno,.mode,.#axis_type)
;-------------------------------- 
;機能：軸構成情報取得
;引数：ロボット番号、動作方法(.mode->0;JT、1:XYZR1EXT1)
;戻値：成否
;-------------------------------- 
;初期化
;MODE_LIN = 0
;MODE_ROT = 1
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
IF .mode==mode_jt THEN
.axis_type[1] = mode_rot;JT1
.axis_type[2] = mode_rot;JT2
.axis_type[3] = mode_lin;JT3
.axis_type[4] = mode_rot;JT4
.axis_type[5] = mode_none;
.axis_type[6] = mode_none;
ELSE
.axis_type[1] = mode_lin;X
.axis_type[2] = mode_lin;Y
.axis_type[3] = mode_lin;Z
.axis_type[4] = mode_rot;
.axis_type[5] = mode_none;
.axis_type[6] = mode_none;
END
IF SYSDATA(JTEXIST,.temp_rno,7)<>FALSE THEN
IF SYSDATA(LINEAR,.temp_rno,7)==mode_rot THEN
.axis_type[7] = mode_rot;EXT1
ELSE
.axis_type[7] = mode_lin;EXT1
END
ELSE
.axis_type[7] = mode_none
END
IF SYSDATA(JTEXIST,.temp_rno,8)<>FALSE THEN
IF SYSDATA(LINEAR,.temp_rno,8)==mode_rot THEN
.axis_type[8] = mode_rot;EXT2
ELSE
.axis_type[8] = mode_lin;EXT2
END
ELSE
.axis_type[8] = mode_none
END
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6])
VALUE 5:
POINT .temp_rno: .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6],.axis_type[7])
VALUE 6,7,8:
POINT .temp_rno: .#axis_type = #PPOINT(.axis_type[1],.axis_type[2],.axis_type[3],.axis_type[4],.axis_type[5],.axis_type[6],.axis_type[7],.axis_type[8])
END
RETURN
.END
.PROGRAM get_vision_info(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.ret)
;-------------------------------- 
;機能：ビジョン設定テーブルから条件取得
;引数：ロボット番号、ビジョンID
;戻値：カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、成否
;-------------------------------- 
.ret = err_no_error
;実行中のロボット種別取得
;テーブル中から条件検索してあれば応答する
FOR .i = 1 TO data_vs_tbnum
IF data_vs_vid[.i]==.id THEN
.camno = data_vs_cam_num[.i]
.calno = data_vs_calc_nu[.i]
.camtype = data_vs_cam_typ[.i]
.holdtype = data_vs_hold_ty[.i]
.calpos = data_vs_calc_po[.i]
IF debug.prt.visio==TRUE THEN
PRINT "get_vision_info()->.rno=",.rno
PRINT "get_vision_info()->.id=",.id
PRINT "get_vision_info()->.camno=",.camno
PRINT "get_vision_info()->.calno=",.calno
PRINT "get_vision_info()->.camtype=",.camtype
PRINT "get_vision_info()->.holdtype=",.holdtype
PRINT "get_vision_info()->.calpos=",.calpos
END
RETURN
END
END
.ret = err_bad_visionn
.END
.PROGRAM get_vision_resu(.id,.type,.calpos,.x,.y,.rot,.ret)
;-------------------------------- 
;機能：ビジョン計測結果取得
;引数：ビジョンID、結果種類(1:マスター、0:非マスター)、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目、3:ビジョンなし装置補正ツール)
;戻値：X座標値、Y座標値、θ座標値、成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "get_vision_result()->.id=",.id,", .type=",.type,", .calpos=",.calpos
END
;
IF .calpos<>type_device3 THEN
IF .type==1 THEN
;マスター
NOEXIST_SET_L v_master[.id,1] = TRANS(0,0,0,0,0,0)
DECOMPOSE .buf[1] = v_master[.id,1]
.x = .buf[1]
.y = .buf[2]
.rot = .buf[4]
ELSE
;非マスター
NOEXIST_SET_L vwork[.id,1] = TRANS(0,0,0,0,0,0)
DECOMPOSE .buf[1] = vwork[.id,1]
.x = .buf[1]
.y = .buf[2]
.rot = .buf[4]
END
ELSE
; ビジョンなし装置補正・マスター登録時のツールを返す
NOEXIST_SET_L vless_tool[.id] = TRANS(0,0,0,0,0,0)
DECOMPOSE .buf[1] = vless_tool[.id]
.x = .buf[1]
.y = .buf[2]
.rot = .buf[4]
END
.END
.PROGRAM get_workno(.work_no,.ret)
;-------------------------------- 
;機能：作業グループ番号取得
;引数：作業グループ番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.work_no = 0
; 作業グループ設定確認(信号入力の場合)
IF data_wset_spec==0 THEN
CALL get_iotype(data_wset_set[1],.sigtype,.ret)
IF .ret<>err_no_error OR .sigtype==io_do OR data_wset_set[2]<1 OR 8<data_wset_set[2] THEN; 信号番号範囲外または出力信号または信号数が1〜8ではない場合はエラー
.ret = err_work_set
GOTO end
END
END
; 作業グループ番号取得
IF data_wset_spec==1 THEN
.work_no = data_wset_no; タブレット
ELSE
.work_no = BITS(data_wset_set[1],data_wset_set[2]); 信号入力
END
IF .work_no==0 THEN; 取得した作業グループ番号が「0」の場合はエラー
.ret = err_work_set
GOTO end
END
;取得した作業グループが最大作業グループ数を超えている場合はエラー
IF .work_no>data_cur_maxnum THEN
.ret = err_work_set
GOTO end
END
; 取得した作業グループ番号が第２階層で使用されていない場合はエラー
FOR .i = 1 TO data_l2num
IF data_l2workno[.i]==.work_no THEN
GOTO end
END
END
.ret = err_work_set
end:
RETURN
.END
.PROGRAM getcmd(.num,.ret)
;-------------------------------- 
;機能：コマンドデータ取得(動作プログラム実行用)
;引数：なし
;戻値：実数データ配列(最大20個)、実数データ数、文字列データ配列、文字列データ数、成否
;-------------------------------- 
.ret = err_no_error
CALL recv(.$str,.ret)
IF .ret==0 THEN
.num = 0
FOR .i = 0 TO max_prm
$prm[TASKNO,.i] = ""
END
;文字列取込み
CALL csv_to_str(.$str,.num,.ret)
IF .num>=max_prm THEN
;バッファ掃除のために無視する
.ret = err_cmd_prmnum
RETURN
ELSE
IF TASKNO==1006 THEN
UTIMER @com_check_timer = 0
END
END
END
.END
.PROGRAM getcurrentpos(.rno,.mode,.#pos,.ret)
;-------------------------------- 
;機能：現在値を指定モードで取得してDECOMPOSEした値を返す
;引数：モード(MODE_JT,MODE_XYZR1EXT1)
;戻値：DECOMPOSEした位置要素配列、成否
;-------------------------------- 
.ret = err_no_error
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
CASE .mode OF
VALUE mode_jt:
IF .rno==0 OR .rno==1 THEN
;両方のロボットを動かすときはMASTER側が基準
POINT .temp_rno: .#pos1 = #S_HERE(1)
ELSE
POINT .temp_rno: .#pos1 = #S_HERE(2)
END
DECOMPOSE .temp_rno: .pos[1] = .#pos1
VALUE mode_xyzr1ext1:
IF .rno==0 OR .rno==1 THEN
;両方のロボットを動かすときはMASTER側が基準
IF 0 THEN
;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
ZL3TRN 1: .pos[1]=#S_HERE(1),1
ELSE
;ツール変換値考慮
DECOMPOSE .temp_rno: .pos[1] = S_HERE(1)
END
;                POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
ELSE
IF 0 THEN
;ツール変換値無視;2015/9/3受領KTERMのASでZL3TRNが正常に動作しないことが判明したのでS_HERE(*)側を有効化
ZL3TRN 2: .pos[1]=#S_HERE(2),1
ELSE
;ツール変換値考慮
DECOMPOSE .temp_rno: .pos[1] = S_HERE(2)
END
;               POINT .pos=TRANS(.temp[1],.temp[2],.temp[3],.temp[4],.temp[5],.temp[6])
END
;            DECOMPOSE .pos[1]=.pos
ANY :
.ret = err_bad_mode
RETURN
END
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
VALUE 5:
POINT .temp_rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7])
VALUE 6:
POINT .temp_rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7],.pos[8])
VALUE 7:
POINT .temp_rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7],.pos[8],.pos[9])
VALUE 8:
POINT .temp_rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7],.pos[8],.pos[9],.pos[10])
ANY :
.ret = err_bad_axesno
RETURN
END
.END
.PROGRAM getmcrpos(.$res,.ret)
;-------------------------------- 
;機能：マクロPG用位置変数取得
;引数：第2階層番号、第3階層番号、呼び出し番号、位置変数番号
;戻値：位置名称、位置変数名、座標種類、ツール番号、位置情報1〜4、成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.rno = data_robottype[.l2num,.l3num]
.mcrposno = VAL($prm[TASKNO,4])
.$mcrpos = $REPLACE($data_mcrpos[.l2num,.l3num,.mcrposno],":",",")
IF .rno==robot_master THEN
.$decompose = "DECOMPOSE 1:mcrpos[1] = "+.$mcrpos
ELSE
.$decompose = "DECOMPOSE 2:mcrpos[1] = "+.$mcrpos
END
ZMONEXE .$decompose
FOR .i = 7 TO 8
NOEXIST_SET_R mcrpos[.i] = 0
IF SYSDATA(JTEXIST,.rno,.i)==FALSE THEN
mcrpos[.i] = 0
END
END
NOEXIST_SET_R mcrpos[9] = 0
NOEXIST_SET_R mcrpos[10] = 0
.$res = $data_mcrposname[.l2num,.l3num,.mcrposno]+","+$data_mcrpos[.l2num,.l3num,.mcrposno]+","+$ENCODE(/L,data_mcrpostype[.l2num,.l3num,.mcrposno])+","+$ENCODE(/L,data_mcrtoolno[.l2num,.l3num,.mcrposno])
.$res = .$res+","+$ENCODE(/L,mcrpos[1])+","+$ENCODE(/L,mcrpos[2])+","+$ENCODE(/L,mcrpos[3])+","+$ENCODE(/L,mcrpos[4])+","+$ENCODE(/L,mcrpos[7])+","+$ENCODE(/L,mcrpos[8])+","+$ENCODE(/L,mcrpos[9])+","+$ENCODE(/L,mcrpos[10])
.END
.PROGRAM getparam(.cmd,.$res,.ret)
;-------------------------------- 
;機能：変数取得コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：応答文字列、成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL($prm[TASKNO,1])
CASE .cmd OF
VALUE cmd_get_sp:
;This protcol will delete soon.
.$res = $ENCODE(/L,0)
VALUE cmd_get_pitch:
.$res = $ENCODE(/L,data_teachrot)+","+$ENCODE(/L,data_teachpitch)+","+$ENCODE(/L,data_exttype[robot_master])+","+$ENCODE(/L,data_exttype[robot_slave])
VALUE cmd_get_tnum:
.$res = $ENCODE(/L,tool_data_num[.rno])
VALUE cmd_get_tool:
.mode = VAL($prm[TASKNO,2]);モードは無効、後日削除
;重量、重心(XYZイナーシャXYZ)は未対応のため固定値応答
.weight[1] = SYSDATA(TOOL.WEIGHT,.rno)
.weight[2] = SYSDATA(TOOL.CENT,.rno,1)
.weight[3] = SYSDATA(TOOL.CENT,.rno,2)
.weight[4] = SYSDATA(TOOL.CENT,.rno,3)
.weight[5] = SYSDATA(TOOL.INER,.rno,1)
.weight[6] = SYSDATA(TOOL.INER,.rno,2)
.weight[7] = SYSDATA(TOOL.INER,.rno,3)
;変換値の入れ物にXLINK,X2LINK,Hand1-waferの順にデータ格納する
.$res = $ENCODE(/L,ZL3GET(LINKX,.rno))+","+$ENCODE(/L,ZL3GET(LINKX2,.rno))+","+$ENCODE(/L,ZL3GET(LINKH1,.rno))+","+$ENCODE(/L,.weight[1])+","+$ENCODE(/L,.weight[2])+","+$ENCODE(/L,.weight[3])
.$res = .$res+","+$ENCODE(/L,.weight[4])+","+$ENCODE(/L,.weight[5])+","+$ENCODE(/L,.weight[6])+","+$ENCODE(/L,.weight[7])
VALUE cmd_get_cord:
.$res = $ENCODE(/L,data_teachcoord)
VALUE cmd_get_pos:
.mode = VAL($prm[TASKNO,2])
;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
.$res = "err_bad_mode"
ELSE
DECOMPOSE .rno: .cpos[1] = .#cpos
FOR .i = 7 TO 8
IF SYSDATA(JTEXIST,.rno,.i)==FALSE THEN
.cpos[.i] = 9999
END
END
FOR .i = 9 TO 10
NOEXIST_SET_R .cpos[.i] = 9999
IF .cpos[.i]>99999 OR .cpos[.i]<0 THEN
.cpos[.i] = 99999
END
END
.$res = $ENCODE(/L,.cpos[1])+","+$ENCODE(/L,.cpos[2])+","+$ENCODE(/L,.cpos[3])+","+$ENCODE(/L,.cpos[4])+","+$ENCODE(/L,.cpos[7])+","+$ENCODE(/L,.cpos[8])+","+$ENCODE(/L,.cpos[9])+","+$ENCODE(/L,.cpos[10])
END
VALUE cmd_get_info:
IF g_last_error!=0 THEN
.err = 1
ELSE
IF SWITCH(ERROR ,1)==ON OR SWITCH(ERROR ,2)==ON THEN
IF SWITCH(ERROR ,1)==ON AND SWITCH(ERROR ,2)==ON THEN
g_last_error = 1020
ELSE
IF SWITCH(ERROR ,1)==ON THEN
g_last_error = 1021
ELSE
g_last_error = 1022
END
END
.err = 1
ELSE
.err = 0
END
END
CASE .rno OF
VALUE robot_all:
IF SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON THEN
;両方ONでON
.power_sw = 1
ELSE
.power_sw = 0
END
VALUE robot_master:
IF SWITCH(POWER ,1)==ON THEN
.power_sw = 1
ELSE
.power_sw = 0
END
VALUE robot_slave:
IF SWITCH(POWER ,2)==ON THEN
.power_sw = 1
ELSE
.power_sw = 0
END
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
IF data_execute==TRUE OR flg_master_move==TRUE OR flg_slave_move==TRUE THEN
.status = status_move
ELSE
CALL chk_exe_staus(.exe_status)
IF .exe_status<>err_no_error THEN
.status = status_hold
ELSE
.status = status_nomove
END
END
.direct_status = 0
IF robot_mode==mode_direct THEN
IF SWITCH(CS ,1)==ON AND SWITCH(CS ,2)==ON AND (robot_mode_flg<>FALSE) THEN
.direct_status = 1
END
END
.tablet_status = 0
IF robot_mode==mode_tablet THEN
IF SWITCH(CS ,1)==ON AND SWITCH(CS ,2)==ON AND (robot_mode_flg<>FALSE) THEN
.tablet_status = 1
END
END
IF SYSDATA(DSIG.EMG_STOP)<>0 THEN
.emg_sta = -SIG(SYSDATA(DSIG.EMG_STOP))
ELSE
.emg_sta = 0
END
.$res = $data_cur_l1name+$data_load_time+","+$ENCODE(/L,data_cur_l2disp)+","+$ENCODE(/L,data_cur_l3disp)+","+$ENCODE(/L,.status)+","+$ENCODE(/L,.power_sw)+","+$ENCODE(/L,.err)
.$res = .$res+","+$ENCODE(/L,.emg_sta)+","+$ENCODE(/L,.tablet_status)+","+$ENCODE(/L,.direct_status)+","+$ENCODE(/L,g_last_error)
IF .rno==robot_slave THEN
.$res = .$res+","+$ENCODE(/L,MSPEED2)+","+$ENCODE(/L,MSPEED2)
ELSE
;両方の場合はマスターを返す
.$res = .$res+","+$ENCODE(/L,MSPEED)+","+$ENCODE(/L,MSPEED)
END
;原点情報
.dsig_home[1] = SYSDATA(DSIG.HOME1,robot_master)
.dsig_home[2] = SYSDATA(DSIG.HOME2,robot_master)
.dsig_home[3] = SYSDATA(DSIG.HOME1,robot_slave)
.dsig_home[4] = SYSDATA(DSIG.HOME2,robot_slave)
FOR .i = 1 TO 4
IF .dsig_home[.i]<>0 THEN
.home_sta[.i] = SIG(.dsig_home[.i])
ELSE
.home_sta[.i] = 0
END
END
IF .home_sta[1]==ON THEN
.r1gen = 1
ELSE
IF .home_sta[2]==ON THEN
.r1gen = 2
ELSE
.r1gen = 0
END
END
IF .home_sta[3]==ON THEN
.r2gen = 1
ELSE
IF .home_sta[4]==ON THEN
.r2gen = 2
ELSE
.r2gen = 0
END
END
.$res = .$res+","+$ENCODE(/L,.r1gen)+","+$ENCODE(/L,.r2gen)
;ロボット状態遷移情報
IF g_last_error<>0 THEN
.robot_status = sta_error
ELSE
.robot_status = robot_status_ou
END
IF debug_status<>-1 THEN
.robot_status = debug_status
END
;AUTO/MANUAL情報
IF SIG(extin_repeat_tg) AND SIG(-extin_teach_tgl) THEN
.tglsw = 1
ELSE
IF SIG(-extin_repeat_tg) AND SIG(extin_teach_tgl) THEN
.tglsw = 0
ELSE
.tglsw = 2
END
END
;コンベア起動/停止状態
.cvsta[1] = 9999
.cvsta[2] = 9999
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
FOR .cvno = 1 TO 2
FOR .arm = 1 TO 2
CALL cvaxis_check(.arm,cv_coopjt[.arm,.cvno],.ret)
IF .ret==0 THEN
.cvsta[.cvno] = SYSDATA(CVSWITCH,.arm,cv_coopjt[.arm,.cvno])
ELSE
.ret = 0
END
END
END
END
.$res = .$res+","+$ENCODE(/L,.robot_status)+","+$ENCODE(/L,.tglsw)
;現在作業グループ番号
.$res = .$res+","+$ENCODE(/L,data_cur_workno)+","+$ENCODE(/L,.cvsta[1])+","+$ENCODE(/L,.cvsta[2])
VALUE cmd_get_l1info:
.$res = $data_cur_l1name+","+$ENCODE(/L,data_l2num)+","+$data_load_time
VALUE cmd_get_l2info:
NOEXIST_SET_R data_l2workno[VAL($prm[TASKNO,2])] = 0
.$res = $data_l2name[VAL($prm[TASKNO,2])]+","+$ENCODE(/L,data_l3num[VAL($prm[TASKNO,2])])+","+$ENCODE(/L,data_l2exetblnu[VAL($prm[TASKNO,2])])+","+$ENCODE(/L,data_l2workno[VAL($prm[TASKNO,2])])
VALUE cmd_get_l3info:
IF flg_noset_name<>TRUE THEN
.$res = $data_l3name[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])]
ELSE
.$res = ""
END
VALUE cmd_get_io:
IF SIG(VAL($prm[TASKNO,2])) THEN
.$res = "1"
ELSE
.$res = "0"
END
VALUE cmd_get_home:
.homeno = VAL($prm[TASKNO,2])
IF .rno!=1 && .rno!=2 THEN
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
IF .homeno!=1 && .homeno!=2 THEN
.ret = err_bad_homeno
.$res = "err_bad_homeno"
RETURN
END
POINT .rno: .#home = #HOME(.homeno)
DECOMPOSE .rno: .buf[1] = .#home
IF SYSDATA(JTEXIST,.rno,7)==FALSE THEN
.buf[7] = 9999
END
IF SYSDATA(JTEXIST,.rno,8)==FALSE THEN
.buf[8] = 9999
END
.buf[9] = SYSDATA(HOME.ACU,.rno,.homeno)
FOR .i = 1 TO 8
IF SYSDATA(JTEXIST,.rno,.i)<>FALSE THEN
.buf[.i+9] = SYSDATA(HOME_CHK,.rno,.i)
ELSE
.buf[.i+9] = 0
END
END
.$res = $ENCODE(/L,.buf[1])+","+$ENCODE(/L,.buf[2])+","+$ENCODE(/L,.buf[3])+","+$ENCODE(/L,.buf[4])+","+$ENCODE(/L,.buf[7])+","+$ENCODE(/L,.buf[9])+","+$ENCODE(/L,.buf[8])
.$res = .$res+","+$ENCODE(/L,.buf[10])+","+$ENCODE(/L,.buf[11])+","+$ENCODE(/L,.buf[12])+","+$ENCODE(/L,.buf[13])+","+$ENCODE(/L,.buf[16])+","+$ENCODE(/L,.buf[17])
VALUE cmd_get_signame:
IF VAL($prm[TASKNO,2])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $data_io_num[VAL($prm[TASKNO,2])]+","+$data_io_name[VAL($prm[TASKNO,2])]
VALUE cmd_get_signum:
IF VAL($prm[TASKNO,2])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(/L,data_io_tablenu)
VALUE cmd_get_monsp:
CASE .rno OF
VALUE robot_all,robot_master:
;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
.$res = $ENCODE(/L,MSPEED)
VALUE robot_slave:
.$res = $ENCODE(/L,MSPEED2)
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
VALUE cmd_get_l2exetb:
IF VAL($prm[TASKNO,3])<0 THEN
.ret = err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
.$res = $ENCODE(/L,data_l2tbl_sign[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])])+","+$ENCODE(/L,data_l2tbl_stat[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])])
VALUE cmd_get_infoex:
IF .rno!=1 && .rno!=2 THEN
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
;現在位置
.mode = VAL($prm[TASKNO,2])
;ツール変換値を演算で求めることも可能だが最後のティーチで使用した変換値を応答できれば要件を満たしていると判断してツール変換値を切替えながらの取得には未対応とする
CALL getcurrentpos(.rno,.mode,.#cpos,.ret)
IF .ret<>err_no_error THEN
.$res = "err_bad_mode"
RETURN
ELSE
DECOMPOSE .rno: .cpos[1] = .#cpos
FOR .i = 7 TO 8
IF SYSDATA(JTEXIST,.rno,.i)==FALSE THEN
.cpos[.i] = 9999
END
END
FOR .i = 9 TO 10
NOEXIST_SET_R .cpos[.i] = 9999
IF .cpos[.i]>99999 OR .cpos[.i]<0 THEN
.cpos[.i] = 99999
END
END
.$res = $ENCODE(/L,.cpos[1])+","+$ENCODE(/L,.cpos[2])+","+$ENCODE(/L,.cpos[3])+","+$ENCODE(/L,.cpos[4])+","+$ENCODE(/L,.cpos[7])+","
END
CASE .rno OF
VALUE robot_all,robot_master:
;タブレット側に併せて仕様変更、2台指定時はMASTER側を応答する
.$res = .$res+$ENCODE(/L,MSPEED)
VALUE robot_slave:
.$res = .$res+$ENCODE(/L,MSPEED2)
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
;アーム動作速度、アーム動作ピッチ(回転)、アーム動作ピッチ(直動)
.$res = .$res+","+$ENCODE(/L,data_teachrot)+","+$ENCODE(/L,data_teachpitch)+","
;IO取得
.signo = VAL($prm[TASKNO,4])
CALL get_iotype(.signo,.sigtype,.ret)
IF .ret<>err_no_error THEN
.$res = "err_bad_signo"
RETURN
END
IF SIG(.signo) THEN
.$res = .$res+"1,"
ELSE
.$res = .$res+"0,"
END
;ハンド状態取得
.solno = VAL($prm[TASKNO,3])
.ionum = .solno*2-1
FOR .i = 0 TO 1
CALL get_iotype(data_hand_io[.rno,.ionum+.i],.sigtype,.ret)
IF .ret<>err_no_error OR .sigtype<>io_do THEN
.$res = "err_bad_signo"
RETURN
END
END
IF data_hand_iotyp[.rno,.solno]==hand_single THEN
IF SIG(data_hand_io[.rno,.ionum])==ON THEN
data_hand_sta[.rno,.solno] = hand_close
ELSE
data_hand_sta[.rno,.solno] = hand_open
END
ELSE
IF SIG(data_hand_io[.rno,.ionum])==ON AND SIG(data_hand_io[.rno,.ionum+1])==OFF THEN
data_hand_sta[.rno,.solno] = hand_close
END
IF SIG(data_hand_io[.rno,.ionum])==OFF AND SIG(data_hand_io[.rno,.ionum+1])==ON THEN
data_hand_sta[.rno,.solno] = hand_open
END
END
.$res = .$res+$ENCODE(/L,data_hand_sta[.rno,.solno])+","
.$res = .$res+$ENCODE(/L,.cpos[8])+","+$ENCODE(/L,.cpos[9])+","+$ENCODE(/L,.cpos[10])
VALUE cmd_get_hand:
.solno = VAL($prm[TASKNO,2])
.ionum = .solno*2-1 ;ハンドSOL信号番号
FOR .i = 0 TO 1
CALL get_iotype(data_hand_io[.rno,.ionum+.i],.sigtype,.ret)
IF .ret<>err_no_error OR .sigtype<>io_do THEN
.$res = "err_bad_signo"
RETURN
END
END
FOR .rno = 1 TO 2
IF data_hand_iotyp[.rno,.solno]==hand_single THEN
IF SIG(data_hand_io[.rno,.ionum])==ON THEN
data_hand_sta[.rno,.solno] = hand_close
ELSE
data_hand_sta[.rno,.solno] = hand_open
END
ELSE
IF SIG(data_hand_io[.rno,.ionum])==ON AND SIG(data_hand_io[.rno,.ionum+1])==OFF THEN
data_hand_sta[.rno,.solno] = hand_close
END
IF SIG(data_hand_io[.rno,.ionum])==OFF AND SIG(data_hand_io[.rno,.ionum+1])==ON THEN
data_hand_sta[.rno,.solno] = hand_open
END
END
END
.$res = $ENCODE(/L,data_hand_sta[robot_master,.solno])+","+$ENCODE(/L,data_hand_sta[robot_slave,.solno])
VALUE cmd_get_handio:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
VALUE robot_master,robot_slave:
.$res = $ENCODE(/L,data_hand_iotyp[.rno,1])+","+$ENCODE(/L,data_hand_iotyp[.rno,2])+","+$ENCODE(/L,data_hand_iotyp[.rno,3])+","+$ENCODE(/L,data_hand_iotyp[.rno,4])
FOR .i = 1 TO 8
.$res = .$res+","+$ENCODE(/L,data_hand_io[.rno,.i])
END
ANY :
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
VALUE cmd_get_vtb:
.vtblno = VAL($prm[TASKNO,2])
IF .vtblno<=0 THEN
;タブレット側が番号0で呼出している暫定対策20150804
;.ret=err_bad_tableno
.$res = "err_bad_tableno"
RETURN
END
NOEXIST_SET_R data_vs_robot[.vtblno] = 0
NOEXIST_SET_R data_vs_cam_num[.vtblno] = 0
NOEXIST_SET_R data_vs_calc_nu[.vtblno] = 0
NOEXIST_SET_R data_vs_cam_typ[.vtblno] = 0
NOEXIST_SET_R data_vs_hold_ty[.vtblno] = 0
NOEXIST_SET_R data_vs_calc_po[.vtblno] = 0
NOEXIST_SET_S $data_vs_name[.vtblno] = "NO SETTING"
CALL convert_vid(mode_del,data_vs_calc_po[.vtblno],data_vs_vid[.vtblno],.vision_id)
.$res = $ENCODE(/L,.vision_id)+","+$ENCODE(/L,data_vs_cam_num[.vtblno])+","+$ENCODE(/L,data_vs_calc_nu[.vtblno])
.$res = .$res+","+$ENCODE(/L,data_vs_cam_typ[.vtblno])+","+$ENCODE(/L,data_vs_hold_ty[.vtblno])+","+$ENCODE(/L,data_vs_calc_po[.vtblno])
.$res = .$res+","+$data_vs_name[.vtblno]+","+$ENCODE(/L,data_vs_robot[.vtblno])
VALUE cmd_get_vtbnum:
.$res = $ENCODE(/L,data_vs_tbnum)
VALUE cmd_get_vresult:
;ビジョンID変換
CALL convert_vid(mode_add,VAL($prm[TASKNO,4]),VAL($prm[TASKNO,2]),.vision_id)
CALL get_vision_resu(.vision_id,VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),.x,.y,.rot,.ret)
.$res = $ENCODE(/L,.x)+","+$ENCODE(/L,.y)+","+$ENCODE(/L,.rot)
VALUE cmd_get_robotmo:
.$res = $ENCODE(/L,robot_mode)+","+$ENCODE(/L,robot_mode_flg)
VALUE cmd_get_lowspar:
IF VAL($prm[TASKNO,2])<=0 OR VAL($prm[TASKNO,2])>=5 THEN
.ret = err_bad_areano
RETURN
END
.slowrate = SYSDATA(SLOWAREA.RATE,VAL($prm[TASKNO,2]))
IF .slowrate>100000 THEN
.slowrate = .slowrate-100000
.sptype = 1
ELSE
.sptype = 0
END
.$res = $ENCODE(/L,SYSDATA(SLOWAREA.MIN_X,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,SYSDATA(SLOWAREA.MIN_Y,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,SYSDATA(SLOWAREA.MAX_X,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,SYSDATA(SLOWAREA.MAX_Y,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,.slowrate)
.$res = .$res+","+$ENCODE(/L,SYSDATA(SLOWAREA.MIN_Z,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,SYSDATA(SLOWAREA.MAX_Z,VAL($prm[TASKNO,2])))+","+$ENCODE(/L,.sptype)
VALUE cmd_get_lowspse:
.areaslow_mode = SWITCH(ZAREASLOWMODE)
.$res = $ENCODE(/L,.areaslow_mode)
VALUE cmd_get_gravity:
NOEXIST_SET_R grav_cur_val[0] = -25
NOEXIST_SET_R grav_cur_val[1] = -25
.$res = $ENCODE(/L,-flg_gravityadj_)+","+$ENCODE(/L,grav_cur_val[0])+","+$ENCODE(/L,grav_cur_val[1])
VALUE cmd_get_colchkm:
.$res = $ENCODE(/L,ABS(flg_enable_colc))
VALUE cmd_get_slowlim:
.$res = $ENCODE(/L,slowlimit_ena)+","+$ENCODE(/L,slowlimit_speed)+","+$ENCODE(/L,slowlimit_time)
VALUE cmd_get_version:
FOR .i = 1 TO 2
.$servo_ver[.i] = ""
FOR .j = 1 TO 4
.$servo_ver[.i] = .$servo_ver[.i]+$SYSDATA(YM.ID,.i,.j)+"  "
END
.$servo_ver[.i] = $LEFT(.$servo_ver[.i],LEN(.$servo_ver[.i])-2)
END
.$res = $STR_ID(2)+","+.$servo_ver[1]+","+.$servo_ver[2]+","+$LEFT($appli_ver_tbl,8)
VALUE cmd_get_intfpar:
IF .rno<1 OR .rno>2 THEN
.r_no = 1
ELSE
.r_no = .rno
END
.intf_param[1] = SYSDATA(INTF.MIN_X,.r_no)
.intf_param[2] = SYSDATA(INTF.MIN_Y,.r_no)
.intf_param[3] = SYSDATA(INTF.MAX_X,.r_no)
.intf_param[4] = SYSDATA(INTF.MAX_Y,.r_no)
.intf_param[5] = SYSDATA(INTF.XLINK_1,.r_no)
.intf_param[6] = SYSDATA(INTF.XLINK_2,.r_no)
.$res = $ENCODE(/L,.intf_param[1])
FOR .i = 2 TO 6
.$res = .$res+","+$ENCODE(/L,.intf_param[.i])
END
VALUE cmd_get_sa:
IF OFF THEN
;            FOR .arm=1 TO 2
;                .sa_base_dir[.arm] = SYSDATA(SA.BASE_DIRECTION, .arm )
;                .sa_tool_dir[.arm] = SYSDATA(SA.TOOL_DIRECTION, .arm)
;                .sa_over_jt[.arm] = SYSDATA(SA.OVR_RNG_JT, .arm)
;                .sa_over_dir[.arm] = SYSDATA(SA.OVR_RNG_DIR, .arm)
;            END
;            NOEXIST_SET_R .sa_base_dir[1] = -1
ELSE
.sa_base_dir[1] = -1
END
IF .sa_base_dir[1]==-1 THEN
.$res = $sa_param
RETURN
END
IF 0<.sa_base_dir[robot_master] OR .sa_base_dir[robot_slave] THEN
.sa_direct = 1
ELSE
IF 0<.sa_tool_dir[robot_master] OR .sa_tool_dir[robot_slave] THEN
.sa_direct = 2
ELSE
.sa_direct = 0
END
END
.$res = $ENCODE(/I1,.sa_direct)
FOR .arm = 1 TO 2
FOR .p_no = 1 TO 4
CASE .sa_direct OF
VALUE sa.jt:
IF OFF THEN
;                            .sa_gain[.arm,.p_no] = SYSDATA(SA.GAIN, .arm,.p_no)
END
IF .sa_gain[.arm,.p_no]<100 THEN
.sa_param[.arm,.p_no] = 1
ELSE
.sa_param[.arm,.p_no] = 0
END
VALUE sa.base:
.check = .sa_base_dir[.arm] BAND 2^(.p_no-1)
IF .check==OFF THEN
.sa_param[.arm,.p_no] = 0
ELSE
.sa_param[.arm,.p_no] = 1
END
VALUE sa.tool:
.check = .sa_tool_dir[.arm] BAND 2^(.p_no-1)
IF .check==OFF THEN
.sa_param[.arm,.p_no] = 0
ELSE
.sa_param[.arm,.p_no] = 1
END
END
IF .sa_over_jt[.arm]==.p_no THEN
.sa_param[.arm,.p_no] = 2
END
IF .sa_over_dir[.arm]==.p_no OR (.p_no==4 AND .sa_over_jt[.arm]==6) THEN
.sa_param[.arm,.p_no] = 3
END
.$res = .$res+","+$ENCODE(/I1,.sa_param[.arm,.p_no])
END
END
VALUE cmd_get_iostat:
.ox_sig_no = VAL($prm[TASKNO,2]); 先頭信号番号（出力）
.wx_sig_no = VAL($prm[TASKNO,3]); 先頭信号番号（入力）
.ix_sig_no = VAL($prm[TASKNO,4]); 先頭信号番号（内部）
CALL get_io_status(.ox_sig_no,16,.ox_sig_stat)
CALL get_io_status(.wx_sig_no,16,.wx_sig_stat)
CALL get_io_status(.ix_sig_no,16,.ix_sig_stat)
.$res = $ENCODE(/L,.ox_sig_no)+","+$ENCODE(/L,.ox_sig_stat)+","+$ENCODE(/L,.wx_sig_no)+","+$ENCODE(/L,.wx_sig_stat)+","+$ENCODE(/L,.ix_sig_no)+","+$ENCODE(/L,.ix_sig_stat)
VALUE cmd_get_count:
.count_no[1] = VAL($prm[TASKNO,2]); 先頭カウンタ番号１
.count_no[2] = VAL($prm[TASKNO,3]); 先頭カウンタ番号２
FOR .i = 1 TO 2
CALL get_cnt_status(.count_no[.i],5)
IF .i==1 THEN
.$res = $ENCODE(/L,.count_no[.i])
ELSE
.$res = .$res+","+$ENCODE(/L,.count_no[.i])
END
FOR .j = 1 TO 5
.$res = .$res+","+$ENCODE(/L,disp_cntnum[.j])
END
END
VALUE cmd_get_genpara:
.pno = VAL($prm[TASKNO,2])
.mno = VAL($prm[TASKNO,3])
CASE .pno OF
VALUE 1:; 安全距離
IF .rno<>1 AND .rno<>2 THEN; ロボット番号確認[1-2]
.ret = err_bad_rno
.$res = "err_bad_rno"
RETURN
END
IF .mno==1 THEN; 現在値取得
DECOMPOSE .rob[1] = S_HERE(.rno)
POINT .rob_pos = TRANS(.rob[1],.rob[2],.rob[3],.rob[4],.rob[5],.rob[6])
POINT .null_pos = TRANS(0,0,.rob[3],0,0,0)
.dist = DISTANCE(.rob_pos,.null_pos)
.$res = $ENCODE(/L,.dist)
ELSE; 設定値取得
.$res = $ENCODE(/L,chk_gohome[.rno])
END
VALUE 2:; ツール間距離
IF .mno==1 THEN; 現在値取得
DECOMPOSE .rob1[1] = S_HERE(1)
DECOMPOSE .rob2[1] = S_HERE(2)
POINT .rob1_pos = TRANS(.rob1[1],.rob1[2],.rob1[3],.rob1[4],.rob1[5],.rob1[6])
POINT .rob2_pos = TRANS(.rob2[1],.rob2[2],.rob1[3],.rob2[4],.rob2[5],.rob2[6])
.dist = DISTANCE(.rob1_pos,.rob2_pos)
.$res = $ENCODE(/L,.dist)
ELSE; 設定値取得
.$res = $ENCODE(/L,chk_dist_here)
END
ANY :
.ret = err_bad_ptype
.$res = "err_bad_ptype"
END
VALUE cmd_get_colr:
;衝突検知感度取得
DECMPCOLR .rno: .colr[1]
DECMPCOLRJ .rno: .colrj[1]
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
.colr[7] = 0
.colrj[7] = 0
.colr[8] = 0
.colrj[8] = 0
VALUE 5:
.colr[8] = 0
.colrj[8] = 0
END
.$res = $ENCODE(/L,.colr[1])+","+$ENCODE(/L,.colr[2])+","+$ENCODE(/L,.colr[3])+","+$ENCODE(/L,.colr[4])+","+$ENCODE(/L,.colr[7])+","+$ENCODE(/L,.colr[8])
.$res = .$res+","+$ENCODE(/L,.colrj[1])+","+$ENCODE(/L,.colrj[2])+","+$ENCODE(/L,.colrj[3])+","+$ENCODE(/L,.colrj[4])+","+$ENCODE(/L,.colrj[7])+","+$ENCODE(/L,.colrj[8])
VALUE cmd_get_wset:
;作業グルーピング設定取得
IF SWITCH(ZUPSPEED)==FALSE THEN
.zupsp = 0
ELSE
.zupsp = 1
END
.$res = $ENCODE(/L,data_wset_ena)+","+$ENCODE(/L,data_cur_maxnum)+","+$ENCODE(/L,.zupsp)
VALUE cmd_get_wspec:
;作業グループ指定方法取得
.$res = $ENCODE(/L,data_wset_spec)+","+$ENCODE(/L,data_wset_set[1])+","+$ENCODE(/L,data_wset_set[2])
VALUE cmd_get_wno:
;作業グループ番号取得
.$res = $ENCODE(/L,data_wset_no)
VALUE cmd_get_winfo:
;作業グループ名称取得
.wno = VAL($prm[TASKNO,2])
IF .wno<1 OR max_worknum<.wno THEN
.ret = err_bad_ptype
.$res = "err_bad_ptype"
ELSE
NOEXIST_SET_S $data_workname[.wno] = ""
.$res = $data_workname[.wno]
IF .$res=="" THEN
.$res = "***"
END
END
VALUE cmd_get_zoption:
;オプション機能設定取得
.ox_num = SYSDATA(ZSIGSPEC.DO); 出力信号
.wx_num = SYSDATA(ZSIGSPEC.DI); 入力信号
.ix_num = SYSDATA(ZSIGSPEC.INT); 内部信号
.fb_io = ZOPTION(13,2);汎用フィールドバス設定I/O設定取得
.coop_ex1 = SWITCH(COOP.DRIVE.EX1)
.coop_ex2 = SWITCH(COOP.DRIVE.EX2)
IF .fb_io<>OFF THEN;設定ONの時
.ox_num = .ox_num+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
.wx_num = .wx_num+SYSDATA(ZSIGSPEC.MAS)+SYSDATA(ZSIGSPEC.SLA)
END
.zop_cbs = ZOPTION(16,7)
NOEXIST_SET_R z_vselect = 0; 他社ビジョン選択(初期値：K-VFinder)
FOR .arm = 1 TO 2
FOR .jt = 7 TO 8
IF SYSDATA(JTEXIST,.arm,.jt)==FALSE THEN
.linear[.arm,.jt] = 0
ELSE
.linear[.arm,.jt] = SYSDATA(LINEAR,.arm,.jt)+1
END
END
END
.cvnum[1] = 0 ;下アームコンベア軸割付(0=無し,1=CV1,2=CV2,3=CV1&CV2)
.cvnum[2] = 0 ;上アームコンベア軸割付(0=無し,1=CV1,2=CV2,3=CV1&CV2)
.set_cvno[1] = 0 ;下アームコンベア番号割付(0=無し,1=コンベア1,2=コンベア2,3=コンベア1&コンベア2)
.set_cvno[2] = 0 ;上アームコンベア番号割付(0=無し,1=コンベア1,2=コンベア2,3=コンベア1&コンベア2)
.cvcam = 0 ;コンベアビジョン設定(0=無し,1=コンベア1,2=コンベア2)
CALL chk_cv_setting(.ret)
IF .ret==err_no_error THEN
FOR .arm = 1 TO 2
CALL cvaxis_check(.arm,9,.ret)
IF .ret==err_no_error THEN
.cvnum[.arm] = .cvnum[.arm]+1
ELSE
.ret = err_no_error
END
CALL cvaxis_check(.arm,10,.ret)
IF .ret==err_no_error THEN
.cvnum[.arm] = .cvnum[.arm]+2
ELSE
.ret = err_no_error
END
FOR .cvno = 1 TO 2
IF cv_coopjt[.arm,.cvno]<>0 THEN
.set_cvno[.arm] = .set_cvno[.arm]+.cvno
END
END
END
FOR .cvno = 1 TO 2
IF cv_vision[.cvno]==1 THEN
.cvcam = .cvno ;固定カメラ設定のコンベア番号を代入
END
END
ELSE
.ret = err_no_error
END
FOR .arm = 1 TO 2
.rbmgfno[.arm] = SYSDATA(ZROB.MGFNO,.arm)
END
.$res = $ENCODE(/L,.ox_num)+","+$ENCODE(/L,.wx_num)+","+$ENCODE(/L,.ix_num)+","+$ENCODE(/L,.zop_cbs)+","
.$res = .$res+$ENCODE(/L,z_vselect); 他社ビジョン
.$res = .$res+","+$ENCODE(/L,.linear[1,7])+","+$ENCODE(/L,.linear[1,8])+","+$ENCODE(/L,.linear[2,7])+","+$ENCODE(/L,.linear[2,8])+","+$ENCODE(/L,.coop_ex1)+","+$ENCODE(/L,.coop_ex2)+","+$ENCODE(/L,.cvnum[1])+","+$ENCODE(/L,.cvnum[2])
.$res = .$res+","+$ENCODE(/L,.cvcam)+","+$ENCODE(/L,.set_cvno[1])+","+$ENCODE(/L,.set_cvno[2])+","+$ENCODE(/L,.rbmgfno[1])+","+$ENCODE(/L,.rbmgfno[2])
VALUE cmd_get_armslow:
;アーム間低速動作機能取得
.armslow_mode = SWITCH(L3ARMSLOWMODE)
.armslow_deg = SYSDATA(L3ARM_SLOW.DEG)
.armslow_sp = SYSDATA(L3ARM_SLOW.RATE)
IF .armslow_sp>100000 THEN
.armslow_sp = .armslow_sp-100000
.armslow_sptype = 1
ELSE
.armslow_sptype = 0
END
.$res = $ENCODE(/L,.armslow_mode)+","+$ENCODE(/L,.armslow_deg)+","+$ENCODE(/L,.armslow_sp)+","+$ENCODE(/L,.armslow_sptype)
VALUE cmd_get_linkslo:
;リンク間低速動作機能取得
.linkslow[1] = SWITCH(L3LINKSLOWMODE)
.linkslow[2] = SYSDATA(L3LINK_SLOW.DEG,.rno,0)
.linkslow[3] = SYSDATA(L3LINK_SLOW.DEG,.rno,1)
.linkslow[4] = SYSDATA(L3LINK_SLOW.RATE,.rno,0)
.linkslow[5] = SYSDATA(L3LINK_SLOW.RATE,.rno,1)
FOR .i = 4 TO 5
IF .linkslow[.i]>100000 THEN
.linkslow[.i] = .linkslow[.i]-100000
.linkslow[.i+2] = 1
ELSE
.linkslow[.i+2] = 0
END
END
.$res = $ENCODE(/L,.linkslow[1])
FOR .i = 2 TO 7
.$res = .$res+","+$ENCODE(/L,.linkslow[.i])
END
VALUE cmd_get_l3lsp:
;直線動作速度取得
NOEXIST_SET_R data_l3speed = 0
.$res = $ENCODE(/L,data_l3speed)
VALUE cmd_get_loadsta:
.sta = VAL($prm[TASKNO,2])
.mem = SYSDATA(MEM.FREE)
CASE .sta OF
VALUE 0:
flg_load_now = TRUE
flg_mem_chk = FALSE
DELETE/S/D $data_l3name
DELETE/S/D $data_l2name
DELETE/S/D $DATA_CALLNAME
DELETE/S/D $DATA_MCRPOSNAME
DELETE/S/D $DATA_MCRPOS
DELETE/R/D data_accel
DELETE/R/D data_accuracy
DELETE/R/D data_abssp_mode
DELETE/R/D DATA_COLCHK
DELETE/R/D DATA_CNTID
DELETE/R/D DATA_CNTTYPE
DELETE/R/D DATA_CNTVAL
DELETE/R/D DATA_CALLNO
DELETE/R/D DATA_CALLPOSNUM
DELETE/R/D data_decel
DELETE/R/D data_hand_ctl
DELETE/R/D data_hand_sol
DELETE/R/D DATA_KEEP_WAIT
DELETE/R/D data_l3type
DELETE/R/D DATA_L3IFGOTO_I ;DATA_L3IFGOTO_ID (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_L3IFGOTO_L ;DATA_L3IFGOTO_LABEL (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_L3LABEL
DELETE/R/D data_postype
DELETE/R/D data_pos1
DELETE/R/D data_pos2
DELETE/R/D data_pos3
DELETE/R/D data_pos4
DELETE/R/D data_pos5
DELETE/R/D data_pos6
DELETE/R/D data_pos7
DELETE/R/D data_pos8
DELETE/R/D data_pos9
DELETE/R/D data_move_jt
DELETE/R/D data_robottype
DELETE/R/D data_repspeed
DELETE/R/D DATA_RESTART_FL ;DATA_RESTART_FLG (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_SIGNUM
DELETE/R/D DATA_SIGSTATUS
DELETE/R/D data_mode
DELETE/R/D data_tool
DELETE/R/D data_vision_id1
DELETE/R/D data_vision_id2
DELETE/R/D data_vision_id3
DELETE/R/D data_vision_sta ;DATA_VISION_STATUS (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_VISION_CAL ;DATA_VISION_CALPOS (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_VISION_ID
DELETE/R/D DATA_VISION_CNT
DELETE/R/D data_wait_befor ;DATA_WAIT_BEFORE (15文字以上のため省略文字列を記載)
DELETE/R/D data_wait_after
DELETE/R/D DATA_WAIT_TIMEO ;DATA_WAIT_TIMEOUT (15文字以上のため省略文字列を記載)
DELETE/R/D DATA_WAIT_TOCON
DELETE/R/D DATA_IFMODE
DELETE/R/D DATA_IFTYPE
DELETE/R/D DATA_IFITEM
DELETE/R/D DATA_IFCNT
DELETE/R/D DATA_IFCNT2
DELETE/R/D DATA_IFCNT3
DELETE/R/D DATA_L2RESETNUM
DELETE/R/D DATA_CALLNO ;R11以降使用されない変数
DELETE/R/D DATA_CALLPOSNUM
DELETE/R/D DATA_MCRPOSTYPE
DELETE/R/D DATA_MCRTOOLNO
DELETE/R/D data_cv_no
DELETE/R/D data_cv_work
DELETE/R/D DATA_WAIT_CVNO
DELETE/R/D DATA_WAIT_CVWO
DELETE/R/D DATA_WAIT_CVUL
DELETE/R/D DATA_WAIT_CVLL
DELETE/R/D DATA_WAIT_CVTO
DELETE/R/D DATA_CVCOOP_NO
DELETE/R/D DATA_CVCOOP_WO
DELETE/R/D DATA_CVCOOP_POS
DELETE/R/D DATA_CVCOOP_WO2
DELETE/R/D DATA_REFPOS
VALUE 1:
flg_load_now = FALSE
VALUE 2:
IF .mem<=8 THEN
flg_mem_chk = TRUE
ELSE
flg_mem_chk = FALSE
END
END
.$res = $ENCODE(/L,.mem)
VALUE cmd_get_genopt:
IF zsw_mode_home<-2 OR 0<zsw_mode_home THEN
.ret = err_bat_value
.$res = "err_bat_value"
RETURN
END
CASE zsw_mode_home OF
VALUE -1:
.buf[1] = 0 ;両アーム連動原点復帰
VALUE 0:
.buf[1] = 1 ;両アーム直接原点復帰
VALUE -2:
.buf[1] = 2 ;マクロPG原点復帰
END
.$res = $ENCODE(/L,.buf[1])
VALUE cmd_get_sagain:
FOR .arm = 1 TO 2
FOR .jt = 5 TO 6
.gain[.arm,.jt] = data_sa_gain[.arm,.jt]
END
END
.$res = $ENCODE(/L,.gain[1,5])+","+$ENCODE(/L,.gain[1,6])+","+$ENCODE(/L,.gain[2,5])+","+$ENCODE(/L,.gain[2,6])
VALUE cmd_get_cvprm:
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.$res = "err_cv_setting"
RETURN
END
.cvno = VAL($prm[TASKNO,1])
.cvjt[1] = cv_coopjt[1,.cvno]
.cvjt[2] = cv_coopjt[2,.cvno]
IF (.cvjt[1]<>0) AND (.cvjt[2]<>0) THEN
IF .cvjt[1]==.cvjt[2] THEN
FOR .i = 1 TO 2
CALL cvaxis_check(.i,.cvjt[.i],.ret)
IF .ret<>err_no_error THEN
.$res = "err_cv_setting"
RETURN
END
END
.cvio = SYSDATA(DSIG.CVRESET,-1,.cvjt[1])
.cvsp = SYSDATA(CVSPEED,1,.cvjt[1])
ELSE
.$res = "err_cv_setting"
RETURN
END
ELSE
IF .cvjt[1]<>0 THEN
CALL cvaxis_check(1,.cvjt[1],.ret)
IF .ret<>err_no_error THEN
.$res = "err_cv_setting"
RETURN
END
.cvio = SYSDATA(DSIG.CVRESET,1,.cvjt[1])
.cvsp = SYSDATA(CVSPEED,1,.cvjt[1])
ELSE
IF .cvjt[2]<>0 THEN
CALL cvaxis_check(2,.cvjt[2],.ret)
IF .ret<>err_no_error THEN
.$res = "err_cv_setting"
RETURN
END
.cvio = SYSDATA(DSIG.CVRESET,2,.cvjt[2])
.cvsp = SYSDATA(CVSPEED,2,.cvjt[2])
ELSE
.cvio = 0
.cvsp = 0
END
END
END
.$res = $ENCODE(/L,cv_coopjt[robot_master,.cvno])+","+$ENCODE(/L,cv_coopjt[robot_slave,.cvno])+","+$ENCODE(/L,.cvio)+","+$ENCODE(/L,cv_deg_o[.cvno])+","+$ENCODE(/L,cv_deg_a[.cvno])
.$res = .$res+","+$ENCODE(/L,.cvsp)+","+$ENCODE(/L,cv_ulim[.cvno])+","+$ENCODE(/L,cv_llim[.cvno])+","+$ENCODE(/L,cv_vision[.cvno])+","+$ENCODE(/L,cv_work_pitch[.cvno])
VALUE cmd_get_cvmon:
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
.$res = "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
RETURN
END
FOR .rno = 1 TO 2
.cvcoop_no = cur_cvcoop_no[.rno]
.cvcoop_wo = cur_cvcoop_wo[.rno]
.cvcoop_wono = cur_cvcoop_wono[.rno]
IF .cvcoop_no<>0 AND .cvcoop_wo<>0 AND .cvcoop_wono<>0 THEN
CALL cvaxis_check(.rno,cv_coopjt[.rno,.cvcoop_no],.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
.$res = "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
RETURN
END
.cv_coop_pos[.rno] = ((CVPOS2:.rno(.cvcoop_wono,cv_coopjt[.rno,.cvcoop_no]))+cv_work_off[.cvcoop_no,.cvcoop_wo])
.cvwno[.rno] = cv_wno[.cvcoop_no,.cvcoop_wo]
ELSE
.cv_coop_pos[.rno] = 0
.cvwno[.rno] = 0
END
END
.cvno = VAL($prm[TASKNO,1])
FOR .i = 1 TO 2
IF SIG(ix_cv_buff[.cvno,.i]) THEN
.cvrno = 0
FOR .rno = 1 TO 2
IF cv_coopjt[.rno,.cvno]<>0 THEN
.cvrno = .rno
END
END
IF .cvrno==0 THEN
.ret = err_no_error
.$res = "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
RETURN
END
CALL cvaxis_check(.cvrno,cv_coopjt[.cvrno,.cvno],.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
.$res = "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
RETURN
END
.cvworkno[.i] = cv_buff_work[.cvno,.i]
.cvbno[.i] = cv_bno[.cvno,.i]
.cv_buff_pos[.i] = ((CVPOS2:.cvrno(.cvworkno[.i],cv_coopjt[.cvrno,.cvno]))+cv_buff_off[.cvno,.i])
.ix_buff[.i] = SIG(ix_cv_area[.cvno,.i])
ELSE
.cvworkno[.i] = 0
.cvbno[.i] = 0
.cv_buff_pos[.i] = 0
.ix_buff[.i] = OFF
END
END
.$res = $ENCODE(/L,cur_cvcoop_no[1])+","+$ENCODE(/L,cur_cvcoop_no[2])+","+$ENCODE(/L,cur_cvcoop_wo[1])+","+$ENCODE(/L,cur_cvcoop_wo[2])+","+$ENCODE(/L,cur_cvcoop_wono[1])+","+$ENCODE(/L,cur_cvcoop_wono[2])+","+$ENCODE(/L,.cv_coop_pos[1])+","+$ENCODE(/L,.cv_coop_pos[2])
.$res = .$res+","+$ENCODE(/L,cv_buff_num[.cvno])+","+$ENCODE(/L,cv_ulim[.cvno])+","+$ENCODE(/L,cv_llim[.cvno])+","+$ENCODE(/L,.cvworkno[1])+","+$ENCODE(/L,.cvworkno[2])+","+$ENCODE(/L,.cv_buff_pos[1])+","+$ENCODE(/L,.cv_buff_pos[2])
.$res = .$res+","+$ENCODE(/L,.ix_buff[1])+","+$ENCODE(/L,.ix_buff[2])+","+$ENCODE(/L,.cvwno[1])+","+$ENCODE(/L,.cvwno[2])+","+$ENCODE(/L,.cvbno[1])+","+$ENCODE(/L,.cvbno[2])
VALUE cmd_get_cvvis:
.cvno = VAL($prm[TASKNO,1])
.l2num = VAL($prm[TASKNO,2])
NOEXIST_SET_R data_cv_vis[.l2num] = OFF
NOEXIST_SET_R data_cv_vid[.l2num] = 1
NOEXIST_SET_R data_cv_vrap[.l2num] = 10
NOEXIST_SET_R data_cv_voffset[.l2num] = 0
.$res = $ENCODE(/L,data_cv_vis[.l2num])+","+$ENCODE(/L,data_cv_vid[.l2num])+","+$ENCODE(/L,data_cv_vrap[.l2num])+","+$ENCODE(/L,data_cv_voffset[.l2num])
VALUE cmd_get_license:
.lic_no = VAL($prm[TASKNO,2])
CASE .lic_no OF
VALUE lic_spup:;速度制限解除
.lic_sta = SYSDATA(LIC.ZUP_SP)
VALUE lic_cv:;コンベア同期
.lic_sta = SYSDATA(LIC.CONV)
ANY :
.ret = err_bat_value
.$res = "err_bat_value"
RETURN
END
.$res = $ENCODE(/L,.lic_sta)
ANY :
.ret = err_cmd_type
.$res = "err_cmd_type"
END
.END
.PROGRAM getposdata(.l2num,.l3num,.mode,.type,.#pos,.ret)
;-------------------------------- 
;機能：1点分の位置情報の取得
;引数：第2階層番号、第3階層番号
;戻値：動作方法(.mode->0;JT、1:XYZR1EXT1)、教示点構成要素(.data実数配列)、補間方法(.type->0:LMOVE、1:JMOVE)、成否
;-------------------------------- 
.ret = err_no_error
.dtype = data_l3type[.l2num,.l3num]
IF (.dtype!=l3type_move) AND (.dtype!=l3type_shift) THEN
.ret = err_bad_l3type
RETURN
END
.rno = data_robottype[.l2num,.l3num]
.mode = data_mode[.l2num,.l3num]
.type = data_postype[.l2num,.l3num]
.move = data_move_jt[.l2num,.l3num]
NOEXIST_SET_R data_pos7[.l2num,.l3num] = 0
NOEXIST_SET_R data_pos8[.l2num,.l3num] = 0
.pos[1] = data_pos1[.l2num,.l3num]
.pos[2] = data_pos2[.l2num,.l3num]
.pos[3] = data_pos3[.l2num,.l3num]
.pos[4] = data_pos4[.l2num,.l3num]
.pos[5] = data_pos5[.l2num,.l3num]
.pos[6] = data_pos6[.l2num,.l3num]
.pos[7] = data_pos7[.l2num,.l3num]
.pos[8] = data_pos8[.l2num,.l3num]
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
IF .move<>0 THEN
.ret = err_bad_axesno
RETURN
END
POINT .rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6])
VALUE 5:
DECOMPOSE .rno: .bef_pos[1] = #dest_pos[.rno]
IF .bef_pos[1]>=9999 THEN;前回の移動位置が無い(9999)の場合は現在値を取得する
IF .mode==mode_jt THEN
DECOMPOSE .rno: .bef_pos[1] = #S_HERE(.rno)
ELSE
DECOMPOSE .rno: .bef_pos[1] = S_HERE(.rno)
END
END
CASE .move OF
VALUE 0:;基軸のみ
POINT .rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.bef_pos[7])
VALUE 1:;基軸+外部軸
POINT .rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7])
VALUE 2:;外部軸のみ
IF dest_mode[.rno]<>9999 THEN
;外部軸のみ移動の場合は教示タイプ(各軸値or変換値)は関係ないので、前回の教示タイプで動く
.mode = dest_mode[.rno]
END
POINT .rno: .#pos = #PPOINT(.bef_pos[1],.bef_pos[2],.bef_pos[3],.bef_pos[4],.bef_pos[5],.bef_pos[6],.pos[7])
END
VALUE 6,7,8:
DECOMPOSE .rno: .bef_pos[1] = #dest_pos[.rno]
IF .bef_pos[1]>=9999 THEN;前回の移動位置が無い(9999)の場合は現在値を取得する
IF .mode==mode_jt THEN
DECOMPOSE .rno: .bef_pos[1] = #S_HERE(.rno)
ELSE
DECOMPOSE .rno: .bef_pos[1] = S_HERE(.rno)
END
END
CASE .move OF
VALUE 0:;基軸のみ
POINT .rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.bef_pos[7],.bef_pos[8])
VALUE 1:;基軸+外部軸
POINT .rno: .#pos = #PPOINT(.pos[1],.pos[2],.pos[3],.pos[4],.pos[5],.pos[6],.pos[7],.pos[8])
VALUE 2:;外部軸のみ
IF dest_mode[.rno]<>9999 THEN
;外部軸のみ移動の場合は教示タイプ(各軸値or変換値)は関係ないので、前回の教示タイプで動く
.mode = dest_mode[.rno]
END
POINT .rno: .#pos = #PPOINT(.bef_pos[1],.bef_pos[2],.bef_pos[3],.bef_pos[4],.bef_pos[5],.bef_pos[6],.pos[7],.pos[8])
END
END
.END
.PROGRAM getstep(.$res,.ret)
;-------------------------------- 
;機能：作業情報の取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;--------------------------------
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.l3type = data_l3type[.l2num,.l3num]
IF flg_noset_name<>TRUE THEN
.$l3name = $data_l3name[.l2num,.l3num]
ELSE
.$l3name = ""
END
CASE .l3type OF
VALUE l3type_move:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name
;ビジョンID変換(引数順でID割当番号)
.vision_id1 = data_vision_id1[.l2num,.l3num]
CALL convert_vid(mode_del,type_pos,data_vision_id2[.l2num,.l3num],.vision_id2)
CALL convert_vid(mode_del,type_pos,data_vision_id3[.l2num,.l3num],.vision_id3)
.$res = .$res+","+$ENCODE(/L,data_vision_sta[.l2num,.l3num])+","+$ENCODE(/L,.vision_id1)+","+$ENCODE(/L,.vision_id2)+","+$ENCODE(/L,.vision_id3)
.$res = .$res+","+$ENCODE(/L,data_repspeed[.l2num,.l3num])+","+$ENCODE(/L,data_postype[.l2num,.l3num])+","+$ENCODE(/L,data_wait_befor[.l2num,.l3num])+","+$ENCODE(/L,data_wait_after[.l2num,.l3num])
NOEXIST_SET_R data_accel[.l2num,.l3num] = data_acc
NOEXIST_SET_R data_decel[.l2num,.l3num] = data_dec
NOEXIST_SET_R data_accuracy[.l2num,.l3num] = data_accu
NOEXIST_SET_R data_abssp_mode[.l2num,.l3num] = 0
NOEXIST_SET_R data_move_jt[.l2num,.l3num] = 0
NOEXIST_SET_R data_cv_no[.l2num,.l3num] = 0
NOEXIST_SET_R data_cv_work[.l2num,.l3num] = 0
.$res = .$res+","+$ENCODE(/L,data_accel[.l2num,.l3num])+","+$ENCODE(/L,data_decel[.l2num,.l3num])+","+$ENCODE(/L,data_accuracy[.l2num,.l3num])+","+$ENCODE(/L,data_abssp_mode[.l2num,.l3num])+","+$ENCODE(/L,data_move_jt[.l2num,.l3num])
.$res = .$res+","+$ENCODE(/L,data_cv_no[.l2num,.l3num])+","+$ENCODE(/L,data_cv_work[.l2num,.l3num])
VALUE l3type_io_wait:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_signum[.l2num,.l3num])
.$res = .$res+","+$ENCODE(/L,data_sigstatus[.l2num,.l3num])+","+$ENCODE(/L,data_wait_befor[.l2num,.l3num])+","+$ENCODE(/L,data_wait_after[.l2num,.l3num])+","+$ENCODE(/L,data_wait_timeo[.l2num,.l3num])
NOEXIST_SET_R data_wait_tocon[.l2num,.l3num] = 0
.$res = .$res+","+$ENCODE(/L,data_wait_tocon[.l2num,.l3num])
VALUE l3type_io_chang:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_signum[.l2num,.l3num])
.$res = .$res+","+$ENCODE(/L,data_sigstatus[.l2num,.l3num])+","+$ENCODE(/L,data_wait_befor[.l2num,.l3num])+","+$ENCODE(/L,data_wait_after[.l2num,.l3num])+","+$ENCODE(/L,data_keep_wait[.l2num,.l3num])
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend,l3type_return:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name
VALUE l3type_vision,l3type_calvisio:
;ビジョンID変換
CALL convert_vid(mode_del,data_vision_cal[.l2num,.l3num],data_vision_id[.l2num,.l3num],.vision_id)
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,.vision_id)+","+$ENCODE(/L,data_vision_cal[.l2num,.l3num])
NOEXIST_SET_R data_vision_cnt[.l2num,.l3num] = 0;         ビジョンNG続行フラグ初期値=0（停止）
.$res = .$res+","+$ENCODE(/L,data_vision_cnt[.l2num,.l3num]); ビジョンNG続行フラグ追加
VALUE l3type_l2reset:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_l2resetnum[.l2num,.l3num])
VALUE l3type_hand_cha:
NOEXIST_SET_R data_hand_sol[.l2num,.l3num] = 1
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_hand_ctl[.l2num,.l3num])+","+$ENCODE(/L,data_hand_sol[.l2num,.l3num])
VALUE l3type_colchk:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_colchk[.l2num,.l3num])
VALUE l3type_ifgoto:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_l3ifgoto_i[.l2num,.l3num])+","+$ENCODE(/L,data_l3ifgoto_l[.l2num,.l3num])
VALUE l3type_iflabel:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_l3label[.l2num,.l3num])
VALUE l3type_cnt:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_cntid[.l2num,.l3num])+","+$ENCODE(/L,data_cnttype[.l2num,.l3num])
VALUE l3type_cntset:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_cntid[.l2num,.l3num])+","+$ENCODE(/L,data_cntval[.l2num,.l3num])
VALUE l3type_stop:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_restart_fl[.l2num,.l3num])
VALUE l3type_call:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$data_callname[.l2num,.l3num]+","+$ENCODE(/L,data_callno[.l2num,.l3num])+","+$ENCODE(/L,data_callposnum[.l2num,.l3num])
VALUE l3type_cvwait:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_wait_cvno[.l2num,.l3num])+","+$ENCODE(/L,data_wait_cvwo[.l2num,.l3num])+","+$ENCODE(/L,data_wait_cvul[.l2num,.l3num])+","+$ENCODE(/L,data_wait_cvll[.l2num,.l3num])+","+$ENCODE(/L,data_wait_cvto[.l2num,.l3num])
VALUE l3type_cvstart:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_cvcoop_no[.l2num,.l3num])+","+$ENCODE(/L,data_cvcoop_wo[.l2num,.l3num])+","+$ENCODE(/L,data_cvcoop_pos[.l2num,.l3num])
VALUE l3type_cvcomp:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_cvcoop_no[.l2num,.l3num])+","+$ENCODE(/L,data_cvcoop_wo[.l2num,.l3num])+","+$ENCODE(/L,data_cvcoop_wo2[.l2num,.l3num])
VALUE l3type_shift:
.$res = $ENCODE(/L,data_robottype[.l2num,.l3num])+","+$ENCODE(/L,data_l3type[.l2num,.l3num])+","+.$l3name+","+$ENCODE(/L,data_refpos[.l2num,.l3num])+","+$ENCODE(/L,data_postype[.l2num,.l3num])+","+$ENCODE(/L,data_wait_befor[.l2num,.l3num])+","+$ENCODE(/L,data_wait_after[.l2num,.l3num])+","+$ENCODE(/L,data_repspeed[.l2num,.l3num])
.$res = .$res+","+$ENCODE(/L,data_accel[.l2num,.l3num])+","+$ENCODE(/L,data_decel[.l2num,.l3num])+","+$ENCODE(/L,data_accuracy[.l2num,.l3num])+","+$ENCODE(/L,data_abssp_mode[.l2num,.l3num])+","+$ENCODE(/L,data_move_jt[.l2num,.l3num])+","+$ENCODE(/L,data_cv_no[.l2num,.l3num])+","+$ENCODE(/L,data_cv_work[.l2num,.l3num])
ANY :
.ret = err_bad_l3type
END
.END
.PROGRAM getstepifgoto(.$res,.ret)
;-------------------------------- 
;機能：条件分岐詳細取得コア
;引数：第2階層番号、第3階層番号、条件番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.ifconid = VAL($prm[TASKNO,4])
NOEXIST_SET_R data_ifcnt2[.l2num,.l3num,.ifconid] = 0
NOEXIST_SET_R data_ifcnt3[.l2num,.l3num,.ifconid] = 0
.$res = $ENCODE(/L,data_ifmode[.l2num,.l3num,.ifconid])+","+$ENCODE(/L,data_iftype[.l2num,.l3num,.ifconid])+","+$ENCODE(/L,data_ifitem[.l2num,.l3num,.ifconid])+","+$ENCODE(/L,data_ifcnt[.l2num,.l3num,.ifconid])+","+$ENCODE(/L,data_ifcnt2[.l2num,.l3num,.ifconid])+","+$ENCODE(/L,data_ifcnt3[.l2num,.l3num,.ifconid])
.END
.PROGRAM getsteppos(.$res,.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号
;戻値：取得データ文字列、成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.$buf1 = $ENCODE(/L,data_mode[.l2num,.l3num])+","+$ENCODE(/L,data_tool[.l2num,.l3num])
NOEXIST_SET_R data_pos7[.l2num,.l3num] = 0
NOEXIST_SET_R data_pos8[.l2num,.l3num] = 0
NOEXIST_SET_R data_pos9[.l2num,.l3num] = 0
IF data_mode[.l2num,.l3num]<>mode_jt THEN
.$res = .$buf1+","+$ENCODE(/L,data_pos1[.l2num,.l3num])+","+$ENCODE(/L,data_pos2[.l2num,.l3num])+","+$ENCODE(/L,data_pos3[.l2num,.l3num])+","+$ENCODE(/L,data_pos4[.l2num,.l3num])+","+$ENCODE(/L,data_pos7[.l2num,.l3num])+","+$ENCODE(/L,data_pos8[.l2num,.l3num])+","+$ENCODE(/L,data_pos9[.l2num,.l3num])
ELSE
.$res = .$buf1+","+$ENCODE(/L,data_pos1[.l2num,.l3num])+","+$ENCODE(/L,data_pos2[.l2num,.l3num])+","+$ENCODE(/L,data_pos3[.l2num,.l3num])+","+$ENCODE(/L,data_pos4[.l2num,.l3num])+","+$ENCODE(/L,data_pos7[.l2num,.l3num])+","+$ENCODE(/L,data_pos8[.l2num,.l3num])+","+$ENCODE(/L,data_pos9[.l2num,.l3num])
END
.END
.PROGRAM give_coffee()
JMOVE #u2_begin
.END
.PROGRAM give_coffee_low()
sig_1 = FALSE
sig_3 = FALSE
sig_4 = FALSE
WAIT sig_1==TRUE
JMOVE #l1_begin
L3LMOVE #l1_glassup,1
DRIVE 3,80
DRIVE 3,5
sig_2 = TRUE
WAIT sig_3==TRUE
DRIVE 3,-135
L3LMOVE #l1_regrab,1
JMOVE #l1_regrabrot
sig_4 = TRUE
JMOVE #l1_fill1
JMOVE #l1_fill2
.END
.PROGRAM give_coffee_up()
sig_1 = FALSE
sig_2 = FALSE
sig_5 = FALSE
JMOVE #u2_begin
L3LMOVE #u2_pickglass,1
DRIVE 3,50
sig_1 = TRUE
WAIT sig_2==TRUE
JMOVE #u2_away
DRIVE 4,0.1
sig_3 = TRUE
WAIT sig_4==TRUE
JMOVE #u2_regrab1
JMOVE #u2_regrab2
JMOVE #u2_regrab3
JMOVE #u2_regrab4
JMOVE #u2_regrab5
JMOVE #u2_regrab6
JMOVE #u2_fill
.END
.PROGRAM gohome_chk(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：BASE引き動作後の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
.ret = err_no_error
RETURN
.END
.PROGRAM gohome_comp(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰完了後の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
.ret = err_no_error
RETURN
.END
.PROGRAM gohome_init(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰動作開始前の処理
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
.ret = err_no_error
RETURN
.END
.PROGRAM gohome_main(.home_no,.ret)
;-------------------------------- 
;機能：原点復帰ﾊﾟﾀｰﾝ選択
;引数：なし
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gohome_ptn = 0 ;原点復帰ﾊﾟﾀｰﾝﾘｾｯﾄ
DECOMPOSE 1: .jho1[1] = #HOME(.home_no)
DECOMPOSE 1: .jhe1[1] = #S_HERE(1)
DECOMPOSE 1: .lhe1[1] = S_HERE(1)
DECOMPOSE 2: .jho2[1] = #HOME(.home_no)
DECOMPOSE 2: .jhe2[1] = #S_HERE(2)
DECOMPOSE 2: .lhe2[1] = S_HERE(2)
POINT .null1 = TRANS(0,0,.jho1[3],0,0,0)
POINT .null2 = TRANS(0,0,.jho2[3],0,0,0)
POINT .here1 = TRANS(.lhe1[1],.lhe1[2],.jho1[3],.lhe1[4],.lhe1[5],.lhe1[6])
POINT .here2 = TRANS(.lhe2[1],.lhe2[2],.jho2[3],.lhe2[4],.lhe2[5],.lhe2[6])
POINT .here1h = TRANS(.lhe1[1],.lhe1[2],0,.lhe1[4],.lhe1[5],.lhe1[6]) ;ツール間現在距離算出用に3軸値を両アームで統一
POINT .here2h = TRANS(.lhe2[1],.lhe2[2],0,.lhe2[4],.lhe2[5],.lhe2[6])
.dist1 = DISTANCE(.here1,.null1)
.dist2 = DISTANCE(.here2,.null2)
POINT .base1 = TRANS(((chk_gohome[1]-5)*.lhe1[1])/.dist1,((chk_gohome[1]-5)*.lhe1[2])/.dist1,.jho1[3],.lhe1[4],.lhe1[5],.lhe1[6]);BASEに引いた点
POINT .base2 = TRANS(((chk_gohome[2]-5)*.lhe2[1])/.dist2,((chk_gohome[2]-5)*.lhe2[2])/.dist2,.jho2[3],.lhe2[4],.lhe2[5],.lhe2[6]);BASEに引いた点
;●原点復帰不可状態の処理
IF ABS(.jho1[1]-.jhe1[1])>360 OR ABS(.jho2[1]-.jhe2[1])>360 THEN ;1軸現在値が回転しすぎ
.ret = err_gen_jt1 ;1軸回転量異常
RETURN
END
IF (.jho1[2]<0 AND .jhe1[2]>=0) OR (.jho1[2]>=0 AND .jhe1[2]<0) OR (.jho2[2]<0 AND .jhe2[2]>=0) OR (.jho2[2]>=0 AND .jhe2[2]<0) THEN ;2軸現在値の符号が原点と逆
.ret = err_gen_jt2 ;2軸回転量異常
RETURN
END
IF (.jho1[2]>0 AND .jho2[2]>0) OR (.jho1[2]<0 AND .jho2[2]<0) OR .jho1[2]==0 OR .jho2[2]==0 THEN ;原点姿勢の異常(両ｱｰﾑの2軸が同一方向を向いている。2軸値の原点角度が0°)
.ret = err_gen_pos ;原点姿勢異常
RETURN
END
;●肘間の角度を計算
CALL chg_jt1rad(.jhe1[1],.jhe1[101]);下ｱｰﾑ側 1軸の角度を0〜360°内に変換
CALL chg_jt1rad(.jhe2[1],.jhe2[101]);上ｱｰﾑ側 1軸の角度を0〜360°内に変換
IF (.jhe1[101]<.jhe2[101] AND .jhe1[2]<0 AND .jhe2[2]>=0) OR (.jhe1[101]>.jhe2[101] AND .jhe2[2]<0 AND .jhe1[2]>=0) THEN
.jt2rad = ABS(.jhe1[101]-.jhe2[101])
ELSE
.jt2rad = 360-ABS(.jhe1[101]-.jhe2[101])
END
;●原点復帰パターンの選択
IF .dist1<chk_gohome[1] AND .dist2<chk_gohome[2] THEN ;両ｱｰﾑが既にBASEに引いている
gohome_ptn = 1 ;★その場から原点復帰
GOTO fin
END
IF (INRANGE(.base1,#S_HERE(1))<>0) THEN ;下ームが動作範囲外に近い
IF .jt2rad>chk_jt1_rad THEN ;肘間隔が広い
gohome_ptn = 2;★上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑを2軸曲げる
GOTO fin
ELSE ;肘間隔が狭い
gohome_ptn = 3;★両ｱｰﾑ2軸を曲げる
GOTO fin
END
END
IF DISTANCE(.here1h,.here2h)<chk_dist_here THEN ;アーム同士の距離が近い
IF .dist1<=.dist2 THEN ;下ｱｰﾑが上ｱｰﾑよりBASEに近い
gohome_ptn = 4;★協調でBASEに引く(下ｱｰﾑMASTER)
GOTO fin
ELSE ;上ｱｰﾑが下ｱｰﾑよりBASEに近い
gohome_ptn = 5;★協調でBASEに引く(上ｱｰﾑMASTER)
GOTO fin
END
ELSE ;アーム同士の距離が遠い場合
IF .jt2rad<chk_jt1_rad THEN ;肘間隔が狭い
gohome_ptn = 3;★両ｱｰﾑ2軸を曲げる
GOTO fin
ELSE
IF .dist1<=.dist2 THEN ;下ｱｰﾑが上ｱｰﾑよりBASEに近い
gohome_ptn = 6;★下ｱｰﾑをBASEに引いて逃げる→上ｱｰﾑをBASEに引く
GOTO fin
ELSE ;上ｱｰﾑが下ｱｰﾑよりBASEに近い
gohome_ptn = 7;★上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑをBASEに引く
GOTO fin
END
END
END
.ret = err_gen_noptn ;原点復帰条件未成立
fin:
RETURN
.END
.PROGRAM gohome_move(.rno,.gohome_ptn,.home_no,.ret)
;-------------------------------- 
;機能：原点復帰動作
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号、原点復帰ﾊﾟﾀｰﾝ、原点番号
;戻値：成否
;--------------------------------
;ﾊﾝﾄﾞI/Oの初期化等の処理はここに追加する。
IF flg_gohome_init<>FALSE THEN
IF EXISTDATA("gohome_init",G)==-1 THEN
CALL gohome_init(.rno,.gohome_ptn,.home_no,.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
END
;ここまで
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
DECOMPOSE .rno: .jho[1] = #HOME(.home_no)
DECOMPOSE .rno: .jhe[1] = #S_HERE(.rno)
DECOMPOSE .rno: .lhe[1] = S_HERE(.rno)
POINT .null = TRANS(0,0,.jho[3],0,0,0)
POINT .here = TRANS(.lhe[1],.lhe[2],.jho[3],.lhe[4],.lhe[5],.lhe[6])
.dist = DISTANCE(.here,.null)
CASE .axis OF
VALUE 4:
POINT .base = TRANS(((chk_gohome[.rno]-5)*.lhe[1])/.dist,((chk_gohome[.rno]-5)*.lhe[2])/.dist,.jho[3],.lhe[4],.lhe[5],.lhe[6]);BASEに引いた点
JMOVE #PPOINT(.jhe[1],.jhe[2],.jho[3],.jhe[4],.jhe[5],.jhe[6]);3軸を原点高さにする
VALUE 5:
POINT .base = TRANS(((chk_gohome[.rno]-5)*.lhe[1])/.dist,((chk_gohome[.rno]-5)*.lhe[2])/.dist,.jho[3],.lhe[4],.lhe[5],.lhe[6],.lhe[7]);BASEに引いた点
JMOVE #PPOINT(.jhe[1],.jhe[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7]);3軸を原点高さにする
VALUE 6,7,8:
POINT .base = TRANS(((chk_gohome[.rno]-5)*.lhe[1])/.dist,((chk_gohome[.rno]-5)*.lhe[2])/.dist,.jho[3],.lhe[4],.lhe[5],.lhe[6],.lhe[7],.lhe[8]);BASEに引いた点
JMOVE #PPOINT(.jhe[1],.jhe[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7],.jhe[8]);3軸を原点高さにする
END
;BASE引き動作
CASE .gohome_ptn OF
VALUE 1:;その場から原点復帰
VALUE 2:;上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑ2軸を曲げる
IF .rno==pg_master THEN
CALL cont_timing
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6])
VALUE 5:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7])
VALUE 6,7,8:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7],.jhe[8])
END
BREAK
ELSE
ZL3LMOVE .base,1,1
BREAK
CALL gohome_nige(.home_no,.rno);1軸退避動作
CALL cont_timing
END
VALUE 3:;両ｱｰﾑ2軸を曲げる
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6])
VALUE 5:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7])
VALUE 6,7,8:
JMOVE #PPOINT(.jhe[1],.jho[2],.jho[3],.jhe[4],.jhe[5],.jhe[6],.jhe[7],.jhe[8])
END
BREAK
VALUE 4:;協調でBASEに引く(下ｱｰﾑMASTER)
IF .rno==pg_master THEN
MASTER
MLZL3LMOVE .base,1,1
BREAK
ALONE
CALL gohome_nige(.home_no,.rno);1軸退避動作
CALL cont_timing
ELSE
SLAVE
ALONE
CALL cont_timing
ZL3LMOVE .base,1,1
BREAK
END
VALUE 5:;協調でBASEに引く(上ｱｰﾑMASTER)
IF .rno==pg_master THEN
SLAVE
ALONE
CALL cont_timing
ZL3LMOVE .base,1,1
BREAK
ELSE
MASTER
MLZL3LMOVE .base,1,1
BREAK
ALONE
CALL gohome_nige(.home_no,.rno);1軸退避動作
CALL cont_timing
END
VALUE 6:;下ｱｰﾑをBASEに引いて逃げる→上ｱｰﾑをBASEに引く
IF .rno==pg_master THEN
ZL3LMOVE .base,1,1
BREAK
CALL gohome_nige(.home_no,.rno);1軸退避動作
CALL cont_timing
ELSE
CALL cont_timing
ZL3LMOVE .base,1,1
BREAK
END
VALUE 7:;上ｱｰﾑをBASEに引いて逃げる→下ｱｰﾑをBASEに引く
IF .rno==pg_master THEN
CALL cont_timing
ZL3LMOVE .base,1,1
BREAK
ELSE
ZL3LMOVE .base,1,1
BREAK
CALL gohome_nige(.home_no,.rno);1軸退避動作
CALL cont_timing
END
END
BREAK
CALL cont_timing
;BASE引き動作完了
IF SYSDATA(HOME_CHK,.rno,4)<>FALSE THEN
DECOMPOSE .rno: .jt[1] = #S_HERE(.rno)
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jt[1],.jt[2],.jt[3],.jho[4],.jt[5],.jt[6]);4軸を原点位置に戻す
VALUE 5:
JMOVE #PPOINT(.jt[1],.jt[2],.jt[3],.jho[4],.jt[5],.jt[6],.jt[7]);4軸を原点位置に戻す
VALUE 6,7,8:
JMOVE #PPOINT(.jt[1],.jt[2],.jt[3],.jho[4],.jt[5],.jt[6],.jt[7],.jt[8]);4軸を原点位置に戻す
END
END
BREAK
CALL cont_timing
IF DISTANCE(S_HERE(.rno),.null)<=chk_gohome[.rno] THEN
;BASE引き後、周辺装置等の原点復帰処理等をしたい場合はここに処理を追加する
IF flg_gohome_chk<>FALSE THEN
IF EXISTDATA("gohome_chk",G)==-1 THEN
CALL gohome_chk(.rno,.gohome_ptn,.home_no,.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
END
ELSE
.ret = err_gen_base[.rno]
RETURN
END
;ここまで
;安全距離からの原点復帰動作
DECOMPOSE .rno: .jt[1] = #S_HERE(.rno)
IF .rno==pg_master THEN
MASTER
CASE .axis OF
VALUE 4:
MLJMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6]);@下ｱｰﾑの1軸を原点位置に戻す
VALUE 5:
MLJMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6],.jt[7]);@下ｱｰﾑの1軸を原点位置に戻す
VALUE 6,7,8:
MLJMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6],.jt[7],.jt[8]);@下ｱｰﾑの1軸を原点位置に戻す
END
BREAK
ALONE
ELSE
SLAVE;@待ち
ALONE
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6]);A上ｱｰﾑの1軸を原点位置に戻す
VALUE 5:
JMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6],.jt[7]);A上ｱｰﾑの1軸を原点位置に戻す
VALUE 6,7,8:
JMOVE #PPOINT(.jho[1],.jt[2],.jt[3],.jt[4],.jt[5],.jt[6],.jt[7],.jt[8]);A上ｱｰﾑの1軸を原点位置に戻す
END
BREAK
END
CALL cont_timing
DECOMPOSE .rno: .jt[1] = #S_HERE(.rno)
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.jt[4],.jho[5],.jho[6]);両アーム2軸を原点に戻す
VALUE 5:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.jt[4],.jho[5],.jho[6],.jt[7]);両アーム2軸を原点に戻す
VALUE 6,7,8:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.jt[4],.jho[5],.jho[6],.jt[7],.jt[8]);両アーム2軸を原点に戻す
END
BREAK
CALL cont_timing
DECOMPOSE .rno: .jt[1] = #S_HERE(.rno)
FOR .i = 4 TO 8
NOEXIST_SET_R .jho[.i] = 0
NOEXIST_SET_R .jt[.i] = 0
IF SYSDATA(JTEXIST,.rno,.i)<>FALSE THEN
IF SYSDATA(HOME_CHK,.rno,.i)<>FALSE THEN
.temp[.i] = .jho[.i]
ELSE
.temp[.i] = .jt[.i]
END
ELSE
.temp[.i] = .jt[.i]
END
END
CASE .axis OF
VALUE 4:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6]);両アーム外部軸を原点に戻す
VALUE 5:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6],.temp[7]);両アーム外部軸を原点に戻す
VALUE 6,7,8:
JMOVE #PPOINT(.jho[1],.jho[2],.jho[3],.temp[4],.jho[5],.jho[6],.temp[7],.temp[8]);両アーム外部軸を原点に戻す
END
CALL cont_timing
;原点復帰完了後の処理がある場合はここに追加する
IF flg_gohome_comp<>FALSE THEN
IF EXISTDATA("gohome_comp",G)==-1 THEN
CALL gohome_comp(.rno,.gohome_ptn,.home_no,.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
END
RETURN
.END
.PROGRAM gohome_nige(.home_no,.rno)
;-------------------------------- 
;機能：原点復帰 1軸退避動作
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号
;戻値：なし
;-------------------------------- 
IF .rno==pg_master THEN
.arno = pg_slave
ELSE
.arno = pg_master
END
GETULIMIT .rno: .#ulim
GETLLIMIT .rno: .#llim
.ulim[1] = DEXT(.#ulim,1)
.llim[1] = DEXT(.#llim,1)
.jt1here = DEXT(#S_HERE(.rno),1);1軸値を取得
DECOMPOSE .rno: .jho[1] = #HOME(.home_no);原点の各軸成分を取得
DECOMPOSE 1: .jhe1[1] = #S_HERE(1);現在値の各軸成分を取得
DECOMPOSE 2: .jhe2[1] = #S_HERE(2);現在値の各軸成分を取得
;●肘間の角度を計算→退避角度の算出
CALL chg_jt1rad(.jhe1[1],.jhe1[101]);下ｱｰﾑ側 1軸の角度を0〜360°内に変換
CALL chg_jt1rad(.jhe2[1],.jhe2[101]);上ｱｰﾑ側 1軸の角度を0〜360°内に変換
IF (.jhe1[101]<.jhe2[101] AND .jhe1[2]<0 AND .jhe2[2]>=0) OR (.jhe1[101]>.jhe2[101] AND .jhe2[2]<0 AND .jhe1[2]>=0) THEN
.jt2rad = ABS(.jhe1[101]-.jhe2[101])
ELSE
.jt2rad = 360-ABS(.jhe1[101]-.jhe2[101])
END
.rad = (.jt2rad-chk_jt1_rad);退避角度
;●退避動作
;退避アームがマイナス側にある場合は、.radがプラスの時に1軸をマイナス側に退避する。.radがマイナスな場合は1軸をプラス側に退避する。
;退避アームがプラス側にある場合は、.radがプラスの時に1軸をプラス側に退避する。.radがマイナスな場合は1軸をマイナス側に退避する。
IF .jho[2]>0 THEN ;退避するｱｰﾑが右側(マイナス側)にある
IF .rad>=0 THEN;マイナス側に退避するので、LLIMITを確認する。
WHILE NOT ((.jt1here-ABS(.rad))>=.llim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をデクリメントする
.rad = .rad-1
IF .rad<=0 THEN
RETURN
END
TWAIT ascycle
END
ELSE;プラス側に退避するので、ULIMITを確認する。
WHILE NOT ((.jt1here+ABS(.rad))<=.ulim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をインクリメントする
.rad = .rad+1
IF .rad>=0 THEN
RETURN
END
TWAIT ascycle
END
END
DRIVE 1,-.rad
ELSE ;退避するｱｰﾑが左側(プラス側)にある
IF .rad>=0 THEN;プラス側に退避するので、ULIMITを確認する。
WHILE NOT ((.jt1here+ABS(.rad))<=.ulim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をインクリメントする
.rad = .rad-1
IF .rad<=0 THEN
RETURN
END
TWAIT ascycle
END
ELSE;マイナス側に退避するので、LLIMITを確認する。
WHILE NOT ((.jt1here-ABS(.rad))>=.llim[1]) DO ;退避動作後の軸値が動作範囲外の場合、退避角度をデクリメントする
.rad = .rad+1
IF .rad>=0 THEN
RETURN
END
TWAIT ascycle
END
END
DRIVE 1,.rad
END
RETURN
.END
.PROGRAM gravityadj(.rno,.mode,.master_setval,.slave_setval,.ret)
;-------------------------------- 
;重力補償自動調整呼出
;引数：通信受信文字列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
flg_slave_grave = FALSE
CASE .rno OF
VALUE robot_all:
gs_gravity_mode = .mode
gs_gravity_setv = .slave_setval
flg_slave_move = TRUE
IF debug.prt.main==ON THEN
PRINT "->gravityadj() TASKNO=",TASKNO,",START FLG_SLAVE_MOVE = TRUE in CMD_EXE_GEN"
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot started gravityadj_core()."
END
CALL gravityadj_core(robot_master,.mode,.master_setval,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot done gravityadj_core()."
END
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF flg_slave_grave==TRUE THEN
.ret = err_gravityadj
flg_slave_grave = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() Slave robot done gravityadj_core()."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
END
END
TWAIT ascycle
END
VALUE robot_master:
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot started gravityadj_core()."
END
CALL gravityadj_core(robot_master,.mode,.master_setval,.ret)
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() MASTER robot done gravityadj_core()."
END
VALUE robot_slave:
gs_gravity_mode = .mode
gs_gravity_setv = .slave_setval
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF flg_slave_grave==TRUE THEN
.ret = err_gravityadj
flg_slave_grave = FALSE
END
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() Slave robot done gravityadj_core()."
END
RETURN
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "->gravityadj() WAITING done gravityadj_core() in Slave robotmove."
END
END
TWAIT ascycle
END
END
BREAK
.END
.PROGRAM gravityadj_core(.rno,.mode,.setval,.ret)
;-------------------------------- 
;重力補償自動調整処理
;引数：ロボット番号、モード(0:自動、1:手動)、ロボット番号に対応した設定値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... .rno=",.rno,",.mode=",.mode,",.setval=",.setval
IF .mode==1 THEN
IF .setval>=500 THEN
.setval = 500
END
IF .setval<=-500 THEN
.setval = -500
END
ZSAGRAV .rno: 3,.setval
grav_cur_val[.rno-1] = .setval
ELSE
CALL setgrav(.rno,.ret)
END
IF .ret<>err_no_error AND TASKNO==robot_slave THEN
flg_slave_grave = TRUE
END
NOEXIST_SET_R grav_cur_val[0] = 0
NOEXIST_SET_R grav_cur_val[1] = 0
PRINT "cmdgravityadj()-> TASKNO=",TASKNO,",Executing...... GRAV_CUR_VAL[0]=",grav_cur_val[0],",GRAV_CUR_VAL[1]=",grav_cur_val[1]
.END
.PROGRAM h1pr()
CP ON
flag = 0
JMOVE h1start
JMOVE h1p1
flag = 10
L3DRAW ,60
L3DRAW ,-60
JMOVE h1p1
JMOVE h1start
.END
.PROGRAM h2pr()
CP ON
WHILE flag<9 DO
L3DRAW ,,5
L3DRAW ,,-5
END
JMOVE h2start
JMOVE h2p1
JMOVE h2p2
JMOVE h2p3
JMOVE h2p2
JMOVE h2p1
JMOVE h2start
.END
.PROGRAM hand(.rno,.status,.solno,.ret)
;-------------------------------- 
;機能：ハンド操作
;引数：ロボット番号、ハンド状態(0=閉、1=開)、ハンドSOL番号(1〜4)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",HAND STATUS=",.status,",HAND SOL NUMBER=",.solno
END
IF (.solno<1) OR (.solno>4) THEN
.ret = err_bat_value
RETURN
END
CASE .rno OF
VALUE robot_all:
CALL handiochk(robot_master,.solno,.ret)
IF .ret<>err_no_error THEN
RETURN
END
CALL handiochk(robot_slave,.solno,.ret)
IF .ret<>err_no_error THEN
RETURN
END
data_hand_sta[robot_master,.solno] = .status
data_hand_sta[robot_slave,.solno] = .status
CALL handmove(robot_master,.status,.solno,.ret)
CALL handmove(robot_slave,.status,.solno,.ret)
VALUE robot_master,robot_slave:
CALL handiochk(.rno,.solno,.ret)
IF .ret<>err_no_error THEN
RETURN
END
data_hand_sta[.rno,.solno] = .status
CALL handmove(.rno,.status,.solno,.ret)
ANY :
.ret = err_bad_rno
PRINT "TASKNO=",TASKNO,",err_bad_rno"
RETURN
END
.END
.PROGRAM handiochk(.rno,.solno,.ret)
;-------------------------------- 
;機能：ハンド制御信号設定状態チェック
;引数：ロボット番号、ハンドSOL番号(1〜4)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.ionum1 = .solno*2-1 ;SOL信号番号の設定(1,3,5,7)
.ionum2 = .solno*2 ;SOL信号番号の設定(2,4,6,8)
IF data_hand_iotyp[.rno,.solno]==hand_single THEN
IF (data_hand_io[.rno,.ionum1]==0) THEN
.ret = err_bad_handio
PRINT "chkhandio()->err_bad_handio"
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",data_hand_iotyp[.rno,.solno],"(HAND_SINGLE),io1=",data_hand_io[.rno,1],",io2=",data_hand_io[.rno,3],",io3=",data_hand_io[.rno,5],",io4=",data_hand_io[.rno,7]
RETURN
END
END
IF data_hand_iotyp[.rno,.solno]==hand_double THEN
IF (data_hand_io[.rno,.ionum1]==0) OR (data_hand_io[.rno,.ionum2]==0) THEN
.ret = err_bad_handio
PRINT "chkhandio()->err_bad_handio"
PRINT "TASKNO=",TASKNO,",.rno=",.rno,",handtype=",data_hand_iotyp[.rno,.solno],"(HAND_DOUBLE),io1=",data_hand_io[.rno,1],",io2=",data_hand_io[.rno,2],",io3=",data_hand_io[.rno,3],",io4=",data_hand_io[.rno,4],",io5=",data_hand_io[.rno,5],",io6=",data_hand_io[.rno,6],",io7=",data_hand_io[.rno,7],",io8=",data_hand_io[.rno,8]
RETURN
END
END
.END
.PROGRAM handmove(.rno,.status,.solno,.ret)
;-------------------------------- 
;機能：ハンド制御信号変更
;引数：ロボット番号、ハンド状態(0=閉、1=開)、ハンドSOL番号(1〜4)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.ionum1 = .solno*2-1 ;SOL信号番号の設定(1,3,5,7)
.ionum2 = .solno*2 ;SOL信号番号の設定(2,4,6,8)
CALL get_iotype(data_hand_io[.rno,.ionum1],.sigtype,.ret)
IF .ret<>err_no_error THEN
RETURN
END
IF .sigtype<>io_do THEN
.ret = err_bad_signo
RETURN
END
IF data_hand_iotyp[.rno,.solno]==hand_single THEN
IF .status==hand_close THEN
SIGNAL data_hand_io[.rno,.ionum1]
END
IF .status==hand_open THEN
SIGNAL -data_hand_io[.rno,.ionum1]
END
END
IF data_hand_iotyp[.rno,.solno]==hand_double THEN
CALL get_iotype(data_hand_io[.rno,.ionum2],.sigtype,.ret)
IF .ret<>err_no_error THEN
RETURN
END
IF .sigtype<>io_do THEN
.ret = err_bad_signo
RETURN
END
IF .status==hand_close THEN
SIGNAL data_hand_io[.rno,.ionum1],-data_hand_io[.rno,.ionum2]
END
IF .status==hand_open THEN
SIGNAL -data_hand_io[.rno,.ionum1],data_hand_io[.rno,.ionum2]
END
END
IF debug.prt.item==TRUE THEN
IF .rno==1 THEN
PRINT "TASKNO=",TASKNO,", hand()->HAND STATUS=",.status,", 49=",SIG(49),", 50=",SIG(50),", 51=",SIG(51),", 52=",SIG(52),", Time= ",$TIME
END
IF .rno==2 THEN
PRINT "TASKNO=",TASKNO," ,hand()->HAND STATUS=",.status,", 65=",SIG(65),", 66=",SIG(66),", 67=",SIG(67),", 68=",SIG(68),", Time= ",$TIME
END
END
.END
.PROGRAM iochange(.signo,.status,.keeptime,.ret)
;-------------------------------- 
;機能：IO変更実行
;引数：信号番号、信号状態、状態保持時間
;戻値：成否
;説明；信号変更前の状態を保持して状態保持時間経過後にIO変更前の状態に戻す
;-------------------------------- 
.ret = err_no_error
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", Keed Signal Time=",.keeptime
END
IF .signo<=0 THEN
;信号状態は.statusに分離管理しているので.signo負値は存在しない
;操作を無視したいときに上位が意図的に0を設定する可能性があるため許容する
RETURN
END
CALL get_iotype(.signo,.sigtype,.ret)
IF .ret<>err_no_error THEN
RETURN
END
IF .sigtype==io_di THEN
;入力信号は変更出来ないのでエラーにする
.ret = err_bad_signo
RETURN
END
.pre_io_status = SIG(.signo)
IF flg_pulse_io<>FALSE THEN
IF .status<>FALSE THEN
IF .keeptime>0 AND .pre_io_status==FALSE THEN;前状態がOFFの場合のみパルス出力する
PULSE .signo,(.keeptime/1000)
ELSE
SIGNAL .signo
END
ELSE
SIGNAL -.signo
IF .keeptime>0 AND .pre_io_status<>FALSE THEN
DLYSIG .signo,(.keeptime/1000)
END
END
IF debug.prt.item==TRUE THEN
PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", SIG",.signo,"=",SIG(.signo),", Keep Signal Time=",.keeptime,", Time= ",$TIME
END
ELSE
IF .status<>FALSE THEN
SIGNAL .signo
ELSE
SIGNAL -.signo
END
IF debug.prt.item==TRUE THEN
PRINT "TASKNO=",TASKNO,", iochange()->Signal Number=",.signo,", Signal Status=",.status,", SIG",.signo,"=",SIG(.signo),", Keep Signal Time=",.keeptime,", Time= ",$TIME
END
IF .keeptime>0 THEN
TWAIT .keeptime/1000
IF .pre_io_status<>FALSE THEN
SIGNAL .signo
ELSE
SIGNAL -.signo
END
END
END
.END
.PROGRAM judge_accept(.ena)
;--------------------------------
;機能：接続要求受付判断
;引数：無し
;戻値：接続要求受付可否[0:受付却下/ -1受付許可]
;--------------------------------
.ena = TRUE
; 接続状態の確認
.tcp_cnt = 0
TCP_STATUS .tcp_cnt,.port_no[0],.sock_id[0],.err_code[0],.sub_code[0],.$ip_add[0]
IF .tcp_cnt>0 THEN
FOR .i = 0 TO .tcp_cnt-1
IF .port_no[.i]==tcp_listen_port[0] OR .port_no[.i]==tcp_listen_port[1] OR (.port_no[.i]==0 AND .err_code[.i]==-34025) THEN
ELSE
.ena = FALSE; LISTENポート以外で切断されていないポートがある
GOTO jump
END
END
END
jump:
IF .ena==FALSE THEN
; 通信状態の確認
IF UTIMER(@com_check_timer)>com_timeout THEN
.ena = TRUE; 通信が一定時間途切れている場合は切断されていることにする
END
END
RETURN
.END
.PROGRAM killpg()
;---------------------------------
;機能：プログラムロード準備
;    ；全TASK停止、PCプログラム7番で実行専用
;---------------------------------
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " "
PRINT " This program have to execute in PC-PROGRAM No.7."
PRINT " "
IF TASKNO<>1007 THEN
PRINT " "
PRINT " *****************************************"
PRINT "  Aborted execute killpg()."
PRINT "  Please execute in PC-PROGRAM No.7."
PRINT "  You doing execute in TASKNO=",TASKNO
PRINT " *****************************************"
PRINT " "
RETURN
END
PRINT " Starting.... killpg()"
flg_start_killp = TRUE
PCABORT 6: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1006)<>1 THEN
PRINT "  1006-PCABORT"
GOTO 12
END
TWAIT ascycle
END
12
PCABORT 5: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1005)<>1 THEN
PRINT "  1005-PCABORT"
GOTO 13
END
TWAIT ascycle
END
13
PCABORT 1: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1001)<>1 THEN
PRINT "  1001-PCABORT"
GOTO 14
END
TWAIT ascycle
END
14
PCABORT 3: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1003)<>1 THEN
PRINT "  1003-PCABORT"
GOTO 15
END
TWAIT ascycle
END
15
PCABORT 4: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1004)<>1 THEN
PRINT "  1004-PCABORT"
GOTO 16
END
TWAIT ascycle
END
16
PCABORT 8: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1008)<>1 THEN
PRINT "  1008-PCABORT"
GOTO 17
END
TWAIT ascycle
END
17
PCABORT 2: 
UTIMER .@nowtime = 0
WHILE (1) DO
IF UTIMER(.@nowtime)>boot_timeout THEN
PRINT "中断できません TASKNO=",TASKNO
RETURN
END
IF TASK(1002)<>1 THEN
PRINT "  1002-PCABORT"
GOTO 18
END
TWAIT ascycle
END
18
MC PCKILL 8:
PRINT "  1008-PCKILL"
MC PCKILL 2:
PRINT "  1002-PCKILL"
MC PCKILL 4: 
PRINT "  1004-PCKILL"
MC PCKILL 3: 
PRINT "  1003-PCKILL"
MC PCKILL 6: 
PRINT "  1006-PCKILL"
MC PCKILL 5: 
PRINT "  1005-PCKILL"
MC PCKILL 1:
PRINT "  1001-PCKILL"
PRINT " "
;ロボットマスター
MC HOLD 1:
PRINT "  1-HOLD"
MC ABORT 1:
PRINT "  1-ABORT"
TWAIT 1
MC KILL 1:
PRINT "  1-KILL"
;ロボットスレーブ
MC HOLD 2:
PRINT "  2-HOLD"
MC ABORT 2:
PRINT "  2-ABORT"
TWAIT 1
MC KILL 2:
PRINT "  2-KILL"
PRINT " "
PRINT " Done killpg(). Now... You can be load some files for controllers in safety."
PRINT " "
MC ZPOW 1: OFF
MC ZPOW 2: OFF
.END
.PROGRAM kof_main()
;---------------------------------
;機能：動作プログラム(マスター)
;引数：無し
;戻値：無し
;-------------------------------- 
.ret = g_last_error
.$res = ""
IF TASKNO==pg_master THEN
IF debug.prt.main==ON THEN
PRINT "main()-> Booted main program. This program working in ROBOT-MASTER."
END
ELSE
PRINT "main()-> Booted main program in BAD-TASK. TASKNO=",TASKNO
RETURN
END
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
IF debug.prt.main==ON THEN
PRINT "main()-> Done main program. ROBOT_MODE=",robot_mode,",ROBOT_MODE_FLG=",robot_mode_flg
END
GOTO 10
END
CALL exec_alone(.ret)
;ダイレクトティーチモード強制解除
SAEND
SAENVCHKON
999
;初期化：共通処理
CALL chg_move_param(0,100,100,100,1,.ret)
;初期化：ロボット別
flg_tablet_run[1] = TRUE
;スレーブロボット動作準備完了待ち
IF flg_tablet_run[2]==FALSE THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>wait_slave_time THEN
GOTO 10
END
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",WAITING... SLAVE-ROBOT still not booted.OPE_COMMAND=",ope_command
END
TWAIT ascycle
UNTIL (flg_tablet_run[2]==TRUE)
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 1"
END
ELSE
IF debug.prt.main==ON THEN
PRINT "main()-> TASKNO=",TASKNO,",SLAVE-ROBOT is booted. CHECKPOINT 2"
END
END
sys_force_cmode = FALSE
smode_start = FALSE
flg_master_move = FALSE
flg_req_mamode = FALSE
flg_main_run = TRUE
flg_direct_run = FALSE
;コマンド実行指示待ち
DO
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
;プログラム終了後status_check関数が反応してエラー状態に遷移する
PRINT "main()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
GOTO 10
END
TWAIT ascycle
UNTIL (flg_master_move==TRUE)
;コマンド実行
IF flg_master_con==TRUE THEN
;マスター作業再開
;ロボット状態遷移
IF flg_single_move==FALSE THEN
robot_status = sta_exe
ELSE
robot_status = sta_l2exe
END
IF debug.prt.main==ON THEN
PRINT "main()->OPE_COMMAND=",ope_command
PRINT "main()->マスター動作を再実行します。DATA_CUR_L2REC[ROBOT_MASTER]=",data_cur_l2rec[robot_master]
PRINT "main()->マスター動作を再実行します。DATA_CUR_L3REC[ROBOT_MASTER]=",data_cur_l3rec[robot_master]
END
.l2num = data_cur_l2rec[robot_master]
.l3num = data_cur_l3rec[robot_master]
IF .l2num==0 AND .l3num==0 THEN
IF debug.prt.main==ON THEN
PRINT "main()->.l2num and .l3num are Zero for MASTER ROBOT!."
END
flg_master_con = FALSE
GOTO 10
END
CALL l2exec(.l2num,.l3num,.ret)
IF .ret==err_no_error THEN
IF flg_single_move==FALSE THEN
data_execute = TRUE
IF debug.prt.main==ON THEN
PRINT "main()->START cmdexe() after RESTART-command."
END
;作業継続用情報初期化(マスター、スレーブ両方)
CALL updatel2l3info(FALSE,0,0,FALSE)
;引き続き作業を続行する
$prm[TASKNO,0] = $ENCODE(cmd_exe_start)
$prm[TASKNO,1] = "0"
$prm[TASKNO,2] = "1"
$prm[TASKNO,3] = "1234"
CALL cmdexecore(.ret)
ELSE
;個別実行再開完了後は再開不可
CALL updatel2l3info(TRUE,0,0,TRUE)
robot_status = sta_nomove
END
END
ELSE
;通常コマンド実行
CALL cmdmain(ope_command,.$res,.ret)
END
CALL update_error(.ret)
10
;終了処理
;完全初期化後のエラー回避
IF ope_command<>1999 THEN
;動作完了応答
IF cmd_wait_type[ope_command]==cmd_type_wait THEN
BREAK
CALL sendresp(ope_command,.$res,.ret)
END
END
;タブレットティーチモード中はプログラムを終了しない
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) THEN
GOTO 999
END
flg_main_run = FALSE
data_execute = FALSE
flg_master_move = FALSE
flg_tablet_run[1] = FALSE
.END
.PROGRAM kof_sub()
;---------------------------------
;機能：動作プログラム(スレーブ)
;引数：無し
;戻値：無し
;-------------------------------- 
.ret = g_last_error
.$res = ""
IF TASKNO==pg_slave THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Booted sub program. This program working in ROBOT-MASTER."
END
ELSE
PRINT "sub()-> Booted sub program in BAD-TASK. TASKNO=",TASKNO
RETURN
END
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Done sub program. ROBOT_MODE=",robot_mode,",ROBOT_MODE_FLG=",robot_mode_flg
END
GOTO 10
END
CALL exec_alone(.ret)
;ダイレクトティーチモード強制解除
SAEND
SAENVCHKON
;
flg_slave_moved = FALSE; 動作済みフラグ
syn_mode_end = FALSE; 同期終了フラグ
999
;初期化：共通処理
IF flg_slave_moved==FALSE THEN
CALL chg_move_param(0,100,100,100,1,.ret)
END
;初期化：ロボット別
flg_tablet_run[2] = TRUE
flg_slave_rdy = FALSE
flg_slave_move = FALSE
;マスターロボット動作準備完了待ち
IF flg_tablet_run[1]==FALSE THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>wait_maste_time THEN
GOTO 10
END
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",WAITING... MASTER-ROBOT still not booted."
END
TWAIT ascycle
UNTIL (flg_tablet_run[1]==TRUE)
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 1"
END
ELSE
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 2"
END
END
;コマンド実行指示待ち
DO
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
;プログラム終了後status_check関数が反応してエラー状態に遷移する
IF debug.prt.sub==ON THEN
PRINT "sub()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
END
GOTO 10
END
;マスター動作プログラム終了に併せてスレーブロボットの動作を終了する
IF flg_tablet_run[1]==FALSE THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> MSTER ROBOT IS NOT BOOTING...OPE_COMMAND=",ope_command
END
GOTO 10
END
;同期終了処理
IF syn_mode_end==TRUE THEN
syn_mode_end = FALSE
ALONE
END
TWAIT ascycle
UNTIL (flg_slave_move==TRUE)
;コマンド実行
;実行タイミングはMASTERが指示、エラー処理はMASTERで実行
CASE ope_command OF
VALUE cmd_exe_gen:
;原点番号設定
.home_no = VAL($ope_param[3])
;ロボット番号設定
.rno = VAL($ope_param[1])
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
BREAK
VALUE cmd_exe_start,cmd_exe_move,cmd_exe_teach,cmd_exe_l2exe,cmd_exe_restart:
IF flg_slave_paral==FALSE THEN
;動作コマンドのみサポート、その他(IO待ち、変更など）はMASTERで実行
IF flg_slave_call==TRUE AND ope_command<>cmd_exe_move AND ope_command<>cmd_exe_teach THEN
flg_slave_call = FALSE
coopsta[robot_slave] = COOPSTATUS(robot_slave)
flg_exec_first_ = FALSE;初回動作フラグOFF
flg_slowlimit = FALSE;スロースタートフラグOFF
flg_nonbreak[robot_slave] = OFF;BREAK無しフラグOFF
CALL setl3speed(0,TRUE)
SPEED 100 ALWAYS;プログラム速度を最高速にする
CALL reset_mon_sp(robot_all); モニタ速度を変更している場合は元に戻す
flg_call_now[robot_slave] = TRUE
POINT #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
dest_mode[2] = 9999
SCALL $gs_callname
IF flg_nonbreak[robot_slave]==OFF OR gs_bflag==TRUE THEN
BREAK
ELSE
flg_nonbreak[robot_slave] = OFF
END
flg_call_now[robot_slave] = FALSE
IF coopsta[robot_slave]<>COOPSTATUS(robot_slave) THEN
;再開不可
no_restart_flg = TRUE
data_execute = FALSE
CALL update_error(err_coop_chg)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
END
ELSE
CALL submove(.ret)
CALL update_error(.ret)
END
ELSE
BREAK; 並列動作開始の為BREAK
;並列スレーブロボット連続作業実行
.l2num = gs_l2num
.l3num = gs_l3num
IF .l2num==0 AND .l3num==0 THEN
IF debug.prt.sub==ON THEN
PRINT "sub()->.l2num and .l3num are Zero for SLAVE ROBOT!."
END
flg_slave_con = FALSE
GOTO 10
END
;マスターが実行済み部分をスキップして処理開始
IF flg_slave_con==TRUE THEN
CALL l2exec(.l2num,.l3num,.ret)
CALL update_error(.ret)
ELSE
FOR .l2num = gs_l2num TO data_l2num
CALL l2exec(.l2num,.l3num,.ret)
IF .ret<>err_no_error THEN
IF .ret==err_slave_acten THEN
;正常終了処理
.ret = err_no_error
GOTO 10
ELSE
;異常終了処理
CALL update_error(.ret)
GOTO 10
END
END
;途中作業以降は先頭から実行
.l3num = 1
END
END
END
VALUE cmd_exe_gravity:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_GRAVITYADJ"
END
.mode = gs_gravity_mode
.setval = gs_gravity_setv
CALL gravityadj_core(robot_slave,.mode,.setval,.ret)
CALL update_error(.ret)
VALUE cmd_exe_vscalib:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VSCALIB"
END
.rno = gs_rno
.camno = gs_camno
.calno = gs_calno
.camtype = gs_camtype
POINT .target = gs_posxyzr1
.len = gs_len
.height = gs_height
POINT .tool_p = gs_toolp
CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
CALL update_error(.ret)
VALUE cmd_exe_vcalchk:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VCALCHK"
END
.rno = gs_rno
.camno = gs_camno
.height = gs_height
CALL vision_excalchk(.rno,.camno,.height,.ret)
CALL update_error(.ret)
VALUE cmd_exe_calxom:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_CALXOM"
END
.rno = gs_rno
.len = gs_len
.height = gs_height
CALL vis_execalxom(.rno,.len,.height,.ret)
CALL update_error(.ret)
VALUE cmd_exe_calyom:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_CALYOM"
END
.rno = gs_rno
.camno = gs_camno
.camtype = gs_camtype
POINT .target = gs_posxyzr1
.len = gs_len
.height = gs_height
POINT .tool_p = gs_toolp
CALL vis_execalyom(.rno,.camno,.camtype,.&target,.len,.height,.&tool_p,.ret)
CALL update_error(.ret)
VALUE cmd_exe_cchkom:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_CCHKOM"
END
.rno = gs_rno
.camno = gs_camno
.sceno = gs_calno
.height = gs_height
CALL vis_excalchkom(.rno,.camno,.sceno,.height,.ret)
CALL update_error(.ret)
ANY :
IF debug.prt.sub==ON THEN
PRINT "sub()-> Error occuerd. You try to execute unsupport command.OPE_COMMAND=",ope_command
END
.ret = err_cmd_type
END
10
;終了処理
;マスタープログラム終了検知までsubプログラムを終了しない(sub関数先頭ループ処理に検知実装有)
IF flg_main_run<>FALSE THEN
GOTO 999
ELSE
flg_slave_move = FALSE
END
flg_tablet_run[2] = FALSE
flg_main_run = FALSE
.END
.PROGRAM l2check(.l2num,.ret)
;-------------------------------- 
;機能：第2階層作業条件の成立チェック
;引数：無し
;戻値：成立した第2階層番号、成立有無(FALSE/TRUE)
;-------------------------------- 
.ret = FALSE
.l2num = -1
;.i=第2階層番号、.j=テーブル番号、.cnt=成立条件数
FOR .i = 1 TO data_l2num
.cnt = 0
IF data_l2exetblnu[.i]<=0 THEN
;実行条件なし
ELSE
;実行条件確認
FOR .j = 1 TO data_l2exetblnu[.i]
IF data_l2tbl_sign[.i,.j]=<3000 THEN
IF data_l2tbl_stat[.i,.j]==1 THEN
IF SIG(data_l2tbl_sign[.i,.j])==ON THEN
.cnt = .cnt+1
END
ELSE
IF SIG(data_l2tbl_sign[.i,.j])==OFF THEN
.cnt = .cnt+1
END
END
ELSE
IF data_l2tbl_stat[.i,.j]==1 THEN
IF data_l2status[data_l2tbl_sign[.i,.j]-3000]==TRUE THEN
.cnt = .cnt+1
END
ELSE
IF data_l2status[data_l2tbl_sign[.i,.j]-3000]==FALSE THEN
.cnt = .cnt+1
END
END
END
END
END
IF .cnt==data_l2exetblnu[.i] THEN
NOEXIST_SET_R data_l2workno[.i] = 0
IF (data_l2workno[.i]==data_cur_workno AND data_cur_workno<>0 AND data_wset_ena==1) OR data_wset_ena==0 THEN; 作業グループ番号一致または作業グルーピング設定無効
;実行条件成立
.l2num = .i
.ret = TRUE
RETURN
END
END
END
.END
.PROGRAM l2exec(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：第2階層実行
;引数：第2階層、第3階層
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()->.l2num=",.l2num,",.l3num=",.l3num
END
;コンベア固定ビジョンの品種ID切り替わりチェック
IF TASKNO==pg_master THEN
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
IF cv_vision[1]==1 OR cv_vision[2]==1 THEN ;コンベア固定ビジョン有り
NOEXIST_SET_R data_cv_vis[.l2num] = OFF
NOEXIST_SET_R data_cv_vid[.l2num] = 1
NOEXIST_SET_R data_cv_vrap[.l2num] = 10
NOEXIST_SET_R data_cv_voffset[.l2num] = 0
IF data_cv_vis[.l2num]==ON THEN ;第二階層固定ビジョン有効
IF cv_vision_id<>data_cv_vid[.l2num] THEN ;品種IDが前回と異なる
cv_vision_id = 0
flg_cvpc_stop = TRUE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cvpc_stop = FALSE
cv_norestart[pg_master] = TRUE
CALL update_error(err_cvpc_ready)
WAIT cv_norestart[pg_master]==FALSE
END
TWAIT ascycle
UNTIL (flg_cvpc_run==FALSE)
END
cv_rap = data_cv_vrap[.l2num]
cv_offset = data_cv_voffset[.l2num]
cv_vision_id = data_cv_vid[.l2num]
IF flg_cvpc_stop==TRUE THEN
flg_cvpc_stop = FALSE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
cv_norestart[pg_master] = TRUE
CALL update_error(err_cvpc_ready)
WAIT cv_norestart[pg_master]==FALSE
END
TWAIT ascycle
UNTIL (flg_cvpc_run<>FALSE)
END
END
END
END
END
FOR .i = .l3num TO data_l3num[.l2num]
;作業継続用情報更新
CALL updatel2l3info(TRUE,.l2num,.i,FALSE)
CALL exec_main(.l2num,.i,.ret)
IF (.ret<>err_no_error) OR ((g_last_error<>err_no_error) AND (g_last_error<>err_l3type_stop)) THEN
CASE .ret OF
VALUE err_slave_acten:
;戻り値：[内部制御用エラーコード]スレーブロボット並列作業完了検知
IF debug.prt.act==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> スレーブ作業完了しました .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
;作業継続用情報初期化(スレーブ単体)
CALL updatel2l3info(FALSE,-1,0,FALSE)
VALUE err_l3_actend:
;戻り値：[内部制御用エラーコード]RETURNコマンド検知
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURNコマンド検知 .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
;マスターロボット
IF TASKNO==pg_master THEN
IF sys_force_cmode==TRUE THEN
;協調中は協調解除
CALL exec_cend(.l2num,.l3num,.ret)
IF (.ret<>err_no_error) THEN
IF debug.prt.act==TRUE THEN
PRINT "detected error. tho.. sopping mainexe() .ret=",.ret
END
CALL update_error(.ret)
PRINT "TASKNO=",TASKNO,", 作業実行に失敗しました .ret=",.ret,",G_LAST_ERROR=",g_last_error
RETURN
END
END
;作業自体をRETURNする
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
END
.ret = err_no_error
sys_force_cmode = FALSE
flg_slave_paral = FALSE
RETURN
ELSE
;スレーブロボット動作のみRETURNする
IF debug.prt.l2exe==TRUE THEN
PRINT "TASKNO=",TASKNO,",l2exec()-> RETURN in .l2num=",.l2num,",.l3num=",.i
END
.ret = err_no_error
RETURN
END
VALUE err_bat_value:
PRINT "TASKNO=",TASKNO,", 範囲外の数値を設定した為作業が実行出来ませんでした .ret=",.ret,",G_LAST_ERROR=",g_last_error
;作業継続用情報初期化(マスター、スレーブ両方)
CALL updatel2l3info(FALSE,0,0,TRUE)
ANY :
PRINT "TASKNO=",TASKNO,", 作業実行に失敗しました .ret=",.ret,",G_LAST_ERROR=",g_last_error
END
RETURN
END
END
IF TASKNO==pg_master THEN
;第2階層条件起動用作業完了フラグON
data_l2status[.l2num] = TRUE
;コンベア同期予約ワーク番号クリア確認
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
UTIMER .@nowtime = 0
flg_cv_clear = TRUE
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cv_clear = FALSE
cv_norestart[pg_master] = TRUE
CALL update_error(err_cvpc_ready)
WAIT cv_norestart[pg_master]==FALSE
END
TWAIT ascycle
UNTIL (flg_cv_clear==FALSE)
END
END
;作業継続用情報初期化(マスター、スレーブ両方)
CALL updatel2l3info(FALSE,0,0,FALSE)
.END
.PROGRAM lp1()
sig1 = 0
sig2 = 0
sig3 = 0
sig4 = 0
sig5 = 0
sig6 = 0
WAIT sig1==1
JMOVE #lp1
L3LMOVE #lp2,1
DRIVE 3,72
DRIVE 3,1
sig2 = 1
WAIT sig3==1
; JMOVE #lp3
DRIVE 3,-90
JMOVE #lp3
DRIVE 3,-40
L3LMOVE #lp4,1
JMOVE #lp5
L3LMOVE #lp6,1
DRIVE 3,39
DRIVE 3,1
sig4 = 1
L3LMOVE #lp7,1
L3LMOVE #lp8,1
TIMER 1 = 0
WAIT TIMER(1)>=65
L3LMOVE #lp9,1
L3LMOVE #lp10,1
DRIVE 3,-65
L3LMOVE #lp11,1
L3LMOVE #lp12,1
sig5 = 1
.END
.PROGRAM m.kukei()
; /***********************************************************************
; FUNCTION: 協調矩形動作（マスター）
; ***********************************************************************/
;
CALL set_aux_all(50,1,100,100);速度/精度/加速度/減速度の設定
;正面XY平面での協調矩形動作
JMOVE #m.pos1
MASTER
BREAK
POINT .m_kukei = S_HERE(1)
POINT .s_kukei = S_HERE(2)
CALL set_aux_all(50,100,100,100);速度/精度/加速度/減速度の設定
FOR .i = 1 TO 1
MLZL3LMOVE SHIFT(.m_kukei BY 70,,70),1,1
MLZL3LMOVE SHIFT(.m_kukei BY 70,,-70),1,1
MLZL3LMOVE SHIFT(.m_kukei BY -70,,-70),1,1
MLZL3LMOVE SHIFT(.m_kukei BY -70,,70),1,1
END
ALONE
;正面XY平面での協調矩形動作
JMOVE #m.pos1
MASTER
POINT .m_kukei = S_HERE(1)
POINT .s_kukei = S_HERE(2)
CALL set_aux_all(50,100,50,50);速度/精度/加速度/減速度の設定
FOR .i = 1 TO 1
MLZL3LMOVE SHIFT(.m_kukei BY 150,150),1,1
MLZL3LMOVE SHIFT(.m_kukei BY 150,-150),1,1
MLZL3LMOVE SHIFT(.m_kukei BY -150,-150),1,1
MLZL3LMOVE SHIFT(.m_kukei BY -150,150),1,1
END
ALONE
.END
.PROGRAM m.main()
; /***********************************************************************
; FUNCTION: ダンスPGメイン（マスター）
; ***********************************************************************/
IF SIG(2300) THEN           ;ダンス実行フラグON
;    　 CALL m.kukei
CALL m.rotate
CALL m.reverse
;	SIGNAL -2300		;1回だけ実行するのでOFFにする
END
.END
.PROGRAM m.reverse()
; /***********************************************************************
; FUNCTION: 上下アームの姿勢逆転（マスター）
; ***********************************************************************/
;
CALL set_aux_all(50,1,100,100);速度/精度/加速度/減速度の設定
JMOVE #m.pos2
BREAK
SIGNAL 2301
WAIT SIG(-2301)
JMOVE #m.rot1
BREAK
SIGNAL 2301
WAIT SIG(-2301)
JMOVE #m.rot2
BREAK
SIGNAL 2301
WAIT SIG(-2301)
JMOVE #m.straight0
BREAK
SIGNAL 2301
WAIT SIG(-2301)
CALL set_aux_all(50,100,100,30);速度/精度/加速度/減速度の設定
JMOVE #m.straight1
JMOVE #m.straight2
JMOVE #m.straight3
JMOVE #m.straight4
CALL set_aux_all(50,100,100,100);速度/精度/加速度/減速度の設定
JMOVE #m.home
.END
.PROGRAM m.rotate()
; /***********************************************************************
; FUNCTION: 1軸90度ピッチ動作（マスター）
; ***********************************************************************/
;
CALL set_aux_all(50,5,100,100);速度/精度/加速度/減速度の設定
;0時方向
JMOVE #m.pos1
BREAK
POINT .m_rot = S_HERE(1)
POINT .m_rot1 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),-20)
POINT .m_rot2 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),20)
FOR .i = 1 TO 2
JMOVE .m_rot1
JMOVE .m_rot2
END
JMOVE .m_rot
;3時方向
MASTER
MLJMOVE #rot1
ALONE
BREAK
POINT .m_rot = S_HERE(1)
POINT .m_rot1 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),-82)
POINT .m_rot2 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),-42)
FOR .i = 1 TO 2
JMOVE .m_rot1
JMOVE .m_rot2
END
JMOVE .m_rot
;9時方向
MASTER
MLJMOVE #rot2
ALONE
BREAK
POINT .m_rot = S_HERE(1)
POINT .m_rot1 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),42)
POINT .m_rot2 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),82)
FOR .i = 1 TO 2
JMOVE .m_rot1
JMOVE .m_rot2
END
JMOVE .m_rot
;6時方向
MASTER
MLJMOVE #rot3
ALONE
BREAK
POINT .m_rot = S_HERE(1)
POINT .m_rot1 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),-200)
POINT .m_rot2 = TRANS(DEXT(.m_rot,1),DEXT(.m_rot,2),DEXT(.m_rot,3),-160)
FOR .i = 1 TO 2
JMOVE .m_rot1
JMOVE .m_rot2
END
JMOVE .m_rot
.END
.PROGRAM mahalka()
HOME
POINT p1 = HERE
POINT p2 = SHIFT(p1 BY 50,0,0)
start:
SPEED 20 ALWAYS
JMOVE p1
TWAIT 1
JMOVE p2
TWAIT 1
GOTO start
.END
.PROGRAM main() ;Communication main program
port = 52000
ip[0] = 192
ip[1] = 168
ip[2] = 0
ip[3] = 100
max_length = 255
tout_open = 5
tout_rec = 5
CALL open_socket;Connecting communication 
IF sock_id<0 THEN
GOTO exit_end
END
text_id = 0
tout = 60
eret = 0
rret = 0
$sdata[1] = "001"
CALL tcpsend(eret,$sdata[1]);Instructing processing 1 
IF eret<0 THEN
PRINT "CODE 001 ERROR END code=",eret
GOTO exit
END
CALL tcprecv;Receiving the result of processing 1 
IF rret<0 THEN
PRINT "CODE 001 RECV ERROR END code=",rret
GOTO exit
END
eret = 0
$sdata[1] = "002"
CALL tcpsend(eret,$sdata[1]);Instructing processing 2 
IF eret<0 THEN
PRINT "CODE 002 ERROR END code=",eret
GOTO exit
END
CALL tcprecv;Receiving the result of processing 2 
IF rret<0 THEN
PRINT "CODE 002 RECV ERROR END code=",rret
GOTO exit
END
exit:
CALL close_socket;Closing communication 
exit_end:
.END
.PROGRAM mainexe()
;-------------------------------- 
;機能：作業実行メインEXE(マスター側実行専用)
;引数：なし
;戻値：なし
;--------------------------------
FOR .i = 1 TO data_l2num
data_l2status[.i] = FALSE
END
IF disable_l2chk==TRUE THEN
;順次実行
;FLG_SLAVE_MOVE = FALSE
FOR .l2num = 1 TO data_l2num
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
END
ELSE
;第2階層条件チェック実行
;ループ処理はタイムアウト無し仕様のため非常停止ボタンを押して抜ける
IF flg_before_exec<>FALSE THEN
IF EXISTDATA("BEFORE_EXEC",G)==-1 THEN
CALL before_exec(.ret)
IF .ret<>err_no_error THEN
CALL update_error(.ret)
RETURN
END
END
END
WHILE (1) DO
DO
CALL l2check(.l2num,.ret)
IF .ret<>TRUE THEN
flg_l2chk_wait = TRUE
END
TWAIT ascycle
UNTIL (.ret==TRUE)
flg_l2chk_wait = FALSE
CALL l2exec(.l2num,1,.ret)
IF (.ret<>err_no_error) OR (g_last_error<>err_no_error) THEN
CALL update_error(.ret)
RETURN
END
IF data_wset_ena<>FALSE THEN
;作業グループ番号変更確認
CALL get_workno(.work_no,.ret)
IF .ret<>err_no_error OR data_cur_workno<>.work_no THEN
CALL update_error(err_work_unmatc)
RETURN
END
END
FOR .i = 1 TO 2
IF cur_cvcoop_no[.i]<>0 OR cur_cvcoop_wo[.i]<>0 OR cur_cvcoop_wono[.i]<>0 OR cv_norestart[.i]<>FALSE THEN
;コンベア同期中
cv_norestart[robot_master] = TRUE ;再開不可
CALL update_error(err_cvcoop)
WAIT cv_norestart[robot_master]==FALSE
END
END
TWAIT ascycle
END
END
.END
.PROGRAM make_cvpos(.rno,.#inpos2,.&inpos1,.#outpos,.ret)
;---------------------------------
;機能：コンベア同期教示点作成
;引数：コンベア値無各軸値、コンベア値有変換値
;戻値：コンベア値有各軸値、成否
;-------------------------------- 
.ret = err_no_error
DECOMPOSE .rno: .pos1[1] = .inpos1
DECOMPOSE .rno: .pos2[1] = .#inpos2
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
CASE .axis OF
VALUE 4:
POINT .rno: .#outpos = #PPOINT(.pos2[1],.pos2[2],.pos2[3],.pos2[4],.pos2[5],.pos2[6])
VALUE 5:
POINT .rno: .#outpos = #PPOINT(.pos2[1],.pos2[2],.pos2[3],.pos2[4],.pos2[5],.pos2[6],.pos2[7])
VALUE 6:
POINT .rno: .#outpos = #PPOINT(.pos2[1],.pos2[2],.pos2[3],.pos2[4],.pos2[5],.pos2[6],.pos2[7],.pos2[8])
VALUE 7:
POINT .rno: .#outpos = #PPOINT(.pos2[1],.pos2[2],.pos2[3],.pos2[4],.pos2[5],.pos2[6],.pos2[7],.pos2[8],.pos1[9])
VALUE 8:
POINT .rno: .#outpos = #PPOINT(.pos2[1],.pos2[2],.pos2[3],.pos2[4],.pos2[5],.pos2[6],.pos2[7],.pos2[8],.pos1[9],.pos1[10])
END
.END
.PROGRAM mh()
; *******************************************************************
;
; Program:      mh
; Comment:      
; Author:       User
;
; Date:         4/19/2019
;
; *******************************************************************
;
SPEED 50 ALWAYS
POINT p1 = HERE
POINT p2 = SHIFT(p1 BY 50,0,0)
JMOVE p2
.END
.PROGRAM monsp(.ret)
;-------------------------------- 
;機能：モニタ速度変更
;引数：速度
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.sp = VAL($prm[TASKNO,2])
IF .sp<=0 OR .sp>100 THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
data_monspeed[VAL($prm[TASKNO,1])] = .sp
IF VAL($prm[TASKNO,1])==robot_all THEN
IF debug.prt.cmd==TRUE THEN
PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,robot_master)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,robot_slave)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
END
MC SPEED ROBOT_MASTER: .sp
MC SPEED ROBOT_SLAVE: .sp
CALL wait_chg_sp(robot_master,.sp,.ret)
CALL wait_chg_sp(robot_slave,.sp,.ret)
ELSE
IF debug.prt.cmd==TRUE THEN
IF $prm[TASKNO,1]=="1" THEN
PRINT "TASKNO=",TASKNO,",Monitor Speed(MASTER)=",$ENCODE(SYSDATA(M.SPEED,robot_master)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
ELSE
PRINT "TASKNO=",TASKNO,",Monitor Speed(SLAVE)=",$ENCODE(SYSDATA(M.SPEED,robot_slave)),"->",$prm[TASKNO,2],",.rno=",$prm[TASKNO,1]
END
END
MC SPEED VAL($prm[TASKNO,1]): .sp
IF $prm[TASKNO,1]=="1" THEN
CALL wait_chg_sp(robot_master,.sp,.ret)
ELSE
CALL wait_chg_sp(robot_slave,.sp,.ret)
END
END
.END
.PROGRAM movepos(.rno,.#cvpos,.mode,.type,.#inpos,.bflag,.sp,.acc,.dec,.accu,.sp_mode,.cvno,.cvwork,.cvworkno,.ret)
;-------------------------------- 
;機能：指定位置移動
;引数：ロボット番号、ツール変換値、動作方法(.mode->0;JT、1:XYZR1EXT1)、補間方法(.type->0:LMOVE、1:JMOVE)、教示点構成要素(.data実数配列)、動作後BREAK有無、第3階層指定速度(ティーチ時などは0)
;引数：第3階層指定加速度、第3階層指定減速度、第3階層指定精度、第3階層指定速度モード(%／mm/sec)、同期コンベア番号、同期対象ワーク、開始/途中/終了
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
;位置情報生成
DECOMPOSE .temp_rno: .inpos[1] = .#inpos
DECOMPOSE .temp_rno: .cvpos[1] = .#cvpos
.axis = SYSDATA(ZROB.NOWAXIS,.temp_rno)
IF .mode==mode_jt THEN
CASE .axis OF
VALUE 4:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
VALUE 5:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7])
VALUE 6:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8])
VALUE 7:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8],.cvpos[1])
VALUE 8:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8],.cvpos[1],.cvpos[2])
ANY :
.ret = err_bad_axesno
RETURN
END
ELSE
CASE .axis OF
VALUE 4:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
VALUE 5:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7])
VALUE 6:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8])
VALUE 7:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8],.cvpos[1])
VALUE 8:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6],.inpos[7],.inpos[8],.cvpos[1],.cvpos[2])
ANY :
.ret = err_bad_axesno
RETURN
END
END
IF debug.prt.move==TRUE THEN
PRINT "->movepos() .rno=",.rno," ,TASKNO=",TASKNO
END
; 動作関連パラメータ設定
IF (TASKNO==robot_master AND (.rno==robot_all OR .rno==robot_master)) OR (TASKNO==robot_slave AND .rno==robot_slave) THEN
CALL chg_move_param(.sp_mode,.sp,.acc,.dec,.accu,.ret)
IF .ret<>err_no_error THEN
RETURN
END
END
;スレーブ制御用グローバル変数
IF .rno==robot_slave THEN
gs_mode = .mode
gs_type = .type
gs_bflag = .bflag
gs_sp = .sp
gs_accel = .acc
gs_decel = .dec
gs_accuracy = .accu
gs_sp_mode = .sp_mode
gs_cvworkno = .cvworkno
END
IF .rno==robot_all THEN
IF syn_mode_start==TRUE THEN
;協調モードに移行
CALL change_ms_mode(slave_timeout,.ret)
IF .ret<>err_no_error THEN
IF TASKNO==pg_master THEN
;終了処理
flg_req_mamode = FALSE
CALL exec_alone(.ret)
RETURN
END
END
END
END
IF .type==mode_jmove THEN
IF .mode==mode_jt THEN
;JMOVE/JT
DECOMPOSE .temp_rno: .d[1] = .#pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "->movepos() MODE_JMOVE JT[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
IF .cvworkno==FALSE THEN
MLJMOVE .#pos
ELSE
CVMLJMOVE .#pos,.cvworkno
END
VALUE robot_master:
IF .cvworkno==FALSE THEN
JMOVE .#pos
ELSE
CVJMOVE .#pos,,.cvworkno
END
VALUE robot_slave:
IF TASKNO==pg_master THEN
POINT .temp_rno: #g_mpos = .#pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(JMOVE/MODE_JT)"
END
DO
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
IF .cvworkno==FALSE THEN
JMOVE .#pos
ELSE
CVJMOVE .#pos,,.cvworkno
END
END
END
ELSE
;JMOVE/XYZR1EXT1
DECOMPOSE .temp_rno: .d[1] = .pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "->movepos() MODE_JMOVE XYZR1EXT1[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
MLJMOVE .#outpos
ELSE
CVMLJMOVE .#outpos,.cvworkno
END
VALUE robot_master:
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
JMOVE .#outpos;変換値指定はできない
ELSE
CVJMOVE .#outpos,,.cvworkno
END
VALUE robot_slave:
IF TASKNO==pg_master THEN
POINT .temp_rno: g_mpos = .pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(JMOVE/NOT MODE_JT)"
END
DO
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
JMOVE .#outpos;変換値指定はできない
ELSE
CVJMOVE .#outpos,,.cvworkno
END
END
END
END
ELSE
IF .mode==mode_jt THEN
;LMOVE/JT
DECOMPOSE .temp_rno: .d[1] = .#pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "->movepos() MODE_LMOVE JT[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
IF .cvworkno==FALSE THEN
MLZL3LMOVE .#pos,1,1
ELSE
CVMLL3LMOVE .#pos,1,.cvworkno
END
VALUE robot_master:
IF .cvworkno==FALSE THEN
ZL3LMOVE .#pos,1,1;引数は各軸値
ELSE
CVL3LMOVE .#pos,1,.cvworkno
END
VALUE robot_slave:
IF TASKNO==pg_master THEN
POINT .temp_rno: #g_mpos = .#pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(LMOVE/MODE_JT)"
END
DO
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
IF .cvworkno==FALSE THEN
ZL3LMOVE .#pos,1,1;引数は各軸値
ELSE
CVL3LMOVE .#pos,1,.cvworkno
END
END
END
ELSE
;LMOVE/XYZR1EXT1
DECOMPOSE .temp_rno: .d[1] = .pos
IF debug.prt.move==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "->movepos() MODE_LMOVE XYZR1EXT1[",.i,"]=",.d[.i]
END
END
CASE .rno OF
VALUE robot_all:
.rno = 1;マスターで制御する
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
MLZL3LMOVE .#outpos,1,1
ELSE
CVMLL3LMOVE .#outpos,1,.cvworkno
END
VALUE robot_master:
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 1: .#tpos=.p[1],#S_HERE(1),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
ZL3LMOVE .#outpos,1,1;引数は各軸値
ELSE
CVL3LMOVE .#outpos,1,.cvworkno
END
VALUE robot_slave:
IF TASKNO==pg_master THEN
POINT .temp_rno: g_mpos = .pos
;スレーブ動作実行
CALL slave_run(slave_timeout,.ret)
IF debug.prt.move==TRUE THEN
PRINT "(LMOVE/NOT MODE_JT)"
END
DO
TWAIT ascycle
UNTIL (flg_slave_move==FALSE)
IF debug.prt.move==TRUE THEN
PRINT "SLAVE action done."
END
ELSE
DECOMPOSE .temp_rno: .p[1] = .pos
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
CALL make_cvpos(.temp_rno,.#tpos,.&pos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
ZL3LMOVE .#outpos,1,1;引数は各軸値
ELSE
CVL3LMOVE .#outpos,1,.cvworkno
END
END
END
END
END
;コンベア同期動作でない場合、再開不可フラグOFF
IF .cvworkno==FALSE THEN
IF TASKNO==.rno THEN
cv_norestart[.rno] = FALSE
ELSE
IF .rno==robot_all THEN
cv_norestart[robot_master] = FALSE
END
END
END
; マスターロボットの動作中の作業番号を記憶
IF .rno==robot_master THEN
now_move_l3num[robot_master] = tmp_move_l3num[.rno]
IF sys_force_cmode==TRUE OR flg_slave_paral==FALSE THEN
now_move_l3num[robot_slave] = 0; 協調動作または単体動作の時はスレーブ側の記憶は消去
END
ELSE
IF TASKNO==robot_slave THEN
now_move_l3num[robot_slave] = tmp_move_l3num[.rno]; 並列動作の時のみスレーブロボットの動作中の作業番号も記憶
IF flg_slave_moved==FALSE THEN
flg_slave_moved = TRUE
END
END
END
IF .bflag==TRUE AND .rno==TASKNO THEN
BREAK
END
IF debug.prt.item==TRUE THEN
IF .mode==mode_jt THEN
PRINT "TASKNO=",TASKNO,", move()->Mode=",.mode,", Type=",.type,", JT1=",.d[1],", JT2=",.d[2],", JT3=",.d[3],", JT4=",.d[4],", JT5=",.d[5],", JT6=",.d[6],", Time=",$TIME
ELSE
PRINT "TASKNO=",TASKNO,", move()->Mode=",.mode,", Type=",.type,", X=",.d[1],", Y=",.d[2],", Z=",.d[3],", R1=",.d[4],", EXT1=",.d[5],", EXT2=",.d[6],", Time=",$TIME
END
END
.END
.PROGRAM nameset(.cmd,.ret)
;-------------------------------- 
;機能：名称設定コア
;引数：文字列配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF flg_mem_chk==TRUE THEN
IF SYSDATA(MEM.FREE)<=mem_min_value THEN
.ret = err_mem_value
RETURN
END
END
CASE .cmd OF
VALUE cmd_set_l1info:
$data_cur_l1name = $prm[TASKNO,2]
data_l2num = VAL($prm[TASKNO,3])
$data_load_time = $prm[TASKNO,4]
VALUE cmd_set_l2info:
$data_l2name[VAL($prm[TASKNO,2])] = $prm[TASKNO,3]
data_l3num[VAL($prm[TASKNO,2])] = VAL($prm[TASKNO,4])
data_l2exetblnu[VAL($prm[TASKNO,2])] = VAL($prm[TASKNO,5])
IF $prm[TASKNO,6]=="1234" THEN
data_l2workno[VAL($prm[TASKNO,2])] = 0
ELSE
data_l2workno[VAL($prm[TASKNO,2])] = VAL($prm[TASKNO,6])
END
VALUE cmd_set_l3info:
IF $prm[TASKNO,4]<>"" THEN
$data_l3name[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])] = $prm[TASKNO,4]
flg_noset_name = FALSE
ELSE
flg_noset_name = TRUE
END
VALUE cmd_set_winfo:
;作業グループ名称設定
.wno = VAL($prm[TASKNO,2])
IF .wno<1 OR max_worknum<.wno THEN
.ret = err_bad_ptype
ELSE
$data_workname[.wno] = $prm[TASKNO,3]
END
ANY :
.ret = err_bad_name
END
.END
.PROGRAM noexist_init()
.$appli_ver = $STR_ID(5)
.$appli_ver_chk = $LEFT(.$appli_ver,3)
IF .$appli_ver_chk=="ADU" THEN
NOEXIST_SET_R flg_pulse_io = FALSE
NOEXIST_SET_R zsw_submove_pul = FALSE
ELSE
NOEXIST_SET_R flg_pulse_io = TRUE
NOEXIST_SET_R zsw_submove_pul = TRUE
END
NOEXIST_SET_R debug.prt.sock = -1
NOEXIST_SET_R debug.prt.proc = -1
NOEXIST_SET_R debug.prt.act = -1
NOEXIST_SET_R debug.prt.cmd = -1
NOEXIST_SET_R debug.prt.core = -1
NOEXIST_SET_R debug.prt.main = -1
NOEXIST_SET_R debug.prt.sub = -1
NOEXIST_SET_R debug.prt.gen = -1
NOEXIST_SET_R debug.prt.com = -1
NOEXIST_SET_R debug.prt.func = -1
NOEXIST_SET_R debug.prt.visio = -1
NOEXIST_SET_R debug.prt.reboo = -1
NOEXIST_SET_R debug.prt.extio = -1
NOEXIST_SET_R debug.prt.pos = 0
NOEXIST_SET_R debug.prt.move = -1
NOEXIST_SET_R debug.prt.l2exe = -1
NOEXIST_SET_R debug.prt.log = 0
NOEXIST_SET_R debug.prt.item = 0
NOEXIST_SET_R debug.prt.sp = 0
NOEXIST_SET_R flg_start_reboo = 0
NOEXIST_SET_R flg_main_run = 0
NOEXIST_SET_R flg_direct_run = 0
NOEXIST_SET_R flg_master_move = 0
NOEXIST_SET_R flg_slave_move = 0
NOEXIST_SET_R flg_req_mamode = 0
NOEXIST_SET_R flg_slave_rdy = 0
NOEXIST_SET_R flg_slave_paral = 0
NOEXIST_SET_R flg_single_move = 0
NOEXIST_SET_R flg_restart = 0
NOEXIST_SET_R robot_status = 0
NOEXIST_SET_R robot_status_ou = 0
NOEXIST_SET_R g_last_error = 0
NOEXIST_SET_R flg_pc1stop = 0
NOEXIST_SET_R sys_force_cmode = 0
NOEXIST_SET_R syn_mode_start = 0
NOEXIST_SET_R extin_start_but = 0
NOEXIST_SET_R extin_stop_butt = 0
NOEXIST_SET_R extin_teach_tgl = 0
NOEXIST_SET_R extin_repeat_tg = 0
NOEXIST_SET_R gohome_ptn = 0
NOEXIST_SET_R chk_gohome[1] = 400
NOEXIST_SET_R chk_gohome[2] = 400
NOEXIST_SET_R chk_jt1_rad = 100
NOEXIST_SET_R chk_dist_here = 200
UTIMER @tim_aft_alone2[1] = 0
UTIMER @tim_aft_alone2[2] = 0
NOEXIST_SET_R cont_time = 0.5
FOR .i = 1 TO max_cntnum
NOEXIST_SET_R data_cntnum[.i] = 0
END
NOEXIST_SET_R flg_gravityadj_ = 0
NOEXIST_SET_R flg_enable_colc = 0
NOEXIST_SET_R poslimit_gen = 1
NOEXIST_SET_R poslimit_restar = 5
NOEXIST_SET_R no_restart_flg = FALSE
NOEXIST_SET_R slowlimit_ena = 1
NOEXIST_SET_R slowlimit_time = 5
NOEXIST_SET_R slowlimit_speed = 100
NOEXIST_SET_R debug_status = -1
NOEXIST_SET_R flg_iowait_debu = 0
NOEXIST_SET_R timeout_signum = 0
NOEXIST_SET_R flg_call_now[1] = 0
NOEXIST_SET_R flg_call_now[2] = 0
NOEXIST_SET_R flg_nonbreak[1] = OFF
NOEXIST_SET_R flg_nonbreak[2] = OFF
NOEXIST_SET_R flg_shift_move = FALSE
NOEXIST_SET_R z_vselect = 0
NOEXIST_SET_R data_teachpitch = 5
NOEXIST_SET_R data_teachrot = 5
NOEXIST_SET_R data_exttype[0] = 0
NOEXIST_SET_R data_exttype[1] = 0
NOEXIST_SET_R data_exttype[2] = 0
NOEXIST_SET_R data_teachcoord = 0
NOEXIST_SET_R data_toolcur[1] = 1
NOEXIST_SET_R data_toolcur[2] = 1
NOEXIST_SET_R data_acc = 100
NOEXIST_SET_R data_dec = 100
NOEXIST_SET_R data_accu = 1
NOEXIST_SET_R data_io_tablenu = 0
NOEXIST_SET_R data_monspeed[0] = 100
NOEXIST_SET_R data_monspeed[1] = 100
NOEXIST_SET_R data_monspeed[2] = 100
NOEXIST_SET_R data_l3speed = 0
FOR .i = 1 TO 2
FOR .j = 1 TO 6
NOEXIST_SET_R data_sa_gain[.i,.j] = 0
NOEXIST_SET_R sa_param[.i,.j] = 1
END
END
NOEXIST_SET_S $sa_param = "0,1,1,1,1,1,1,1,1,1,1,1,1"
IF LEN($sa_param)<>25 THEN
$sa_param = "0,1,1,1,1,1,1,1,1,1,1,1,1"
END
NOEXIST_SET_R sa_tool[1] = 1
NOEXIST_SET_R sa_tool[2] = 1
NOEXIST_SET_R mode_sa = 0
NOEXIST_SET_R data_execute = 0
NOEXIST_SET_R data_cur_l2disp = 0
NOEXIST_SET_R data_cur_l3disp = 0
NOEXIST_SET_R data_cur_l2rec[1] = 0
NOEXIST_SET_R data_cur_l2rec[2] = 0
NOEXIST_SET_R data_cur_l3rec[1] = 0
NOEXIST_SET_R data_cur_l3rec[2] = 0
NOEXIST_SET_R now_move_l3num[1] = 0
NOEXIST_SET_R now_move_l3num[2] = 0
NOEXIST_SET_R tmp_move_l3num[1] = 0
NOEXIST_SET_R tmp_move_l3num[2] = 0
NOEXIST_SET_R chg_bef_mspeed[1] = 0
NOEXIST_SET_R chg_bef_mspeed[2] = 0
NOEXIST_SET_R chg_aft_mspeed[1] = 0
NOEXIST_SET_R chg_aft_mspeed[2] = 0
NOEXIST_SET_R data_l2num = 0
NOEXIST_SET_R flg_noset_name = OFF
NOEXIST_SET_R flg_load_now = OFF
NOEXIST_SET_R flg_mem_chk = FALSE
NOEXIST_SET_R flg_slave_call = FALSE
NOEXIST_SET_L #dest_pos[1] = #PPOINT(9999,9999,9999,9999)
NOEXIST_SET_L #dest_pos[2] = #PPOINT(9999,9999,9999,9999)
NOEXIST_SET_R dest_mode[1] = 9999
NOEXIST_SET_R dest_mode[2] = 9999
NOEXIST_SET_R data_cur_workno = -999
NOEXIST_SET_R data_cur_maxnum = 0
NOEXIST_SET_R data_wset_ena = 0
NOEXIST_SET_R data_wset_spec = 0
NOEXIST_SET_R data_wset_set[1] = 0
NOEXIST_SET_R data_wset_set[2] = 0
NOEXIST_SET_R data_wset_no = 0
NOEXIST_SET_S $data_pgname = "MAINEXE"
NOEXIST_SET_S $data_cur_l1name = "NO SETTING"
NOEXIST_SET_S $data_load_time = "00000000000000"
FOR .rno = 1 TO 2
FOR .cvno = 1 TO 2
NOEXIST_SET_R cv_coopjt[.rno,.cvno] = 0;コンベア軸設定
NOEXIST_SET_R cv_coop_mode[.rno,.cvno] = 1;コンベア番号取得モード（1:同期開始/2:コンベア待ち/3:条件分岐）
NOEXIST_SET_R cv_need[.rno,.cvno] = 0;目標ワーク（先頭/2番目）フラグ
NOEXIST_SET_R cv_comp[.rno,.cvno] = 0;同期完了フラグ
END
NOEXIST_SET_R cur_cvcoop_no[.rno] = 0;同期中コンベア番号
NOEXIST_SET_R cur_cvcoop_wo[.rno] = 0;同期中対象ワーク
NOEXIST_SET_R cur_cvcoop_wono[.rno] = 0;同期中ワーク番号
END
FOR .cvno = 1 TO 2
FOR .work = 1 TO 2
NOEXIST_SET_R cv_work[.cvno,.work] = 0;ワーク番号
END
END
FOR .cvno = 1 TO 2
NOEXIST_SET_R cv_deg_o[.cvno] = 0;コンベア設置角度
NOEXIST_SET_R cv_deg_a[.cvno] = 0;コンベア設置角度
NOEXIST_SET_R cv_ulim[.cvno] = 0;コンベア上流範囲
NOEXIST_SET_R cv_llim[.cvno] = 0;コンベア下流範囲
NOEXIST_SET_R cv_vision[.cvno] = 0;コンベアビジョン(0:無し/1:固定/2:ハンドアイ)
NOEXIST_SET_R cv_work_pitch[.cvno] = 100;コンベアリセットピッチ
NOEXIST_SET_R cv_buff_num[.cvno] = 0;バッファ内ワーク数
NOEXIST_SET_R sw_auto_cvreset[.cvno] = ON
END
NOEXIST_SET_R cv_norestart[1] = 0;コンベア同期中再開不可フラグ（下アーム）
NOEXIST_SET_R cv_norestart[2] = 0;コンベア同期中再開不可フラグ（上アーム）
NOEXIST_SET_R flg_cvpc_stop = 0
NOEXIST_SET_R flg_cvpc_run = 0
NOEXIST_SET_R flg_cv_clear = 0
NOEXIST_SET_R cv_vision_id = OFF
NOEXIST_SET_R cv_rap = 10
NOEXIST_SET_R cv_offset = 0
NOEXIST_SET_R flg_cv_vision = OFF
NOEXIST_SET_R ope_command = 1999
NOEXIST_SET_R ope_commandpc = 1999
NOEXIST_SET_R ope_param[1] = 0
NOEXIST_SET_R ope_param[2] = 0
NOEXIST_SET_R ope_param[3] = 0
NOEXIST_SET_R ope_param[4] = 0
NOEXIST_SET_R ope_param[5] = 0
NOEXIST_SET_R ope_param[6] = 0
NOEXIST_SET_R ope_param[7] = 0
NOEXIST_SET_R ope_param[8] = 0
NOEXIST_SET_R ope_param[9] = 0
NOEXIST_SET_R ope_param[10] = 0
NOEXIST_SET_R ope_param[11] = 0
NOEXIST_SET_R ope_param[12] = 0
NOEXIST_SET_R ope_param[13] = 0
NOEXIST_SET_R ope_param[14] = 0
NOEXIST_SET_R ope_param[15] = 0
NOEXIST_SET_R ope_param[16] = 0
NOEXIST_SET_R ope_param[17] = 0
NOEXIST_SET_R ope_param[18] = 0
NOEXIST_SET_R ope_param[19] = 0
NOEXIST_SET_R ope_param[20] = 0
NOEXIST_SET_R ope_param[21] = 0
NOEXIST_SET_R ope_param[22] = 0
NOEXIST_SET_R ope_param[23] = 0
NOEXIST_SET_R mfp_param1 = 0
NOEXIST_SET_R mfp_param2 = 0
NOEXIST_SET_R mfp_param3 = 0
NOEXIST_SET_R mfp_param4 = 0
NOEXIST_SET_R mfp_param5 = 0
NOEXIST_SET_R mfp_param6 = 0
NOEXIST_SET_R mfp_param7 = 0
NOEXIST_SET_R mfp_param8 = 0
NOEXIST_SET_R mfp_param9 = 0
NOEXIST_SET_R mfp_param10 = 0
NOEXIST_SET_R mfp_param11 = 0
NOEXIST_SET_R mfp_param12 = 0
NOEXIST_SET_R mfp_param13 = 0
NOEXIST_SET_R mfp_param14 = 0
NOEXIST_SET_R mfp_param15 = 0
NOEXIST_SET_R mfp_param16 = 0
NOEXIST_SET_R mfp_param17 = 0
NOEXIST_SET_R mfp_param18 = 0
NOEXIST_SET_R mfp_param19 = 0
NOEXIST_SET_R mfp_param20 = 0
NOEXIST_SET_R mfp_param21 = 0
NOEXIST_SET_R mfp_param22 = 0
NOEXIST_SET_R mfp_param23 = 0
NOEXIST_SET_R tool_data_num[1] = 999
NOEXIST_SET_R tool_data_num[2] = 999
NOEXIST_SET_R data_hand_io[1,1] = 49
NOEXIST_SET_R data_hand_io[1,2] = 50
NOEXIST_SET_R data_hand_io[1,3] = 51
NOEXIST_SET_R data_hand_io[1,4] = 52
NOEXIST_SET_R data_hand_io[1,5] = 53
NOEXIST_SET_R data_hand_io[1,6] = 54
NOEXIST_SET_R data_hand_io[1,7] = 55
NOEXIST_SET_R data_hand_io[1,8] = 56
NOEXIST_SET_R data_hand_io[2,1] = 65
NOEXIST_SET_R data_hand_io[2,2] = 66
NOEXIST_SET_R data_hand_io[2,3] = 67
NOEXIST_SET_R data_hand_io[2,4] = 68
NOEXIST_SET_R data_hand_io[2,5] = 69
NOEXIST_SET_R data_hand_io[2,6] = 70
NOEXIST_SET_R data_hand_io[2,7] = 71
NOEXIST_SET_R data_hand_io[2,8] = 72
FOR .i = 1 TO 8
IF data_hand_io[1,.i]==0 THEN
data_hand_io[1,.i] = 49+(.i-1)
END
IF data_hand_io[2,.i]==0 THEN
data_hand_io[2,.i] = 65+(.i-1)
END
END
IF EXISTDATA("data_hand_type[1]",R)<>FALSE THEN
.handt1 = data_hand_type[1]
.handt2 = data_hand_type[2]
NOEXIST_SET_R data_hand_iotyp[1,1] = .handt1
NOEXIST_SET_R data_hand_iotyp[2,1] = .handt2
ELSE
NOEXIST_SET_R data_hand_iotyp[1,1] = 1
NOEXIST_SET_R data_hand_iotyp[2,1] = 1
END
NOEXIST_SET_R data_hand_iotyp[1,2] = 1
NOEXIST_SET_R data_hand_iotyp[1,3] = 1
NOEXIST_SET_R data_hand_iotyp[1,4] = 1
NOEXIST_SET_R data_hand_iotyp[2,2] = 1
NOEXIST_SET_R data_hand_iotyp[2,3] = 1
NOEXIST_SET_R data_hand_iotyp[2,4] = 1
IF EXISTDATA("DATA_HAND_CUR[1]",R)<>FALSE THEN
.handcur1 = data_hand_cur[1]
.handcur2 = data_hand_cur[2]
NOEXIST_SET_R data_hand_sta[1,1] = .handcur1
NOEXIST_SET_R data_hand_sta[2,1] = .handcur2
ELSE
NOEXIST_SET_R data_hand_sta[1,1] = 0
NOEXIST_SET_R data_hand_sta[2,1] = 0
END
NOEXIST_SET_R data_hand_sta[1,2] = 0
NOEXIST_SET_R data_hand_sta[1,3] = 0
NOEXIST_SET_R data_hand_sta[1,4] = 0
NOEXIST_SET_R data_hand_sta[2,2] = 0
NOEXIST_SET_R data_hand_sta[2,3] = 0
NOEXIST_SET_R data_hand_sta[2,4] = 0
NOEXIST_SET_R data_vs_tbnum = 3
UTIMER @lamp_flash = 0
NOEXIST_SET_R log_error_ena = -1
NOEXIST_SET_S $delimiter = "  "
NOEXIST_SET_R log_mode[1] = 1
NOEXIST_SET_R log_mode[2] = 1
NOEXIST_SET_R log_count[1] = 1
NOEXIST_SET_R log_count[2] = 1
NOEXIST_SET_R log_count[9] = 1
NOEXIST_SET_R log_max_num = 100
NOEXIST_SET_R zsw_mode_home = ON
NOEXIST_SET_R flg_geninit_set = FALSE;原点復帰オプション初期値設定完了フラグ
IF flg_geninit_set==FALSE THEN
IF zsw_mode_home==OFF AND EXISTDATA("gohome_mcr",G)==TRUE THEN
zsw_mode_home = -2
ELSEIF zsw_mode_home==OFF AND EXISTDATA("gohome_mcr",G)==FALSE THEN
zsw_mode_home = 0
ELSE
zsw_mode_home = -1
END
flg_geninit_set = TRUE
END
NOEXIST_SET_R zsw_man_intfoff = OFF
NOEXIST_SET_R flg_extin_gen = OFF
NOEXIST_SET_R flg_extin_resta = OFF
NOEXIST_SET_R flg_extin_start = OFF
NOEXIST_SET_R flg_extin_robot = OFF
NOEXIST_SET_R flg_extin_arese = OFF
NOEXIST_SET_R flg_extin_mrese = OFF
NOEXIST_SET_R flg_extin_aabor = OFF
NOEXIST_SET_R flg_extin_mabor = OFF
NOEXIST_SET_R flg_extin_tglsw = OFF
NOEXIST_SET_R flg_tglsw_chger = OFF
NOEXIST_SET_R flg_gohome_init = OFF
NOEXIST_SET_R flg_gohome_chk = OFF
NOEXIST_SET_R flg_gohome_comp = OFF
NOEXIST_SET_R flg_before_exec = OFF
NOEXIST_SET_R flg_tab_abort = OFF
NOEXIST_SET_R sw_extin_gena = OFF
NOEXIST_SET_R sw_extin_genm = OFF
NOEXIST_SET_R sig_extin_gen = 0
NOEXIST_SET_R sw_extin_start = OFF
NOEXIST_SET_R sig_extin_start = 0
NOEXIST_SET_R sw_extin_restar = OFF
NOEXIST_SET_R sig_extin_resta = 0
NOEXIST_SET_R sw_extin_robotm = OFF
NOEXIST_SET_R sig_extin_robot = 0
NOEXIST_SET_R sw_extin_reset = OFF
NOEXIST_SET_R sig_extin_reset = 0
NOEXIST_SET_R sw_extin_abort = OFF
NOEXIST_SET_R sig_extin_abort = 0
FOR .i = 0 TO robot_status_ma
NOEXIST_SET_R flg_extout_stat[.i] = OFF
NOEXIST_SET_R sig_extout_stat[.i] = 0
END
NOEXIST_SET_R flg_extout_tgls = OFF
NOEXIST_SET_R extout_repeat = 0
NOEXIST_SET_R extout_teach = 0
NOEXIST_SET_R flg_extout_home[1] = OFF;第一原点
NOEXIST_SET_R flg_extout_home[2] = OFF;第二原点
FOR .i = 1 TO 4
NOEXIST_SET_R sig_extout_home[.i] = 0
END
NOEXIST_SET_R flg_extout_vchk = OFF
NOEXIST_SET_R sig_extout_vchk = 0
NOEXIST_SET_R flg_vchk_done = FALSE;ビジョン準備完了出力済みフラグ
NOEXIST_SET_R flg_extout_emg = OFF
NOEXIST_SET_R sig_extout_emg = 0
.END
.PROGRAM oat2rpy(.#xyzoat,.#xyzrpy)
;-------------------------------- 
;機能：座標変換(OAT->RPY)
;引数：OAT
;戻値：RPY
;-------------------------------- 
;外部軸
;.xyzrpy[7]=.xyzoat[7]
DECOMPOSE .xyzoat[1] = .#xyzoat
;XYZOAT
.so = SIN(.xyzoat[4]+90)
.co = COS(.xyzoat[4]+90)
.sa = SIN(.xyzoat[5]-90)
.ca = COS(.xyzoat[5]-90)
.st = SIN(.xyzoat[6])
.ct = COS(.xyzoat[6])
.mat[0,0] = .co*.st-.sa*.ct*.so
.mat[1,0] = .so*.st+.sa*.ct*.co
.mat[2,0] = -.ca*.ct
.mat[3,0] = 0e+00
.mat[0,1] = .co*.ct+.sa*.st*.so
.mat[1,1] = .so*.ct-.sa*.st*.co
.mat[2,1] = .ca*.st
.mat[3,1] = 0e+00
.mat[0,2] = .ca*.so
.mat[1,2] = -.ca*.co
.mat[2,2] = -.sa
.mat[3,2] = 0e+00
.mat[0,3] = .xyzoat[1]
.mat[1,3] = .xyzoat[2]
.mat[2,3] = .xyzoat[3]
.mat[3,3] = 1
;XYZRPY
.xyzrpy[1] = .mat[0,3]
.xyzrpy[2] = .mat[1,3]
.xyzrpy[3] = .mat[2,3]
IF ABS(.mat[0,2])<1e-06 THEN
.xyzrpy[5] = 0e+00
.xyzrpy[4] = ATAN2(-.mat[1,2],.mat[2,2])
.xyzrpy[6] = ATAN2(-.mat[0,1],.mat[0,0])
IF ABS(.xyzrpy[6])<1e-06 THEN
.xyzrpy[6] = 0e+00
END
ELSE
.p = SQRT(.mat[0,0]*.mat[0,0]+.mat[0,1]*.mat[0,1])
IF ABS(.p)<1e-06 THEN
IF (.mat[0,2]>0e+00) THEN
.xyzrpy[5] = 90
ELSE
.xyzrpy[5] = -90
END
.xyzrpy[4] = 0e+00
.xyzrpy[6] = ATAN2(.mat[1,0],.mat[1,1])
ELSE
.xyzrpy[4] = ATAN2(-.mat[1,2],.mat[2,2])
.xyzrpy[5] = ATAN2(.mat[0,2],.p)
.xyzrpy[6] = ATAN2(-.mat[0,1],.mat[0,0])
END
END
POINT .#xyzrpy = #PPOINT(.xyzrpy[1],.xyzrpy[2],xyzrpy[3],.xyzrpy[4],.xyzrpy[5],.xyzrpy[6])
.END
.PROGRAM open_socket() ;Starting c ommunication
er_count = 0
listen:
TCP_LISTEN retl,port
IF retl<0 THEN
IF er_count>=5 THEN
PRINT "Connection with PC is failed (LISTEN). Program is stopped."
sock_id = -1
GOTO exit
ELSE
er_count = er_count+1
PRINT "TCP_LISTEN error=",retl,"    error count=",er_count
GOTO listen
END
ELSE
PRINT "TCP_LISTEN OK ",retl
END
er_count = 0
accept:
TCP_ACCEPT sock_id,port,tout_open,ip[1]
IF sock_id<0 THEN
IF er_count>=5 THEN
PRINT "Connection with PC is failed (ACCEPT). Program is stopped."
TCP_END_LISTEN ret,port
sock_id = -1
ELSE
er_count = er_count+1
PRINT "TCP_ACCEPT error id=",sock_id,"  error count=",er_count
GOTO accept
END
ELSE
PRINT "TCP_ACCEPT OK id=",sock_id
END
exit:
.END
.PROGRAM pc3_handshake(.sig_no)
; FUNCTION: ハンドシェイク待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
WHILE SIG(-.sig_no) DO
TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
END
SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc3_sig_change(.res,.sig_no,.timeout)
; FUNCTION: タイムアウト付き信号状態変更待ち[PC3]
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(.sig_no) GOTO end
TWAIT ascycle;                           信号の状態変更待ち
UNTIL UTIMER(.@vtime)>=.timeout;           タイムアウトするまで
.res = -1
end:
.END
.PROGRAM pc3_tcp_recv(.tcp_sock,.timeout)
; FUNCTION: TCP/IP通信 受信
; NOTE    : ver1.0.0[12/10/19]
; TCP_RECV 実行結果,ｿｹｯﾄID,受信文字列変数配列,配列数,ﾀｲﾑｱｳﾄ時間,1要素長
TCP_RECV .vstatus_recv,.tcp_sock,.$rcv_buf[0],vrecv_num,.timeout,vrecv_str_num
IF .vstatus_recv<0 THEN
PRINT /X2,"!!TCP_RECV error in pc3_tcp_recv : ",/I6,.vstatus_recv
CALL pc3_vcom_error(err_vis_recv,"TCP Recv Error")
v.com_error = verr_recv
ELSE
IF vrecv_num>0 THEN
FOR .i = 0 TO vrecv_num-1
IF vcontrol_char<0 THEN
$vrecv_data[.i] = .$rcv_buf[.i]
ELSE
$vrecv_data[.i] = $DECODE(.$rcv_buf[.i],$CHR(vcontrol_char),0); 制御文字削除
END
END
IF tcp_debug==1 THEN
PRINT /X2,">>TCP_RECV OK : [",$vrecv_data[0],"]"
END
ELSE
PRINT /X2,"TCP_RECV error in TCP_RECV"
END
END
.END
.PROGRAM pc3_tcp_sclose(.tcp_sock)
; FUNCTION: TCP/IP通信 ソケットの切断（クライアント側）
; NOTE    : ver1.0.0[12/10/19]
close:
IF .tcp_sock>0 THEN;                       ソケットがオープンしている場合
TCP_CLOSE .tcp_close,.tcp_sock;          ソケットクローズ処理
IF .tcp_close<0 THEN;                    処理エラー
PRINT /X2,"TCP_CLOSE error : id=",/I2,.tcp_sock
TCP_CLOSE .ret,.tcp_sock;              強制終了
IF .ret<0 THEN
PRINT /X2,"!!TCP_CLOSE retry error : id=",/I2,.tcp_sock
v.com_error = verr_socket
END
ELSE
IF tcp_debug==1 THEN
PRINT /X2,"<>TCP_CLOSE OK : [id=",/I2,.tcp_sock,"]"
END
END
END
.tcp_sock = -1
.END
.PROGRAM pc3_tcp_send(.tcp_sock,.timeout)
; FUNCTION: TCP/IP通信 送信
; NOTE    : ver1.0.0[12/10/19]
IF vcontrol_char<0 THEN
.$snd_buf[0] = $vsend_data[0]
ELSE
.$snd_buf[0] = $vsend_data[0]+$CHR(vcontrol_char); 制御文字追加
END
; TCP_SEND 実行結果,ｿｹｯﾄID,送信文字列変数配列,配列数,ﾀｲﾑｱｳﾄ時間
TCP_SEND .vstatus_send,.tcp_sock,.$snd_buf[0],vsend_num,.timeout
IF .vstatus_send<0 THEN
PRINT /X2,"!!TCP_SEND error in pc3_tcp_send : ",/I6,.vstatus_send
CALL pc3_vcom_error(err_vis_send,"TCP Send Error")
v.com_error = verr_send
ELSE
IF tcp_debug==1 THEN
PRINT /X2,"<<TCP_SEND OK : [",$vsend_data[0],"]"
END
END
.END
.PROGRAM pc3_tcp_sopen(.tcp_port,.tcp_sock)
; FUNCTION: TCP/IP通信 ソケットの生成（クライアント側）
; NOTE    : ver1.0.0[13/01/31]
.err_count = 0;                            エラーカウンタ
.retry_count = 1;                          生成リトライ回数
.timeout_connect = 1;                      接続要求受信待ち(TCP_ACCEPT)監視待ち時間(秒)
init:
.tcp_cnt = 0
.al_open = 0;                              ソケットの状態
TCP_STATUS .tcp_cnt,.port1[0],.sock1[0],.err1[0],.sub1[0],.$ip_add1[0]
IF .tcp_cnt==0 GOTO connect
FOR .i = 0 TO .tcp_cnt-1
IF .port1[.i]==.tcp_port THEN
.tcp_sock = .sock1[.i]
IF sock_notclose==1 THEN
.al_open = 1
IF tcp_debug==1 THEN
PRINT "ALREADY OPEN-> Port:",.port1[.i]," Socket:",.sock1[.i]," IP:",.$ip_add1[.i]
END
ELSE
IF tcp_debug==1 THEN
PRINT "CLOSE-> Port:",.port1[.i]," Socket:",.sock1[.i]," IP:",.$ip_add1[.i]
END
CALL pc3_tcp_sclose(.tcp_sock);        ソケットクローズ
END
END
END
IF sock_notclose==0 THEN
.tcp_sock = -1;                            ソケット番号初期化
END
connect:
IF .al_open==0 THEN
TCP_CONNECT .tcp_sock,.tcp_port,vsend_ip[0],.timeout_connect
END
IF .tcp_sock<0 THEN
IF .err_count>=.retry_count THEN
PRINT /X2,"!!TCP_CONNECT error in pc3_tcp_sopen : ",.tcp_sock
v.com_error = verr_socket
ELSE
.err_count = .err_count+1
IF tcp_debug==1 THEN
PRINT /X2,"TCP_CONNECT error : id=",/I6,.tcp_sock," err count=",/I1,.err_count
END
GOTO connect
END
ELSE
IF tcp_debug==1 THEN
PRINT /X2,"<>TCP_CONNECT OK : [port/",/I5,.tcp_port," socket/",/I2,.tcp_sock,"]"
END
END
.END
.PROGRAM pc3_vcom_ackchk(.$vack_data)
; FUNCTION: ACK確認
; NOTE    : ver1.0.0[12/11/22]
RETURN
.END
.PROGRAM pc3_vcom_error(.err,.$res)
; FUNCTION: エラーコード＆内容セット[PC3]
; NOTE    : ver1.0.0[14/02/24]
v.com_err = .err
$vcom_res = .$res
PRINT /X2,$vcom_res," in pc3_vcom_send : ",v.com_err;エラー内容表示
CALL pc3_vcom_log(1,.$res);                ログ保存
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc3_vcom_log(.class,.$string)
; FUNCTION: ログ作成[PC3]
; NOTE    : ver1.0.0[14/02/24]
IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
.$log = $DATE(3)+" "+$TIME+" [pc3_vcom_send] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
$vlog[1,vlog_cnt[1]] = .$log;            ログデータ保存
vlog_cnt[1] = vlog_cnt[1]+1;             ログカウンタカウントアップ
IF vlog_cnt[1]>vlog_max THEN;            ログカウンタ上限超えの為リセット
vlog_cnt[1] = 1
END
END
.END
.PROGRAM pc3_vcom_send()
; FUNCTION: UDP/IP通信 送信[PC3]
; NOTE    : ver1.0.0[14/03/06]
v.com_err = verr_init;                     通信結果クリア(変数定義用)
$vcom_res = "";                            エラー内容クリア(変数定義用)
SIGNAL -ix_vcomm_comp,-ix_vcomm_error;     通信完了信号＆通信エラー信号ＯＦＦ
SIGNAL -ix_vcomm_start,-ix_vcomm_busy;     通信開始信号＆通信中信号ＯＦＦ
CALL pc3_vcom_log(0,"送信ＰＧ起動")
SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
CALL pc3_vcom_log(0,"通信開始信号待ち...")
CALL pc3_handshake(ix_vcomm_start);        通信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
IF SIG(ix_vsend_only) AND SIG(ix_vrecv_only) THEN
CALL pc3_vcom_error(verr_onlymode,"片方向通信モードエラー");片方向通信モードエラー
HALT;                                    停止(片方向通信モードエラー)
END
CALL pc3_vcom_log(0,"通信開始")
SIGNAL ix_vcomm_busy;                      通信中信号ＯＮ
IF SIG(ix_vsend_only) GOTO start;          送信のみ信号ＯＮ時は受信ＰＧ起動確認なし
CALL pc3_vcom_log(0,"受信ＰＧ起動確認")
IF TASK(1004)<>1 THEN;                     受信ＰＧ起動確認
CALL pc3_vcom_log(0,"受信ＰＧ起動実行")
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 4: pc4_vcom_recv;              受信ＰＧ起動
CALL pc3_vcom_log(0,"受信ＰＧ起動完了待ち...")
CALL vchk_pc_start(.chk,1004);           受信ＰＧ[PC4]起動確認
IF .chk!=0 THEN
CALL pc3_vcom_error(verr_timeout3,"受信ＰＧ起動待ちタイムアウトエラー");受信ＰＧ待ちタイムアウトエラー
HALT;                                  停止(受信ＰＧ起動待ちタイムアウトエラー)
END
END
CALL pc3_vcom_log(0,"受信ＰＧ起動確認完了")
start:; 送受信開始
v.com_err = verr_init;                     通信結果クリア
$vcom_res = "";                            エラー内容クリア
IF SIG(ix_vsend_only) GOTO send;           送信のみ信号ＯＮ時は受信ＰＧ起動なし
SIGNAL -ix_vrecv_comp,ix_vrecv_start;      受信完了信号ＯＦＦ＆受信開始信号ＯＮ
CALL pc3_vcom_log(0,"受信開始待ち...")
CALL pc3_sig_change(.chk,-ix_vrecv_start,vhandshake_time);受信開始信号ＯＦＦ待ち
IF .chk!=0 THEN
CALL pc3_vcom_error(verr_timeout1,"受信開始待ちタイムアウトエラー");受信開始待ちタイムアウトエラー
HALT;                                    停止(受信開始待ちタイムアウトエラー)
END
IF SIG(ix_vrecv_only) GOTO recv;           受信のみ信号ＯＮ時は送信なし
send:; 送信
CALL pc3_vcom_log(0,"送信開始")
UDP_SENDTO .vstatus_send,vsend_ip[0],vsend_port,$vsend_data[0],vsend_num,vsend_timeout
IF .vstatus_send<>0 THEN;                  送信ステータス確認
.$log = "送信エラー : "+$ENCODE(/I6,.vstatus_send)+" // "+$vsend_data[0]
CALL pc3_vcom_error(verr_send,.$log);    送信エラー
HALT;                                    停止(送信エラー)
ELSE
.$log = "送信完了 ["+$ENCODE(/I2,vsend_num)+"] -> "+$vsend_data[0]
CALL pc3_vcom_log(0,.$log)
END
IF SIG(ix_vsend_only) GOTO end;            送信のみ信号ＯＮ時は受信完了待ちなし
recv:; 受信
CALL pc3_vcom_log(0,"受信完了待ち...")
CALL pc3_sig_change(.chk,ix_vrecv_comp,vrecv_timeout+1);受信完了信号ＯＮ待ち
IF .chk!=0 THEN
IF v.com_err==verr_init THEN
CALL pc3_vcom_error(verr_timeout2,"受信完了待ちタイムアウトエラー : "+$vsend_data[0]);受信完了待ちタイムアウトエラー
END
HALT;                                    停止(受信完了待ちタイムアウトエラー)
END
end:; 通信完了処理
CALL pc3_vcom_log(0,"通信完了")
v.com_err = verr_ok
SIGNAL -ix_vcomm_busy,ix_vcomm_comp;       通信中信号ＯＦＦ＆通信完了信号ＯＮ
GOTO loop
.END
.PROGRAM pc4_handshake(.sig_no)
; FUNCTION: ハンドシェイク待ち[PC4]
; NOTE    : ver1.0.0[12/10/18]
WHILE SIG(-.sig_no) DO
TWAIT ascycle;                           フラグ(信号)ＯＮ待ち
END
SIGNAL -.sig_no;                           フラグ(信号)ＯＦＦ
.END
.PROGRAM pc4_vcom_error(.err,.$res)
; FUNCTION: エラーコード＆内容セット[PC4]
; NOTE    : ver1.0.0[14/02/24]
v.com_err = .err
$vcom_res = .$res
PRINT /X2,$vcom_res," in pc4_vcom_recv : ",v.com_err;エラー内容表示
CALL pc4_vcom_log(1,.$res);                ログ保存
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM pc4_vcom_log(.class,.$string)
; FUNCTION: ログ作成[PC4]
; NOTE    : ver1.0.0[14/02/24]
IF vlog==2 OR (vlog==1 AND .class<>0) THEN;保存確認
.$log = $DATE(3)+" "+$TIME+" [pc4_vcom_recv] "+$ENCODE(/I,v.com_err)+" : "+.$string;ログデータ作成
$vlog[2,vlog_cnt[2]] = .$log;            ログデータ保存
vlog_cnt[2] = vlog_cnt[2]+1;             ログカウンタカウントアップ
IF vlog_cnt[2]>vlog_max THEN;            ログカウンタ上限超えの為リセット
vlog_cnt[2] = 1
END
END
.END
.PROGRAM pc4_vcom_recv()
; FUNCTION: UDP/IP通信 受信[PC4]
; NOTE    : ver1.0.0[14/02/24]
SIGNAL -ix_vrecv_start,-ix_vrecv_comp;     受信開始信号＆受信完了信号ＯＦＦ
CALL pc4_vcom_log(0,"受信ＰＧ起動")
SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
CALL pc4_handshake(ix_vrecv_start);        受信開始信号ＯＮ待ち(確認後信号ＯＦＦ)
CALL pc4_vcom_log(0,"受信開始")
UDP_RECVFROM .vstatus_recv,vrecv_port,$vrecv_data[0],vrecv_num,vrecv_timeout,vrecv_ip[0],vrecv_str_num
IF .vstatus_recv<>0 THEN;                  受信ステータス確認
IF v.com_err==verr_init THEN
.$log = "受信エラー : "+$ENCODE(/I6,.vstatus_recv)
CALL pc4_vcom_error(verr_recv,.$log);  受信エラー
END
HALT;                                    停止(受信エラー)
ELSE
.$log = "受信完了 ["+$ENCODE(/I2,vrecv_num)+"] <- "+$vrecv_data[0]
CALL pc4_vcom_log(0,.$log)
END
SIGNAL ix_vrecv_comp;                      受信完了信号ＯＮ
GOTO loop
.END
.PROGRAM pccom()
;-------------------------------- 
;機能：通信制御(動作プログラム実行用)
;-------------------------------- 
IF mode_ctype==mode_tcp THEN
;TCPポート接続、再接続
CALL tcp_open(0,.ret)
END
;外部制御盤からの操作機能を追加するが、通信バッファ溜まり防止のため通信ループは常時回す
CALL getcmd(.num,.ret)
IF .ret==0 THEN
IF SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
;タブレット操作許可、ボタン操作禁止
CALL pccomcore(FALSE,.num,.ret)
ELSE
;ｴﾗｰﾘｾｯﾄ以外のタブレット操作禁止、ボタン操作許可
IF (VAL($prm[TASKNO,0])==cmd_exe_reset) THEN
CALL pccomcore(FALSE,.num,.ret)
GOTO 10
END
;操作パネルのティーチ／リピート入力が不正な場合はエラー応答
IF (SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==ON) OR (SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==OFF) THEN
.ret = err_extio_unkno
CALL update_error(.ret)
ELSE
;外部制御盤操作中エラー応答
.ret = err_extio_disab
END
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
END
ELSE
;タブレット操作禁止、ボタン操作許可
;通信処理乗っ取りコマンド実行
CALL chk_extin(.status,.num)
IF .status==TRUE THEN
;入力検知
IF (VAL($prm[TASKNO,0])<>cmd_exe_reset) AND (g_last_error<>err_no_error) THEN
;エラー発生中はエラーリセットしか受け付けない
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccom:extin()-> Cannot execute command=",VAL($prm[TASKNO,0]),",G_LAST_ERROR=",g_last_error
END
GOTO 10
END
;コマンド種類(動作、非動作)に併せた実行方法が必要
CASE VAL($prm[TASKNO,0]) OF
VALUE cmd_exe_start,cmd_exe_reset,cmd_exe_gen:
IF (flg_master_move==TRUE OR flg_slave_move==TRUE) THEN
IF debug.prt.com==TRUE THEN
PRINT "pccom()-> Can not execute command,Because still moving any robot."
END
GOTO 10
END
;動作系コマンドのためPCCOMのように動作プログラム(main関数)経由で実行する
CALL pccomcore(TRUE,.num,.ret)
VALUE cmd_exe_restart:
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
;コマンド実行
CALL cmdmain(cmd_exe_restart,.$res,.ret)
VALUE cmd_exe_abort:
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
CALL cmdabort(.ret)
VALUE cmd_exe_robotmo:
IF (robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE) THEN
;操作禁止
ELSE
;非動作系コマンドのためPCCOMPCのように通信プログラムで実行しないとMCコマンド使用箇所でエラーが発生する
CALL cmdchgrobotmode(.ret)
END
ANY :
IF debug.prt.com==TRUE THEN
PRINT "pccom()-> Not Support command for extin_ctl()"
END
END
END
END
10
;再起動プログラムが停止している場合に自動再起動する
IF (TASK(1001)<>1) THEN
IF flg_pc1stop==FALSE THEN
UTIMER .@pc1stop_timer = 0
END
flg_pc1stop = TRUE
IF UTIMER(.@pc1stop_timer)>pc1stop_time THEN
PCEXECUTE rebootsystem
PRINT ".......Restart rebootsystem() in task 1001(PC-PROGRAM no.1)"
END
ELSE
flg_pc1stop = FALSE
UTIMER .@pc1stop_timer = 0
END
;エラー発生時はログに残す
IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
CALL error_log(.ret)
END
.END
.PROGRAM pccomcore(.flg_force,.num,.ret)
;-------------------------------- 
;機能：通信制御(動作プログラム実行用、コマンド受信後の処理)
;-------------------------------- 
;コマンド受信有り
.$res = ""
;コマンドを取得する
FOR .i = 1 TO .num
$ope_param[.i] = $prm[TASKNO,.i]
$prm[pg_master,.i] = $prm[TASKNO,.i]
END
;動作命令系コマンドのみ実行する
IF .flg_force==FALSE THEN
IF cmd_exec_type[VAL($prm[TASKNO,0])]==cmd_type_pcpg THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
END
GOTO 10
END
END
;エラー発生中はエラーリセットコマンド以外はエラー応答する
IF (VAL($prm[TASKNO,0])<>cmd_exe_reset) AND (g_last_error<>err_no_error) THEN
.ret = g_last_error
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccomcore()-> Cannot execute command=",VAL($prm[TASKNO,0]),",G_LAST_ERROR=",g_last_error
END
GOTO 10
END
;リセット操作を受付ける(タブレットがポート変更するまでの暫定)
;ﾀﾞｲﾚｸﾄ/ﾀﾌﾞﾚｯﾄﾓｰﾄﾞ中はｴﾗｰﾘｾｯﾄ受け付けない
;サイクル中はｴﾗｰﾘｾｯﾄ受け付けない
IF VAL($prm[TASKNO,0])==cmd_exe_reset AND flg_start_reboo==FALSE AND robot_mode_flg==FALSE THEN
IF SWITCH(CS ,1)==OFF AND SWITCH(CS ,2)==OFF THEN
IF flg_master_move==FALSE AND flg_slave_move==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Start execute reset-command."
END
IF (g_last_error==err_bad_positio) AND (disable_readj_p==TRUE) THEN
flg_enable_stop = FALSE
END
;status_check()でエラーを起こさないようにする
CALL reset_error(.ret)
ELSE
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Can not start execute reset-command,because robot is busy."
END
.ret = err_robot_busy
END
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
END
;コマンド実行可能条件が未成立はエラー応答する
;ロボット動作中にOPE_COMMANDを更新するとエラーになるため受信文字列で判定する
CALL check_exec_cmd(VAL($prm[TASKNO,0]),.flg_exec_cmd)
IF .flg_exec_cmd==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Result of judgement by check_exec_cmd() is not authorizing."
END
.ret = err_robotmode
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
;OPE_COMMAND更新タイミング注意
ope_command = VAL($prm[TASKNO,0])
;プログラム実行要否判定後に自動的にプログラムを実行する
CALL exec_pg(.ret)
IF .ret<>err_no_error THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Can not execute program(exec_pg(.ret))."
END
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;動作プログラム(main関数)未実行状態中はエラー応答する
IF flg_main_run==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() Not ready for main-program(FLG_MAIN_RUN==FALSE)."
END
.ret = err_main_start
CALL sendresp(ope_command,"",.ret)
END
;コマンド実行中はエラー応答する
IF flg_master_move==TRUE THEN
;動作中エラー応答
.ret = err_robot_busy
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;動作プログラム起動中はエラー応答する
IF flg_start_reboo==TRUE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccomcore() REBOOTING...."
END
.ret = err_robot_busy
CALL sendresp(ope_command,"",.ret)
GOTO 10
END
;コマンドを実行する
flg_master_move = TRUE
;コマンド種別が終了確認タイプで無ければ実行完了応答する
IF cmd_wait_type[ope_command]==cmd_type_no_wai THEN
.ret = err_no_error
CALL sendresp(ope_command,"",.ret)
END
10
.END
.PROGRAM pccompc()
;-------------------------------- 
;機能：通信制御(非動作プログラム実行用)
;-------------------------------- 
IF mode_ctype==mode_tcp THEN
;TCPポート接続、再接続
CALL tcp_open(0,.ret)
END
CALL getcmd(.num,.ret)
IF .ret==0 THEN
IF (flg_tab_abort<>FALSE) AND (VAL($prm[TASKNO,0])==cmd_exe_abort) THEN
;AUTO時タブレットから停止無効
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
.ret = err_robotmode
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
END
;コマンド受信有り
.$res = ""
;コマンドを取得する
;        FOR .i=1 TO .num
;            $OPE_PARAMPC[.i]=$prm[TASKNO,.i]
;        END
;操作パネルのティーチ／リピート入力が不正な場合はエラー応答
IF (SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==ON) OR (SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==OFF) THEN
CASE VAL($prm[TASKNO,0]) OF
VALUE cmd_exe_gen,cmd_exe_start,cmd_exe_l2exe,cmd_exe_gravity,cmd_exe_vscalib,cmd_exe_teach,cmd_exe_move,cmd_exe_restart,cmd_exe_robotmo:
.ret = err_extio_unkno
CALL update_error(.ret)
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
END
CALL check_exec_cmd(VAL($prm[TASKNO,0]),.flg_exec_cmd)
IF .flg_exec_cmd==FALSE THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccompc() Result of judgement by check_exec_cmd() is not authorizing."
END
.ret = err_robotmode
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
IF (SIG(extin_teach_tgl)==OFF) AND (SIG(extin_repeat_tg)==ON) AND ((VAL($prm[TASKNO,0])==cmd_exe_restart) OR (VAL($prm[TASKNO,0])==cmd_exe_robotmo)) THEN
IF debug.prt.com==TRUE THEN
PRINT "pccompc()-> (SIG(EXTIN_TEACH_TGLSW)==OFF) AND (SIG(EXTIN_REPEAT_TGLSW)==ON) AND ((VAL($prm[TASKNO,0])==CMD_EXE_RESTART) OR (VAL($prm[TASKNO,0])==CMD_EXE_ROBOTMODE))"
END
.ret = err_robotmode
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
GOTO 10
END
ope_commandpc = VAL($prm[TASKNO,0])
;非動作命令系のみ実行する
IF cmd_exec_type[ope_commandpc]==cmd_type_monpg THEN
IF debug.prt.com==TRUE THEN
PRINT "->pccompc() Try execute by Bad command-type(CMD_EXEC_TYPE[OPE_COMMAND]==CMD_TYPE_PCPG)."
END
GOTO 10
END
;プログラムを実行要否判定後に自動的にプログラムを実行する
IF (ope_commandpc==cmd_exe_restart) OR (ope_commandpc==cmd_exe_robotmo) THEN
IF g_last_error<>err_no_error THEN
.ret = g_last_error
CALL sendresp(VAL($prm[TASKNO,0]),"",.ret)
IF debug.prt.com==TRUE THEN
PRINT "TASKNO=",TASKNO,",pccompc()-> Cannot execute command=",ope_commandpc,",G_LAST_ERROR=",g_last_error
END
GOTO 10
ELSE
IF ope_commandpc==cmd_exe_restart THEN
IF .ret<>err_no_error THEN
CALL sendresp(ope_commandpc,"",.ret)
GOTO 10
END
END
END
END
;コマンド実行
CALL cmdmain(ope_commandpc,.$res,.ret)
CALL sendresp(ope_commandpc,.$res,.ret)
END
10
;エラー発生時はログに残す
IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
CALL error_log(.ret)
END
.END
.PROGRAM rdyboot(.flg_motor,.ret)
;-------------------------------- 
;動作プログラム実行(再起動)準備、モータ停止状態遷移
;引数：準備にモータ電源ON処理含む(TRUE/FALSE)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
;エラー状態を一旦解除する
.bak_error = g_last_error
g_last_error = err_no_error
.dsig_emg = SYSDATA(DSIG.EMG_STOP)
IF .dsig_emg<>0 THEN
IF SIG(.dsig_emg)==ON THEN
PRINT "->RdyBoot() Need to clear EMG-STOP button."
.ret = err_emg_on
CALL update_error(.ret)
RETURN
END
END
;状態監視プログラム(status_check関数)でエラーが発生しないようにフラグ変更
CALL chk_robot_stop_
IF SWITCH(REPEAT ,1)==OFF OR SWITCH(REPEAT ,2)==OFF THEN
PRINT "->RdyBoot() Need to change repeat mode."
.ret = err_repeat
CALL update_error(.ret)
RETURN
END
IF SWITCH(TEACH_LOCK ,1)==ON OR SWITCH(TEACH_LOCK ,2)==ON THEN
PRINT "->RdyBoot() Need to unlock teach-lock button."
.ret = err_teach_lock
CALL update_error(.ret)
RETURN
END
CALL exec_alone(.ret)
IF .ret<>err_no_error THEN
PRINT "RdyBoot()-> Error ocured,When called exec_alone(.ret)-function"
RETURN
END
UTIMER .@nowtime = 0
DO
MC HOLD 
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT stop main program."
.ret = err_main_stop
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL ((SWITCH(CS ,1)==OFF) AND ((TASK(1)==0) OR (TASK(1)==2)))
IF debug.prt.core==TRUE THEN
PRINT "->RdyBoot() Kill pg for Robot 1:."
END
MC KILL 
UTIMER .@nowtime = 0
DO
MC HOLD 2:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT stop main program."
.ret = err_main_stop
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL ((SWITCH(CS ,2)==OFF) AND ((TASK(2)==0) OR (TASK(2)==2)))
IF debug.prt.core==TRUE THEN
PRINT "->RdyBoot() Kill pg for Robot 2:."
END
MC KILL 2: 
;エラーOFF 
UTIMER .@nowtime = 0
DO
MC ERESET 1:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT error reset."
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(ERROR ,1)==OFF)
UTIMER .@nowtime = 0
DO
MC ERESET 2:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->RdyBoot() Can NOT error reset."
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(ERROR ,2)==OFF)
IF (SWITCH(ERROR ,1)==OFF) AND (SWITCH(ERROR ,2)==OFF) THEN
g_last_error = err_no_error
ELSE
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
IF .flg_motor==TRUE THEN
UTIMER .@nowtime = 0
DO
MC ZPOWER ON
IF UTIMER(.@nowtime)>power_timeout THEN
PRINT "->RdyBoot() Can NOT motor-on."
.ret = err_poweron
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON)
END
COLRON 1: 
COLRJON 1: 
COLRON 2: 
COLRJON 2: 
.END
.PROGRAM rebootsystem()
;-------------------------------- 
;機能：再起動管理、エラーチェック用常時起動プログラム
;引数：無し
;戻値：無し
;-------------------------------- 
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
flg_tglsw_repea = TRUE
ELSE
flg_tglsw_repea = FALSE
END
flg_cycle_time = FALSE
IF kroset==TRUE THEN
SIGNAL -ix_cycle_time
END
WHILE (TRUE) DO
IF flg_start_reboo==TRUE THEN
CALL resetsystem
END
IF flg_start_killp==FALSE THEN
IF TASK(1005)<>1 OR TASK(1006)<>1 THEN
IF debug.prt.reboo==TRUE THEN
PRINT "rebootsystem()->.......TASK(1005)<>1 OR TASK(1006)<>1"
END
flg_start_reboo = TRUE
END
END
IF flg_main_run==TRUE OR flg_direct_run==TRUE THEN
;ロボット状態監視
CALL status_check(.ret)
END
;AUTO/MANUAL状態出力
IF flg_extout_tgls<>FALSE THEN
IF SIG(extin_teach_tgl)==OFF AND SIG(extin_repeat_tg)==ON THEN
SIGNAL extout_repeat,-extout_teach
ELSE
IF SIG(extin_teach_tgl)==ON AND SIG(extin_repeat_tg)==OFF THEN
SIGNAL -extout_repeat,extout_teach
ELSE
SIGNAL -extout_repeat,-extout_teach
END
END
END
;ランプ制御
CALL extout_ctl
;コンベア同期
CALL chk_cv_setting(.ret)
IF .ret<>err_no_error THEN
.ret = err_no_error
ELSE
CALL cv_sync_main
END
;原点所在時信号出力
CALL extout_home
;ビジョン準備完了出力(一旦機能削除)
IF FALSE THEN
IF flg_extout_vchk<>FALSE AND flg_vchk_done<>TRUE AND SIG(-ix_interval_vis) THEN
CALL vcheck_connect(.ret);ビジョン接続確認
IF .ret<>err_no_error THEN
.ret = err_no_error
SIGNAL -sig_extout_vchk
PULSE ix_interval_vis,vischk_interval
ELSE
SIGNAL sig_extout_vchk
flg_vchk_done = TRUE
END
END
END
;非常停止中出力
IF flg_extout_emg<>FALSE THEN
.dsig_emg = SYSDATA(DSIG.EMG_STOP)
IF .dsig_emg<>0 THEN
IF SIG(.dsig_emg)==ON THEN
SIGNAL sig_extout_emg
ELSE
SIGNAL -sig_extout_emg
END
END
END
;K-ROSET用(サイクルタイム計測)
IF kroset==TRUE THEN
CALL chk_cycle_time
END
CASE robot_status_ou OF
VALUE sta_l2exe,sta_tablet:
;MANUAL時速度抑制
L3COOPADJSP ON
VALUE sta_nomove:
;停止(再開不可)時は、コンベアビジョンの計測を停止する。
cv_vision_id = 0
ANY :
L3COOPADJSP OFF
END
TWAIT ascycle
END
.END
.PROGRAM recv(.$str,.ret)
;-------------------------------- 
;窶ｹ@窶拿ﾐェUDPﾐ錦τ樽ﾐ鞘ぎ窶飯窶慊ｮﾐ糊ｼﾑ砺ﾑ寅袴徹ﾑ凪ｰﾑ寅や廃)
;竄ｬﾑ尉停斷ェ窶墟倪堋ｵ
;窶寅ｯ窶冤ﾐェﾐ錦τ樽窶｢ﾂｶﾐ錦吮飯・アﾑ陳ｬ窶斷ｫ
;-------------------------------- 
.$str = ""
.$cmd[1] = ""
.ret = -1
.timeout = tcp_timeout
;ﾐ錦τ樽ﾑ漬ｶ窶露窶佯
CALL get_cominfo(type_recv,.nouse,.sid,nouse,.port)
IF (.sid==-1) OR ((TASKNO==1005) AND (tcp_reconnect_b[0]==TRUE)) OR ((TASKNO==1006) AND (tcp_reconnect_b[1]==TRUE)) THEN
IF (tcp_reconnect_b[0]==TRUE) OR (tcp_reconnect_b[1]==TRUE) THEN
PRINT "recv()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
END
RETURN
END
;ﾐ錦τ樽ﾐ鞘ぎ窶飯慴雨ﾐ杵
IF mode_ctype==mode_udp THEN
UDP_RECVFROM .ret,.port,.$cmd[1],.len,.timeout,ip[0],255
ELSE
IF .sid!=-1 THEN
TCP_RECV .ret,.sid,.$cmd[1],.num,.timeout,255
END
END
IF .ret==0 THEN
IF .$cmd[1]=="" THEN
.ret = -1
ELSE
.$str = .$cmd[1]
IF debug.prt.sock==TRUE THEN
CALL check_disp_sock(.$cmd[1],.flg_disp)
IF .flg_disp==TRUE THEN
PRINT "TASKNO=",TASKNO," recv()->.sid=",.sid," port=",.port,",.$cmd[1]=",.$cmd[1]
END
END
END
END
;ﾐ錦τ樽窶｢ﾂｶﾐ錦吮飯≫｢ﾐｫ窶伉ｶ
IF .ret==0 THEN
CALL commu_log(2,.$str)
END
.END
.PROGRAM reset_error(.ret)
;-------------------------------- 
;動作プログラム実行(再起動)準備、モータ停止状態遷移
;引数：準備にモータ電源ON処理含む(TRUE/FALSE)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.time_out = boot_timeout
.time_out2 = emg_timeout
;エラー状態を一旦解除する
.bak_error = g_last_error
g_last_error = err_no_error
;操作パネルの状態を確認
IF SWITCH(REPEAT ,1)==OFF OR SWITCH(REPEAT ,2)==OFF THEN
PRINT "->reset_error() Need to change repeat mode."
.ret = err_repeat
CALL update_error(.ret)
RETURN
END
IF SWITCH(TEACH_LOCK ,1)==ON OR SWITCH(TEACH_LOCK ,2)==ON THEN
PRINT "->reset_error() Need to unlock teach-lock button."
.ret = err_teach_lock
CALL update_error(.ret)
RETURN
END
;エラーOFF(下アーム)
UTIMER .@nowtime = 0
DO
MC ERESET 1:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->reset_error() Can NOT error reset."
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(ERROR ,1)==OFF)
;エラーOFF(上アーム)
UTIMER .@nowtime = 0
DO
MC ERESET 2:
IF UTIMER(.@nowtime)>.time_out THEN
PRINT "->reset_error() Can NOT error reset."
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(ERROR ,2)==OFF)
IF (SWITCH(ERROR ,1)==OFF) AND (SWITCH(ERROR ,2)==OFF) THEN
g_last_error = err_no_error
ELSE
.ret = .bak_error
CALL update_error(.ret)
RETURN
END
IF SYSDATA(DSIG.EMG_STOP)<>0 THEN
.emg_sta = SIG(SYSDATA(DSIG.EMG_STOP))
ELSE
.emg_sta = OFF
END
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>.time_out2 THEN
PRINT "->reset_error() Need to clear EMG-STOP button."
.ret = err_no_error
RETURN
END
TWAIT ascycle
UNTIL (.emg_sta==OFF)
;モータON
UTIMER .@nowtime = 0
DO
MC ZPOWER ON
IF UTIMER(.@nowtime)>power_timeout THEN
PRINT "->reset_error() Can NOT motor-on."
.ret = err_poweron
CALL update_error(.ret)
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON)
.END
.PROGRAM reset_mon_sp(.rno)
;-------------------------------- 
;機能：モニタ速度を戻す
;引数：
;戻値：成否
;-------------------------------- 
CASE .rno OF
VALUE robot_all:
FOR .i = robot_master TO robot_slave
IF chg_bef_mspeed[.i]<>0 THEN
IF ABS(chg_bef_mspeed[.i]-data_monspeed[0])<0.1 THEN
.$str = "SPEED "+$ENCODE(.i)+":"+$ENCODE(chg_bef_mspeed[.i])
ZMONEXE .$str
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> M.SPEED",chg_bef_mspeed[.i],"[%], P.SPEED",SYSDATA(P.SPEED,.i),"[%], TASKNO =",TASKNO,", rno =",.i
END
ELSE
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",chg_bef_mspeed[.i],"[%], DATA_MONSPEED",data_monspeed[0],"[%], TASKNO =",TASKNO,", rno =",.i
END
END
chg_aft_mspeed[.i] = chg_bef_mspeed[.i]
chg_bef_mspeed[.i] = 0
ELSE
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> -- NoChange -- M.SPEED",SYSDATA(M.SPEED,.i),"[%], P.SPEED",SYSDATA(P.SPEED,.i),"[%], TASKNO =",TASKNO,", rno =",.i
END
END
END
VALUE robot_master,robot_slave:
IF chg_bef_mspeed[.rno]<>0 THEN
IF ABS(chg_bef_mspeed[.rno]-data_monspeed[0])<0.1 THEN
.$str = "SPEED "+$ENCODE(.rno)+":"+$ENCODE(chg_bef_mspeed[.rno])
ZMONEXE .$str
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> M.SPEED",chg_bef_mspeed[.rno],"[%], P.SPEED",SYSDATA(P.SPEED,.rno),"[%], TASKNO =",TASKNO,", rno =",.rno
END
ELSE
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",chg_bef_mspeed[.rno],"[%], DATA_MONSPEED",data_monspeed[0],"[%], TASKNO =",TASKNO,", rno =",.rno
END
END
chg_aft_mspeed[.rno] = chg_bef_mspeed[.rno]
chg_bef_mspeed[.rno] = 0
END
IF .rno==robot_master THEN
IF chg_bef_mspeed[robot_slave]<>0 AND flg_req_mamode==TRUE THEN
IF ABS(chg_bef_mspeed[robot_slave]-data_monspeed[0])<0.1 THEN
.$str = "SPEED "+$ENCODE(robot_slave)+":"+$ENCODE(chg_bef_mspeed[robot_slave])
ZMONEXE .$str
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> M.SPEED",chg_bef_mspeed[robot_slave],"[%], P.SPEED",SYSDATA(P.SPEED,robot_slave),"[%], TASKNO =",TASKNO,", rno =",robot_slave
END
ELSE
IF debug.prt.sp==TRUE THEN
PRINT "reset_mon_sp()-> -- Unmatch -- CHG_BEF_MSPEED",chg_bef_mspeed[robot_slave],"[%], DATA_MONSPEED",data_monspeed[0],"[%], TASKNO =",TASKNO,", rno =",robot_slave
END
END
chg_aft_mspeed[robot_slave] = chg_bef_mspeed[robot_slave]
chg_bef_mspeed[robot_slave] = 0
END
END
END
.END
.PROGRAM reset_omron()
;-------------------------------- 
;機能：オムロンビジョン 通信再接続
;-------------------------------- 
;
CALL pc3_tcp_sclose(vtcp_sock)
.END
.PROGRAM resetctrllinfo()
;-------------------------------- 
;制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
flg_main_run = FALSE
flg_tablet_run[1] = FALSE
flg_tablet_run[2] = FALSE
flg_direct_run = FALSE
flg_master_move = FALSE
flg_slave_move = FALSE
;ロボットモードONフラグ
robot_mode_flg = FALSE
;ロボットモード_タブレットモード
robot_mode = mode_tablet
flg_req_mamode = FALSE
flg_slave_rdy = FALSE
flg_slave_paral = FALSE
tcp_reconnect_b[0] = FALSE
tcp_reconnect_b[1] = FALSE
flg_wait_end = FALSE
flg_gravityadj_ = FALSE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL -extout_start_bu,-extout_stop_but
;暫定スロースタート機能制御
flg_slowlimit = FALSE
flg_exec_first_ = TRUE
;実行条件成立待機中ﾌﾗｸﾞ
flg_l2chk_wait = FALSE
.END
.PROGRAM resetstartinfo()
;-------------------------------- 
;初回起動時だけ実行する制御情報リセット
;引数：無し
;戻値：無し
;-------------------------------- 
;SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
IF SYSDATA(ZSIMENV)<>2 THEN
;K-ROSET用
kroset = FALSE
;通信ポート
tcp_listen_port[0] = real_tcp_port[0]
tcp_listen_port[1] = real_tcp_port[1]
;メッセージOFF=パフォーマンス対策
;MESSAGE OFF
;外部制御盤入力設定=実機
extin_start_but = real_start_butt
extin_stop_butt = real_stop_butto
IF flg_extin_tglsw<>TRUE THEN
extin_teach_tgl = real_teach_tgls
extin_repeat_tg = real_repeat_tgl
ELSE
extin_teach_tgl = off_teach_tglsw
extin_repeat_tg = off_repeat_tgls
END
ELSE
IF kroset==TRUE THEN
;アーム間干渉チェック機能有効化
ZINTFCHK ON
;通信ポート(K-ROSET用)
tcp_listen_port[0] = sim_tcp_port[0]
tcp_listen_port[1] = sim_tcp_port[1]
ELSE
;アーム間干渉チェック機能無効化
ZINTFCHK OFF
;通信ポート
tcp_listen_port[0] = real_tcp_port[0]
tcp_listen_port[1] = real_tcp_port[1]
END
;衝突・衝撃検知機能無効化
ZCOLDISABLE 1:  ON
ZCOLDISABLE 2:  ON
;外部制御盤入力設定=シミュレータ
extin_start_but = sim_start_butto
extin_stop_butt = sim_stop_button
IF flg_extin_tglsw<>TRUE THEN
extin_teach_tgl = sim_teach_tglsw
extin_repeat_tg = sim_repeat_tgls
ELSE
extin_teach_tgl = off_teach_tglsw
extin_repeat_tg = off_repeat_tgls
END
END
flg_start_killp = FALSE
tcp_listen_lock = FALSE
flg_start_reboo = TRUE
;信号を一旦OFF、extout_ctl関数で判定して必要なら自動再点灯
SIGNAL -extout_start_bu,-extout_stop_but
;ティーチロック無効化
ZTPDISCON  ON
;暫定スロースタート機能制御
flg_slowlimit = FALSE
flg_exec_first_ = TRUE
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
;モニタ速度変更フラグ初期化
chg_bef_mspeed[1] = 0
chg_bef_mspeed[2] = 0
chg_aft_mspeed[1] = 0
chg_aft_mspeed[2] = 0
;モニタ速度保存
data_monspeed[0] = MSPEED
;通信断判定時間(sec)
IF ZOPTION(16,7)==1 THEN
com_timeout = 300
ELSE
com_timeout = 10
END
.END
.PROGRAM resetsystem()
;-------------------------------- 
;システムリセット 
;引数：無し
;戻値：無し
;-------------------------------- 
;ロボット状態初期化
CALL resetctrllinfo
;エラー状態を一旦解除する
g_last_error = err_no_error
;PCプログラムは必ず起動する(停止しない)
CALL bootpcprogram(.ret)
IF debug.prt.core==TRUE THEN
PRINT "->ResetSystem() System change to READY status."
END
flg_start_reboo = FALSE
;制御電源投入直後のロボット状態を通知する
CALL status_check(.ret)
.END
.PROGRAM rpy2oat(.#xyzrpy,.#xyzoat)
;-------------------------------- 
;機能：座標変換(RPY->OAT)
;引数：RPY
;戻値：OAT
;-------------------------------- 
;外部軸
;.xyzoat[7]=.xyzrpy[7]
DECOMPOSE .xyzrpy[1] = .#xyzrpy
;XYZRPY
.sx = SIN(.xyzrpy[4])
.sy = SIN(.xyzrpy[5])
.sz = SIN(.xyzrpy[6])
.cx = COS(.xyzrpy[4])
.cy = COS(.xyzrpy[5])
.cz = COS(.xyzrpy[6])
.mat[0,0] = .cy*.cz
.mat[0,1] = -.cy*.sz
.mat[0,2] = .sy
.mat[0,3] = .xyzrpy[1]
.mat[1,0] = .sx*.sy*.cz+.cx*.sz
.mat[1,1] = -.sx*.sy*.sz+.cx*.cz
.mat[1,2] = -.sx*.cy
.mat[1,3] = .xyzrpy[2]
.mat[2,0] = -.cx*.sy*.cz+.sx*.sz
.mat[2,1] = .cx*.sy*.sz+.sx*.cz
.mat[2,2] = .cx*.cy
.mat[2,3] = .xyzrpy[3]
.mat[3,0] = 0e+00
.mat[3,1] = 0e+00
.mat[3,2] = 0e+00
.mat[3,3] = 0e+00
;XYZOAT
.p = SQRT(.mat[0,2]*.mat[0,2]+.mat[1,2]*.mat[1,2])
.xyzoat[1] = .mat[0,3]
.xyzoat[2] = .mat[1,3]
.xyzoat[3] = .mat[2,3]
.xyzoat[5] = ATAN2(-.mat[2,2],.p)
IF ABS(.p)>1e-06 THEN
.xyzoat[4] = ATAN2(.mat[0,2],-.mat[1,2])
.xyzoat[6] = ATAN2(.mat[2,1],-.mat[2,0])
ELSE
.xyzoat[4] = ATAN2(.mat[1,1],.mat[0,1])
.xyzoat[6] = 0e+00
END
.xyzoat[4] = .xyzoat[4]-90
.xyzoat[5] = .xyzoat[5]+90
FOR .i = 1 TO 3
IF .xyzoat[.i+3]>180 THEN
.xyzoat[.i+3] = .xyzoat[.i+3]-360
END
IF .xyzoat[.i+3]<-180 THEN
.xyzoat[.i+3] = .xyzoat[.i+3]+360
END
END
POINT .#xyzoat = #PPOINT(.xyzoat[1],.xyzoat[2],xyzoat[3],.xyzoat[4],.xyzoat[5],.xyzoat[6])
.END
.PROGRAM s.kukei()
; /***********************************************************************
; FUNCTION: 協調矩形動作（スレーブ）
; ***********************************************************************/
;
;正面XZ平面での協調矩形動作
JMOVE #s.pos1
SLAVE
ALONE
;正面XY平面での協調矩形動作
JMOVE #s.pos1
SLAVE
ALONE
.END
.PROGRAM s.main()
; /***********************************************************************
; FUNCTION: ダンスPGメイン（スレーブ）
; ***********************************************************************/
IF SIG(2300) THEN           ;ダンス実行フラグON
;       CALL s.kukei
CALL s.rotate
CALL s.reverse
;	SIGNAL -2300		;1回だけ実行するのでOFFにする
END
.END
.PROGRAM s.reverse()
; /***********************************************************************
; FUNCTION: 上下アームの姿勢逆転（マスター）
; ***********************************************************************/
;
CALL set_aux_all(50,1,100,100);速度/精度/加速度/減速度の設定
JMOVE #s.pos2
BREAK
WAIT SIG(2301)
SIGNAL -2301
JMOVE #s.rot1
BREAK
WAIT SIG(2301)
SIGNAL -2301
JMOVE #s.rot2
BREAK
WAIT SIG(2301)
SIGNAL -2301
JMOVE #s.straight0
BREAK
WAIT SIG(2301)
SIGNAL -2301
CALL set_aux_all(50,100,100,30);速度/精度/加速度/減速度の設定
JMOVE #s.straight1
JMOVE #s.straight2
JMOVE #s.straight3
JMOVE #s.straight4
CALL set_aux_all(50,1,100,100);速度/精度/加速度/減速度の設定
JMOVE #s.home
.END
.PROGRAM s.rotate()
; /***********************************************************************
; FUNCTION: 1軸90度ピッチ動作（スレーブ）
; ***********************************************************************/
;
CALL set_aux_all(50,5,100,100);速度/精度/加速度/減速度の設定
JMOVE #s.pos1
BREAK
POINT .s_rot = S_HERE(2)
POINT .s_rot1 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),20)
POINT .s_rot2 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),-20)
FOR .i = 1 TO 2
JMOVE .s_rot1
JMOVE .s_rot2
END
JMOVE .s_rot
SLAVE
ALONE
BREAK
POINT .s_rot = S_HERE(2)
POINT .s_rot1 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),-42)
POINT .s_rot2 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),-82)
FOR .i = 1 TO 2
JMOVE .s_rot1
JMOVE .s_rot2
END
JMOVE .s_rot
SLAVE
ALONE
BREAK
POINT .s_rot = S_HERE(2)
POINT .s_rot1 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),82)
POINT .s_rot2 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),42)
FOR .i = 1 TO 2
JMOVE .s_rot1
JMOVE .s_rot2
END
JMOVE .s_rot
SLAVE
ALONE
BREAK
POINT .s_rot = S_HERE(2)
POINT .s_rot1 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),200)
POINT .s_rot2 = TRANS(DEXT(.s_rot,1),DEXT(.s_rot,2),DEXT(.s_rot,3),160)
FOR .i = 1 TO 2
JMOVE .s_rot1
JMOVE .s_rot2
END
JMOVE .s_rot
.END
.PROGRAM savmod()
;-------------------------------- 
;ダイレクトティーチ用プログラム
;引数：無し
;戻値：無し
;--------------------------------
IF disable_readj_p==TRUE THEN
;停止位置記憶有効フラグ
flg_enable_stop = FALSE
END
NOEXIST_SET_R flg_sa_change = OFF
flg_direct_run = TRUE
PRINT "Booted DIrect-teach program. This program name is SAV."
IF (robot_mode<>mode_direct) OR (robot_mode_flg==FALSE) THEN
RETURN
END
IF TASKNO==robot_master THEN
GETULIMIT 1: .#ulim
GETLLIMIT 1: .#llim
.axis = SYSDATA(ZROB.NOWAXIS,1)
ELSE
GETULIMIT 2: .#ulim
GETLLIMIT 2: .#llim
.axis = SYSDATA(ZROB.NOWAXIS,2)
END
FOR .i = 1 TO .axis+2;本体軸のみ
IF .i<9 THEN
.ulim[.i] = DEXT(.#ulim,.i)
.llim[.i] = DEXT(.#llim,.i)
.lim[.i] = ABS(.ulim[.i])+ABS(.llim[.i])-1;上下限の絶対値の和をそのまま使うと、下アームのJT1のみ本体異常となる場合があり、念のため全軸1引いた値にしておく
END
END
CASE .axis OF
VALUE 4:
SADEGREE .lim[1],.lim[2],.lim[3],.lim[4]
VALUE 5:
SADEGREE .lim[1],.lim[2],.lim[3],.lim[4],,,.lim[7]
VALUE 6,7,8:
SADEGREE .lim[1],.lim[2],.lim[3],.lim[4],,,.lim[7],.lim[8]
END
SAENVCHKOFF
SAGAIN 0,0,0,0,,,0,0
SASTART
DO
IF (flg_sa_change BAND TASKNO)<>0 THEN
SAEND
.lock = NOT (sa_param[TASKNO,1] OR sa_param[TASKNO,2] OR sa_param[TASKNO,3] OR sa_param[TASKNO,4] OR sa_param[TASKNO,5] OR sa_param[TASKNO,6])
IF .lock==ON THEN
SAGAIN 100,100,100,100,,,100,100
ELSE
CASE mode_sa OF
VALUE sa.jt:
FOR .jt = 1 TO 6
IF sa_param[TASKNO,.jt]<>FALSE THEN
.sa_gain[.jt] = data_sa_gain[TASKNO,.jt]
ELSE
.sa_gain[.jt] = 100
END
END
SAGAIN .sa_gain[1],.sa_gain[2],.sa_gain[3],.sa_gain[4],,,.sa_gain[5],.sa_gain[6]
VALUE sa.base:
SAGAIN sa_gain_org[1],sa_gain_org[2],sa_gain_org[3],sa_gain_org[4]
SAXYZ sa_param[TASKNO,1],sa_param[TASKNO,2],sa_param[TASKNO,3],sa_param[TASKNO,4]
VALUE sa.tool:
SAGAIN sa_gain_org[1],sa_gain_org[2],sa_gain_org[3],sa_gain_org[4]
SATXYZ sa_param[TASKNO,1],sa_param[TASKNO,2],sa_param[TASKNO,3],sa_param[TASKNO,4]
END
END
flg_sa_change = flg_sa_change BAND (COM TASKNO)
SASTART
END
TWAIT ascycle
UNTIL ((robot_mode==mode_direct) AND (robot_mode_flg==TRUE));プログラム終了後status_check関数が反応してエラー状態に遷移する
SAEND
SAENVCHKON
flg_direct_run = FALSE
.END
.PROGRAM scene_change_om(.code)
; FUNCTION: オムロン シーン切り替え
; NOTE    : ver1.0.0[13/02/27]
SIGNAL -ix_vcomm_error,-ix_vcomm_comp
vis_code = .code
$vsend_data[0] = "SCENE"+$ENCODE(/D,vis_code); 送信データ作成
CALL vis_tcp(1,1,0);                           送信開始
CALL vis_wait_tcp;                             受信待ち
IF v.com_error==verr_ok AND $vcom_res=="" THEN;  通信ＯＫ
$vres = "OK"
v.err = verr_init
ELSE;                                      通信ＮＧ
v.err = v.com_error
$vres = $vcom_res
END
.END
.PROGRAM selfcheck(.l2num,.l3num,.ret)
;-------------------------------- 
;機能：呼び出しTASKと作業データのロボット種別比較
;引数：第2階層番号(.l2num)、第3階層番号(.l3num)
;戻値：成否
;-------------------------------- 
.ret = err_bad_rno
IF (TASKNO==pg_master) AND (data_robottype[.l2num,.l3num]==robot_master) THEN
.ret = err_no_error
END
IF (TASKNO==pg_slave) AND (data_robottype[.l2num,.l3num]==robot_slave) THEN
.ret = err_no_error
END
.END
.PROGRAM send(.$str,.ret)
;-------------------------------- 
;窶ｹ@窶拿ﾐェUDP窶倪飯樽ﾐ鞘ぎ窶飯窶慊ｮﾐ糊ｼﾑ砺ﾑ寅袴徹ﾑ凪ｰﾑ寅び漬ｺ窶廃)
;竄ｬﾑ尉停斷ェ窶倪飯樽窶｢ﾂｶﾐ錦吮飯
;窶寅ｯ窶冤ﾐェﾑ陳ｬ窶斷ｫ
;-------------------------------- 
.ret = -1
.$buf[1] = .$str
.timeout = tcp_timeout
;窶倪飯樽ﾑ漬ｶ窶露窶佯
CALL get_cominfo(type_send,.nouse,.sid,nouse,.port)
IF (.sid==-1) OR ((TASKNO==1005) AND (tcp_reconnect_b[0]==TRUE)) OR ((TASKNO==1006) AND (tcp_reconnect_b[1]==TRUE)) THEN
IF (tcp_reconnect_b[0]==TRUE) OR (tcp_reconnect_b[1]==TRUE) THEN
PRINT "send()->TCP_RECONNECT_BUSY==TRUE,TASKNO=",TASKNO
END
RETURN
END
;窶倪飯樽ﾐ鞘ぎ窶飯慴雨ﾐ杵
IF mode_ctype==mode_udp THEN
UDP_SENDTO .ret,ip[0],.port,.$buf[1],1,.timeout
ELSE
;CALL tcp_open(1,.ret)
IF .sid!=-1 THEN
TCP_SEND .ret,.sid,.$buf[1],1,.timeout
ELSE
IF debug.prt.sock==TRUE THEN
PRINT "send NG .sid=-1"
END
END
END
IF debug.prt.sock==TRUE THEN
CALL check_disp_sock(.$buf[1],.flg_disp)
IF .flg_disp==TRUE THEN
PRINT "TASKNO=",TASKNO," send()->.sid=",.sid," port=",.port,",.$buf[1]=",.$buf[1],".ret=",.ret
END
END
;窶倪飯樽窶｢ﾂｶﾐ錦吮飯≫｢ﾐｫ窶伉ｶ
CALL commu_log(1,.$str)
.END
.PROGRAM sendresp(.cmd,.$res,.ret)
;-------------------------------- 
;機能：コマンド応答
;引数：成否
;戻値：なし
;-------------------------------- 
;エラー発生時はログに残す
IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error==err_no_error THEN
CALL error_log(.ret)
END
IF .$res<>"" THEN
IF .$res=="***" THEN
.$res = ""
END
.$str = $ENCODE(/L,.cmd)+","+$ENCODE(/L,.ret)+","+.$res+",1234"
ELSE
.$str = $ENCODE(/L,.cmd)+","+$ENCODE(/L,.ret)+",1234"
END
CALL send(.$str,.ret)
.END
.PROGRAM set_aux(.sp,.accu,.acce,.dece)
; /***********************************************************************
; FUNCTION: 速度／動作軌跡／加速／減速設定(Master)
; ***********************************************************************/
;
FOR .i = 1 TO 6
.acc[.i] = .accu
END
ZL3ACCURACY .acc[1]     ;LMOVE時の各軸精度指定
SPEED .sp
ACCEL .acce
DECEL .dece
RETURN
.END
.PROGRAM set_aux_all(.sp,.accu,.acce,.dece);速度設定ALWAYS
; /**************************************************************
; Function : 速度設定(速度、精度、加速度、減速度)ALWAYS
; **************************************************************/
;
SPEED .sp ALWAYS
FOR .i = 1 TO 6
.acc[.i] = .accu
END
L3ACCURACY .acc[1] ALWAYS
ACCEL .acce ALWAYS
DECEL .dece ALWAYS
RETURN
.END
.PROGRAM setgrav(.rno,.ret)
;-------------------------------- 
;重力補償自動調整実行ﾌﾟﾛｸﾞﾗﾑ
;引数：実行ﾌﾟﾛｸﾞﾗﾑ番号
;戻値：成否
;-------------------------------- 
.ret = err_no_error
NOEXIST_SET_R grav_retry = 30
NOEXIST_SET_R grav_cur_val[0] = -25
NOEXIST_SET_R grav_cur_val[1] = -25
NOEXIST_SET_R grav_chk_lim = 0.5
NOEXIST_SET_R grav_chk_tim = 3
NOEXIST_SET_R grav_deg = 3
NOEXIST_SET_R grav_pul = 5
NOEXIST_SET_R grav_ret_pul = 1
GETULIMIT .rno: .#ulim
GETLLIMIT .rno: .#llim
DECOMPOSE .rno: .ulim[1] = .#ulim
DECOMPOSE .rno: .llim[1] = .#llim
DECOMPOSE .rno: .ho[1] = #HOME(1)
.retry = 0;ﾘﾄﾗｲ回数ﾘｾｯﾄ
.jt3grav = grav_cur_val[.rno-1];重力補償値初期値設定
.jt3pos = (.ulim[3]+.llim[3])/2;3軸初期位置
.flg_pul = 5;重力補償値きざみﾌﾗｸﾞ初期化
.jt3gravpul = grav_pul;重力補償値きざみ値
.flg_finish = FALSE;重力補償設定最終段階ﾌﾗｸﾞ
IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで適切な位置へ移動処理を入れる
JMOVE #grav_pos[.rno]
BREAK
END
;
retry:
COLROFF .rno: 
COLRJOFF .rno: 
PRINT TASKNO,.jt3grav
ZSAGRAV .rno: 3,.jt3grav
grav_cur_val[.rno-1] = .jt3grav
DECOMPOSE .rno: .jt[1] = #S_HERE(.rno)
CALL setl3speed(safty_lmove_sp,FALSE)
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
ZL3LMOVE #PPOINT(.jt[1],.jt[2],.jt3pos,.jt[4],.jt[5],.jt[6]),1,1
VALUE 5:
ZL3LMOVE #PPOINT(.jt[1],.jt[2],.jt3pos,.jt[4],.jt[5],.jt[6],.jt[7]),1,1
VALUE 6,7,8:
ZL3LMOVE #PPOINT(.jt[1],.jt[2],.jt3pos,.jt[4],.jt[5],.jt[6],.jt[7],.jt[8]),1,1
END
BREAK
;
SADEGREE ,,grav_deg
SAENVCHKOFF
SAGAIN 100,100,1,100,100,100,100,100
.pre_jt3 = DEXT(#S_HERE(.rno),3)
UTIMER .@tim = 0
SASTART
TWAIT 0.5
DO
.now_jt3 = DEXT(#S_HERE(.rno),3)
IF UTIMER(.@tim)>=60 OR .retry>=grav_retry THEN ;60秒以上経過orﾘﾄﾗｲ上限を越えた
.ret = err_gravityadj
SAEND
COLRON .rno: 
COLRJON .rno: 
CALL setl3speed(safty_lmove_sp,FALSE)
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
VALUE 5:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6],.jt[7]),1,1
VALUE 6,7,8:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6],.jt[7],.jt[8]),1,1
END
PRINT "TASKNO=",TASKNO,",ZSAGRAV Set NOT complete."
RETURN
END
IF (SACHK:.rno)==0 OR (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)>grav_chk_lim) THEN ;3軸が指定動作範囲を超えたor指定時間経過後に指定角度以上3軸が動いている
SAEND
.retry = .retry+1
IF .jt3pos-DEXT(#S_HERE(.rno),3)>0 THEN
IF .flg_pul==FALSE THEN
.jt3gravpul = grav_ret_pul
END
.jt3grav = .jt3grav-.jt3gravpul
.flg_pul = TRUE
ELSE
IF .flg_pul==TRUE THEN
.jt3gravpul = grav_ret_pul
END
.jt3grav = .jt3grav+.jt3gravpul
.flg_pul = FALSE
END
GOTO retry
END
TWAIT ascycle
UNTIL (UTIMER(.@tim)>=grav_chk_tim AND ABS(.pre_jt3-.now_jt3)<grav_chk_lim) ;指定時間以上経過しても3軸が指定値以上動いていない
SAEND
.jt3gravpul = grav_ret_pul
.retry = 0
IF .flg_finish<>TRUE THEN
CASE .jt3pos OF
VALUE (.ulim[3]+.llim[3])/2:
.jt3pos = .llim[3]+1
GOTO retry
VALUE (.llim[3]+1):
.jt3pos = .ulim[3]-1
GOTO retry
VALUE (.ulim[3]-1):
.jt3pos = (.ulim[3]+.llim[3])/2
.flg_finish = TRUE
GOTO retry
END
END
grav_cur_val[.rno-1] = .jt3grav
COLRON .rno: 
COLRJON .rno: 
IF FALSE THEN ;原点姿勢で自動重力補償設定できない場合は、ここで初期位置に戻す。
JMOVE #grav_pos[.rno]
BREAK
END
CALL setl3speed(safty_lmove_sp,FALSE)
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6]),1,1
VALUE 5:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6],.ho[7]),1,1
VALUE 6,7,8:
ZL3LMOVE #PPOINT(.ho[1],.ho[2],.ho[3],.ho[4],.ho[5],.ho[6],.ho[7],.ho[8]),1,1
END
PRINT "TASKNO=",TASKNO,",ZSAGRAV Set complete."
RETURN
.END
.PROGRAM setl3speed(.sp,.always)
;-------------------------------- 
;機能：L3SPEED設定
;引数：指定速度、ALWAYSフラグ
;戻値：なし
;-------------------------------- 
IF .always==FALSE THEN
L3SPEED .sp
ELSE
L3SPEED .sp ALWAYS
END
IF ZOPTION(16,7)==1 THEN
IF data_l3speed<.sp AND data_l3speed<>0 THEN
IF .always==FALSE THEN
L3SPEED data_l3speed
ELSE
L3SPEED data_l3speed ALWAYS
END
END
END
.END
.PROGRAM setmcrpos(.ret)
;-------------------------------- 
;機能：マクロPG用位置変数設定
;引数：第2階層番号、第3階層番号、呼び出し番号、位置変数番号、
;      位置名称、位置変数名、座標種類、ツール番号、位置情報1〜4
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF flg_mem_chk==TRUE THEN
IF SYSDATA(MEM.FREE)<=mem_min_value THEN
.ret = err_mem_value
RETURN
END
END
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.rno = data_robottype[.l2num,.l3num]
.mcrposno = VAL($prm[TASKNO,4])
$data_mcrposname[.l2num,.l3num,.mcrposno] = $prm[TASKNO,5]
$data_mcrpos[.l2num,.l3num,.mcrposno] = $prm[TASKNO,6]
.$mcrpos = $REPLACE($data_mcrpos[.l2num,.l3num,.mcrposno],":",",")
data_mcrpostype[.l2num,.l3num,.mcrposno] = VAL($prm[TASKNO,7])
data_mcrtoolno[.l2num,.l3num,.mcrposno] = VAL($prm[TASKNO,8])
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
IF VAL($prm[TASKNO,7])==mode_jt THEN
.$point = "POINT "+$ENCODE(/L,.rno)+":"+.$mcrpos+" = #PPOINT("+$prm[TASKNO,9]+","+$prm[TASKNO,10]+","+$prm[TASKNO,11]+","+$prm[TASKNO,12]+",0,0"
ELSE
.$point = "POINT "+$ENCODE(/L,.rno)+":"+.$mcrpos+" = TRANS("+$prm[TASKNO,9]+","+$prm[TASKNO,10]+","+$prm[TASKNO,11]+","+$prm[TASKNO,12]+",0,0"
END
IF .axis>4 THEN
FOR .i = 5 TO .axis
.$point = .$point+","+$prm[TASKNO,8+.i]
END
END
.$point = .$point+")"
ZPRGEXE .$point,.err
IF .err<>0 THEN
.ret = err_mcrpos_ng
END
.END
.PROGRAM setparam(.cmd,.ret)
;-------------------------------- 
;機能：変数設定コマンドコア
;引数：変数種類(.ptype)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.rno = VAL($prm[TASKNO,1])
CASE .cmd OF
VALUE cmd_set_sp:
;This protcol will delete soon.
VALUE cmd_set_pitch:
data_teachrot = VAL($prm[TASKNO,2])
data_teachpitch = VAL($prm[TASKNO,3])
data_exttype[robot_master] = VAL($prm[TASKNO,4])
data_exttype[robot_slave] = VAL($prm[TASKNO,5])
VALUE cmd_set_tnum:
tool_data_num[.rno] = VAL($prm[TASKNO,2])
VALUE cmd_set_tool:
FOR .i = 4 TO 6
CALL setparam_range($prm[TASKNO,.i],"REAL",0,1000,FALSE,.tool_pos[.i-3],.ret); リンク長／ハンド長 最小値[0]・最大値[1000]確認
IF .ret<>err_no_error GOTO end
END
;カレントツールは変更しないでデータ格納のみ実行する
.mode = VAL($prm[TASKNO,2]);モードは無効、後日削除
IF VAL($prm[TASKNO,7])<0 OR VAL($prm[TASKNO,7])>2 THEN
.ret = err_bat_value
RETURN
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdsetparam() BEFORE XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
END
IF .rno==1 THEN
ZL3LINKX 1: .tool_pos[1]
ZL3LINKX2 1: .tool_pos[2]
ZL3LINKH1 1: .tool_pos[3]
ELSE
ZL3LINKX 2: .tool_pos[1]
ZL3LINKX2 2: .tool_pos[2]
ZL3LINKH1 2: .tool_pos[3]
END
IF .rno==1 THEN
ZMONEXE "WEIGHT 1:VAL($prm[1006,7]),VAL($prm[1006,8]),VAL($prm[1006,9]),VAL($prm[1006,10]),VAL($prm[1006,11]),VAL($prm[1006,12]),VAL($prm[1006,13])"
ELSE
ZMONEXE "WEIGHT 2:VAL($prm[1006,7]),VAL($prm[1006,8]),VAL($prm[1006,9]),VAL($prm[1006,10]),VAL($prm[1006,11]),VAL($prm[1006,12]),VAL($prm[1006,13])"
END
IF debug.prt.cmd==TRUE THEN
PRINT "->cmdsetparam() AFTER XLINK=",$ENCODE(ZL3GET(LINKX,.rno)),",X2LINK=",$ENCODE(ZL3GET(LINKX2,.rno)),",Hand1-wafer=",$ENCODE(ZL3GET(LINKH1,.rno))
END
VALUE cmd_set_cord:
data_teachcoord = VAL($prm[TASKNO,2])
VALUE cmd_set_home:
.homeno = VAL($prm[TASKNO,2])
IF .homeno!=1 && .homeno!=2 THEN
.ret = err_bad_homeno
RETURN
END
IF .rno==0 THEN
.ret = err_bad_homeno
RETURN
END
.axis = SYSDATA(ZROB.NOWAXIS,.rno)
GETULIMIT .rno: .#ulim
GETLLIMIT .rno: .#llim
DECOMPOSE .rno: .ulim[1] = .#ulim
DECOMPOSE .rno: .llim[1] = .#llim
FOR .i = 1 TO 4
IF .ulim[.i]<VAL($prm[TASKNO,2+.i]) OR .llim[.i]>VAL($prm[TASKNO,2+.i]) THEN
;動作範囲外を越えている場合はエラー
.ret = err_bad_homeno
RETURN
END
END
CASE .axis OF
VALUE 4:
POINT .rno: .#buf = #PPOINT(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),0,0)
VALUE 5:
IF SYSDATA(JTEXIST,.rno,7)<>FALSE THEN
IF .ulim[7]<VAL($prm[TASKNO,7]) OR .llim[7]>VAL($prm[TASKNO,7]) THEN
;動作範囲外を越えている場合はエラー
.ret = err_bad_homeno
RETURN
END
.homepos[7] = VAL($prm[TASKNO,7])
ELSE
.homepos[7] = 0
END
POINT .rno: .#buf = #PPOINT(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),0,0,.homepos[7])
VALUE 6,7,8:
IF SYSDATA(JTEXIST,.rno,7)<>FALSE THEN
IF .ulim[7]<VAL($prm[TASKNO,7]) OR .llim[7]>VAL($prm[TASKNO,7]) THEN
;動作範囲外を越えている場合はエラー
.ret = err_bad_homeno
RETURN
END
.homepos[7] = VAL($prm[TASKNO,7])
ELSE
.homepos[7] = 0
END
IF SYSDATA(JTEXIST,.rno,8)<>FALSE THEN
IF .ulim[8]<VAL($prm[TASKNO,9]) OR .llim[8]>VAL($prm[TASKNO,9]) THEN
;動作範囲外を越えている場合はエラー
.ret = err_bad_homeno
RETURN
END
.homepos[8] = VAL($prm[TASKNO,9])
ELSE
.homepos[8] = 0
END
POINT .rno: .#buf = #PPOINT(VAL($prm[TASKNO,3]),VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),0,0,.homepos[7],.homepos[8])
ANY :
.ret = err_bad_axesno
RETURN
END
.hacc = VAL($prm[TASKNO,8])
IF .hacc<1 OR .hacc>100 THEN
.ret = err_bat_value
RETURN
END
FOR .i = 1 TO 6
IF VAL($prm[TASKNO,.i+9])==1 OR VAL($prm[TASKNO,.i+9])==0 THEN
.chk[.i] = VAL($prm[TASKNO,.i+9])
ELSE
.ret = err_bat_value
RETURN
END
END
;モータ電源は自動OFF(モータ電源ONは他のシーケンスに任せる)
IF SWITCH(POWER ,1)==ON OR SWITCH(POWER ,2)==ON THEN
CALL cmdabort(.ret)
UTIMER .@nowtime = 0
DO
MC ZPOWER OFF
IF UTIMER(.@nowtime)>power_timeout THEN
PRINT "->RdyBoot() Can NOT motor-off."
.ret = err_motor_off
RETURN
END
TWAIT ascycle
UNTIL (SWITCH(POWER ,1)==OFF AND SWITCH(POWER ,2)==OFF)
END
ZHOME_CHK .rno: .chk[1],.chk[2],.chk[3],.chk[4],0,0,.chk[5],.chk[6]
IF .homeno==1 THEN
IF .rno==robot_all THEN
SETHOME robot_master: .hacc,.#buf
SETHOME robot_slave: .hacc,.#buf
ELSE
SETHOME .rno: .hacc,.#buf
END
ELSE
IF .rno==robot_all THEN
SET2HOME robot_master: .hacc,.#buf
SET2HOME robot_slave: .hacc,.#buf
ELSE
SET2HOME .rno: .hacc,.#buf
END
END
VALUE cmd_set_signame:
IF VAL($prm[TASKNO,2])<0 THEN
.ret = err_bad_tableno
RETURN
END
IF VAL($prm[TASKNO,3])<0 THEN
.ret = err_bad_tableno
RETURN
END
$data_io_num[VAL($prm[TASKNO,2])] = $prm[TASKNO,3]
$data_io_name[VAL($prm[TASKNO,2])] = $prm[TASKNO,4]
VALUE cmd_set_signum:
IF VAL($prm[TASKNO,2])<0 THEN
.ret = err_bad_tableno
RETURN
END
data_io_tablenu = VAL($prm[TASKNO,2])
VALUE cmd_set_l2exetb:
IF VAL($prm[TASKNO,3])<0 THEN
.ret = err_bad_tableno
RETURN
END
data_l2tbl_sign[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])] = VAL($prm[TASKNO,4])
data_l2tbl_stat[VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3])] = VAL($prm[TASKNO,5])
VALUE cmd_set_handio:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
FOR .i = 6 TO 13
CALL get_iotype(VAL($prm[TASKNO,.i]),.sigtype,.ret)
IF .ret<>err_no_error THEN
.ret = err_bad_signo
RETURN
END
IF .sigtype==io_di OR .sigtype==io_int THEN
;入力信号と内部信号はエラーにする
.ret = err_bad_signo
RETURN
END
END
FOR .i = 1 TO 4
data_hand_iotyp[.rno,.i] = VAL($prm[TASKNO,.i+1])
END
FOR .i = 1 TO 8
data_hand_io[.rno,.i] = VAL($prm[TASKNO,.i+5])
END
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_vtb:
.vtblno = VAL($prm[TASKNO,2])
IF .vtblno<=0 THEN
.ret = err_bad_tableno
RETURN
END
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
data_vs_cam_num[.vtblno] = VAL($prm[TASKNO,4])
data_vs_calc_nu[.vtblno] = VAL($prm[TASKNO,5])
data_vs_cam_typ[.vtblno] = VAL($prm[TASKNO,6])
data_vs_hold_ty[.vtblno] = VAL($prm[TASKNO,7])
data_vs_calc_po[.vtblno] = VAL($prm[TASKNO,8])
$data_vs_name[.vtblno] = $prm[TASKNO,9]
data_vs_robot[.vtblno] = VAL($prm[TASKNO,10])
;ビジョンID変換
CALL convert_vid(mode_add,data_vs_calc_po[.vtblno],VAL($prm[TASKNO,3]),data_vs_vid[.vtblno])
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_vtbnum:
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
data_vs_tbnum = VAL($prm[TASKNO,2])
ANY :
.ret = err_bad_rno
RETURN
END
VALUE cmd_set_lowspar:
IF VAL($prm[TASKNO,2])<1 OR 4<VAL($prm[TASKNO,2]) THEN; エリア番号[1-4]確認
.ret = err_bad_areano
RETURN
END
FOR .i = 3 TO 6
CALL setparam_range($prm[TASKNO,.i],"REAL",-10000,10000,FALSE,.lowsp_area[.i-2],.ret); 領域最小値[-10000]・最大値[10000]確認
IF .ret<>err_no_error GOTO end
END
FOR .i = 8 TO 9
CALL setparam_range($prm[TASKNO,.i],"REAL",-10000,10000,FALSE,.lowsp_area[.i-3],.ret); 領域最小値[-10000]・最大値[10000]確認
IF .ret<>err_no_error GOTO end
END
IF .lowsp_area[1]>.lowsp_area[3] OR .lowsp_area[2]>.lowsp_area[4] OR .lowsp_area[5]>.lowsp_area[6] THEN; 最小値と最大値を逆に設定していないか確認
.ret = err_bat_value
RETURN
END
IF VAL($prm[TASKNO,10])==0 THEN
IF VAL($prm[TASKNO,7])<1 OR 100<VAL($prm[TASKNO,7]) THEN; 速度[1-100%]確認
.ret = err_bad_speed
RETURN
END
ELSE
IF VAL($prm[TASKNO,7])<1 OR 1500<VAL($prm[TASKNO,7]) THEN; 速度[1-1500mm/sec]確認
.ret = err_bad_speed
RETURN
END
END
ZAREASLOWSET VAL($prm[TASKNO,2]): .lowsp_area[1],.lowsp_area[2],.lowsp_area[3],.lowsp_area[4],.lowsp_area[5],.lowsp_area[6]
IF VAL($prm[TASKNO,10])==0 THEN
ZAREASLOWRATE VAL($prm[TASKNO,2]): VAL($prm[TASKNO,7])
ELSE
ZAREASLOWRATE VAL($prm[TASKNO,2]): VAL($prm[TASKNO,7]) MM/S
END
VALUE cmd_set_lowspse:
;取得ASコマンドが存在しないためGETコマンド用に暫定保持
IF VAL($prm[TASKNO,2])==OFF THEN
ZAREASLOWMODE OFF
ELSE
ZAREASLOWMODE ON
END
VALUE cmd_set_zeroing:
CALL cmdzero(.rno,VAL($prm[TASKNO,2]),VAL($prm[TASKNO,3]),.ret)
VALUE cmd_set_colchkm:
;ダイレクトティーチモード及びタブレットティーチモード中は実行禁止 15/11/27 add Y.Fujimoto
IF robot_mode==mode_tablet AND robot_mode_flg==FALSE THEN
.flg = VAL($prm[TASKNO,2])
CALL chg_colcalflg(.flg)
END
VALUE cmd_set_slowlim:
IF $prm[TASKNO,4]=="1234" THEN
slowlimit_ena = 1
slowlimit_speed = VAL($prm[TASKNO,2])
slowlimit_time = VAL($prm[TASKNO,3])
ELSE
IF VAL($prm[TASKNO,3])>slowlimit_spmax OR VAL($prm[TASKNO,3])<slowlimit_spmin THEN
.ret = err_bat_value
RETURN
END
IF VAL($prm[TASKNO,4])>1000 OR VAL($prm[TASKNO,4])<0 THEN
.ret = err_bat_value
RETURN
END
slowlimit_ena = VAL($prm[TASKNO,2])
slowlimit_speed = VAL($prm[TASKNO,3])
slowlimit_time = VAL($prm[TASKNO,4])
END
VALUE cmd_set_intfpar:
FOR .i = 2 TO 5
CALL setparam_range($prm[TASKNO,.i],"REAL",0.1,10000,FALSE,.intf_tool[.i-1],.ret); 領域最小値[0.1]・最大値[10000]確認
IF .ret<>err_no_error GOTO end
END
CALL setparam_range($prm[TASKNO,6],"REAL",0.1,10000,FALSE,.intf_link1r,.ret)
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,7],"REAL",0.1,10000,FALSE,.intf_link2r,.ret)
IF .ret<>err_no_error GOTO end
IF .rno==0 OR .rno==1 THEN
ZINTFTOOLMDL 1: .intf_tool[1],.intf_tool[2],.intf_tool[3],.intf_tool[4]
ZINTFXLINKRAD 1: .intf_link1r
ZINTFXLINK2RAD 1: .intf_link2r
END
IF .rno==0 OR .rno==2 THEN
ZINTFTOOLMDL 2: .intf_tool[1],.intf_tool[2],.intf_tool[3],.intf_tool[4]
ZINTFXLINKRAD 2: .intf_link1r
ZINTFXLINK2RAD 2: .intf_link2r
END
VALUE cmd_exe_sa:
mode_sa = VAL($prm[TASKNO,2])
sa_tool[1] = VAL($prm[TASKNO,3])
sa_tool[2] = VAL($prm[TASKNO,4])
sa_param[1,1] = VAL($prm[TASKNO,5])
sa_param[1,2] = VAL($prm[TASKNO,6])
sa_param[1,3] = VAL($prm[TASKNO,7])
sa_param[1,4] = VAL($prm[TASKNO,8])
sa_param[2,1] = VAL($prm[TASKNO,9])
sa_param[2,2] = VAL($prm[TASKNO,10])
sa_param[2,3] = VAL($prm[TASKNO,11])
sa_param[2,4] = VAL($prm[TASKNO,12])
sa_param[1,5] = VAL($prm[TASKNO,13])
sa_param[1,6] = VAL($prm[TASKNO,14])
sa_param[2,5] = VAL($prm[TASKNO,15])
sa_param[2,6] = VAL($prm[TASKNO,16])
$sa_param = $prm[TASKNO,2]
FOR .i = 5 TO 16
$sa_param = $sa_param+","+$prm[TASKNO,.i]
END
flg_sa_change = 3
VALUE cmd_exe_flash:
CALL setparam_range($prm[TASKNO,2],"REAL",0,100,TRUE,check_lamp_time,.ret)
CALL setparam_range($prm[TASKNO,3],"INT",1,100,TRUE,check_lamp_cnt,.ret)
CALL setparam_range($prm[TASKNO,4],"INT",0,1,TRUE,check_lamp_mode,.ret)
exout_both_flas = TRUE
VALUE cmd_set_genpara:
.pno = VAL($prm[TASKNO,2])
CASE .pno OF
VALUE 1:; 安全距離
IF .rno<>1 AND .rno<>2 THEN; ロボット番号確認[1-2]
.ret = err_bad_rno
RETURN
END
chk_gohome[.rno] = VAL($prm[TASKNO,3])
VALUE 2:; ツール間距離
chk_dist_here = VAL($prm[TASKNO,3])
ANY :
.ret = err_bad_ptype
END
VALUE cmd_set_colr:
.colr_type = VAL($prm[TASKNO,2])
.pno = VAL($prm[TASKNO,3])
.jt7exist = SYSDATA(JTEXIST,.rno,7)
.jt8exist = SYSDATA(JTEXIST,.rno,8)
CASE .colr_type OF
VALUE 1:;衝突検知
FOR .i = 4 TO 9
IF VAL($prm[TASKNO,.i])<0 OR VAL($prm[TASKNO,.i])>1000 THEN
.ret = err_bat_value
RETURN
END
END
IF .jt7exist<>FALSE AND .jt8exist<>FALSE THEN
COLR .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,VAL($prm[TASKNO,8]),VAL($prm[TASKNO,9])
ELSE
IF .jt7exist<>FALSE THEN
COLR .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,VAL($prm[TASKNO,8])
ELSE
IF .jt8exist<>FALSE THEN
COLR .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,,VAL($prm[TASKNO,9])
ELSE
COLR .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7])
END
END
END
VALUE 2:;衝撃検知
FOR .i = 4 TO 9
IF VAL($prm[TASKNO,.i])<0 OR VAL($prm[TASKNO,.i])>500 THEN
.ret = err_bat_value
RETURN
END
END
IF .jt7exist<>FALSE AND .jt8exist<>FALSE THEN
COLRJ .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,VAL($prm[TASKNO,8]),VAL($prm[TASKNO,9])
ELSE
IF .jt7exist<>FALSE THEN
COLRJ .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,VAL($prm[TASKNO,8])
ELSE
IF .jt8exist<>FALSE THEN
COLRJ .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7]),,,,VAL($prm[TASKNO,9])
ELSE
COLRJ .rno: VAL($prm[TASKNO,4]),VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]),VAL($prm[TASKNO,7])
END
END
END
ANY :
.ret = err_bad_ptype
END
VALUE cmd_set_wset:
;作業グルーピング設定
IF VAL($prm[TASKNO,2])==1 THEN
data_wset_ena = 1; 有効
CALL get_workno(.work_no,.ret)
.ret = err_no_error
data_cur_workno = .work_no
ELSE
data_wset_ena = 0; 無効(1以外は全て無効とする)
data_cur_workno = -999
END
.work_num = VAL($prm[TASKNO,3])
IF .work_num<min_worknum OR max_worknum<.work_num THEN
.ret = err_bad_ptype
ELSE
data_cur_maxnum = .work_num
END
IF VAL($prm[TASKNO,4])==0 THEN
ZUPSPEED OFF
ELSE
ZUPSPEED ON
END
VALUE cmd_set_wspec:
;作業グループ番号指定方法設定
.spec = VAL($prm[TASKNO,2])
IF .spec<0 OR 1<.spec THEN
.ret = err_bad_ptype
ELSE
IF .spec==1 THEN; タブレット
data_wset_spec = .spec
data_wset_set[1] = 0
data_wset_set[2] = 0
ELSE; 信号入力
.signo = VAL($prm[TASKNO,3])
CALL get_iotype(.signo,.sigtype,.ret)
IF .ret<>err_no_error OR .sigtype==io_do THEN
.ret = err_bad_signo
ELSE
IF VAL($prm[TASKNO,4])<1 OR 8<VAL($prm[TASKNO,4]) THEN
.ret = err_bad_ptype
ELSE
.signo2 = .signo+(VAL($prm[TASKNO,4])-1)
CALL get_iotype(.signo2,.sigtype,.ret)
IF .ret<>err_no_error OR .sigtype==io_do THEN
.ret = err_bad_signo
ELSE
data_wset_spec = .spec
data_wset_set[1] = .signo
data_wset_set[2] = VAL($prm[TASKNO,4])
END
END
END
END
END
VALUE cmd_set_wno:
.work_no = VAL($prm[TASKNO,2])
IF .work_no<1 OR max_worknum<.work_no THEN
.ret = err_bad_ptype
ELSE
data_wset_no = .work_no
END
VALUE cmd_set_armslow:
CALL setparam_range($prm[TASKNO,3],"REAL",0,180,FALSE,.armslowdeg,.ret); 領域最小値[0]・最大値[180]確認
IF .ret<>err_no_error GOTO end
IF VAL($prm[TASKNO,5])==0 THEN
IF VAL($prm[TASKNO,4])<=0 OR 100<VAL($prm[TASKNO,4]) THEN; 速度[1-100%]確認
.ret = err_bad_speed
RETURN
END
ELSE
IF VAL($prm[TASKNO,4])<1 OR 1500<VAL($prm[TASKNO,4]) THEN; 速度[1-1500mm/sec]確認
.ret = err_bad_speed
RETURN
END
END
IF VAL($prm[TASKNO,2])==0 THEN
L3ARMSLOWMODE OFF
ELSE
L3ARMSLOWMODE ON
END
L3ARMSLOWSET .armslowdeg
IF VAL($prm[TASKNO,5])==0 THEN
L3ARMSLOWRATE VAL($prm[TASKNO,4])
ELSE
L3ARMSLOWRATE VAL($prm[TASKNO,4]) MM/S
END
VALUE cmd_set_linkslo:
CALL setparam_range($prm[TASKNO,3],"REAL",0,180,FALSE,.linkslow_cwdeg,.ret); 領域最小値[0]・最大値[180]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,4],"REAL",0,180,FALSE,.linkslow_ccwdeg,.ret); 領域最小値[0]・最大値[180]確認
IF .ret<>err_no_error GOTO end
IF VAL($prm[TASKNO,7])==0 THEN
IF VAL($prm[TASKNO,5])<1 OR 100<VAL($prm[TASKNO,5]) THEN; 速度[1-100%]確認
.ret = err_bad_speed
RETURN
END
ELSE
IF VAL($prm[TASKNO,5])<1 OR 1500<VAL($prm[TASKNO,5]) THEN; 速度[1-1500mm/sec]確認
.ret = err_bad_speed
RETURN
END
END
IF VAL($prm[TASKNO,8])==0 THEN
IF VAL($prm[TASKNO,6])<1 OR 100<VAL($prm[TASKNO,6]) THEN; 速度[1-100%]確認
.ret = err_bad_speed
RETURN
END
ELSE
IF VAL($prm[TASKNO,6])<1 OR 1500<VAL($prm[TASKNO,6]) THEN; 速度[1-1500mm/sec]確認
.ret = err_bad_speed
RETURN
END
END
CASE .rno OF
VALUE robot_all:
.ret = err_bad_rno
RETURN
VALUE robot_master,robot_slave:
IF VAL($prm[TASKNO,2])==0 THEN
L3LINKSLOWMODE OFF
ELSE
L3LINKSLOWMODE ON
END
L3LINKSLOWSET .rno: .linkslow_cwdeg,.linkslow_ccwdeg
IF VAL($prm[TASKNO,7])==0 AND VAL($prm[TASKNO,8])==0 THEN
L3LINKSLOWRATE .rno: VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6])
END
IF VAL($prm[TASKNO,7])==1 AND VAL($prm[TASKNO,8])==0 THEN
L3LINKSLOWRATE .rno: VAL($prm[TASKNO,5]) MM/S,VAL($prm[TASKNO,6])
END
IF VAL($prm[TASKNO,7])==0 AND VAL($prm[TASKNO,8])==1 THEN
L3LINKSLOWRATE .rno: VAL($prm[TASKNO,5]),VAL($prm[TASKNO,6]) MM/S
END
IF VAL($prm[TASKNO,7])==1 AND VAL($prm[TASKNO,8])==1 THEN
L3LINKSLOWRATE .rno: VAL($prm[TASKNO,5]) MM/S,VAL($prm[TASKNO,6]) MM/S
END
END
VALUE cmd_set_l3lsp:
IF VAL($prm[TASKNO,2])<0 OR VAL($prm[TASKNO,2])>1500 THEN
.ret = err_bat_value
RETURN
END
data_l3speed = VAL($prm[TASKNO,2])
VALUE cmd_set_genopt:
.hreturn_op = VAL($prm[TASKNO,2])
IF .hreturn_op==2 AND EXISTDATA("gohome_mcr",G)==FALSE THEN
.ret = err_noexist_pg
RETURN
END
CASE .hreturn_op OF
VALUE 0:
zsw_mode_home = -1
VALUE 1:
zsw_mode_home = 0
VALUE 2:
zsw_mode_home = -2
ANY :
.ret = err_bat_value
RETURN
END
VALUE cmd_exe_sagain:
data_sa_gain[1,5] = VAL($prm[TASKNO,2])
data_sa_gain[1,6] = VAL($prm[TASKNO,3])
data_sa_gain[2,5] = VAL($prm[TASKNO,4])
data_sa_gain[2,6] = VAL($prm[TASKNO,5])
flg_sa_change = 3
VALUE cmd_set_cvprm:
.cvno = VAL($prm[TASKNO,1])
IF cv_coopjt[1,.cvno]<>0 OR cv_coopjt[2,.cvno]<>0 THEN
CALL setparam_range($prm[TASKNO,2],"REAL",-180,180,FALSE,.deg_o,.ret); 領域最小値[-180]・最大値[180]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,3],"REAL",-180,180,FALSE,.deg_a,.ret); 領域最小値[-180]・最大値[180]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,4],"REAL",0.01,500,FALSE,.cv_sp,.ret); 領域最小値[0.01]・最大値[500]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,5],"REAL",0,99999,FALSE,.cv_ulim,.ret); 領域最小値[0]・最大値[99999]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,6],"REAL",0,99999,FALSE,.cv_llim,.ret); 領域最小値[0]・最大値[99999]確認
IF .ret<>err_no_error GOTO end
IF .cv_ulim>=.cv_llim THEN
.ret = err_bat_value
RETURN
END
CALL setparam_range($prm[TASKNO,7],"REAL",0,99999,FALSE,.cv_pitch,.ret); 領域最小値[0]・最大値[99999]確認
IF .ret<>err_no_error GOTO end
flg_cvpc_stop = TRUE
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>boot_timeout THEN
flg_cvpc_stop = FALSE
.ret = err_cvpc_ready
RETURN
END
TWAIT ascycle
UNTIL (flg_cvpc_run==FALSE)
FOR .rno = 1 TO 2
IF cv_coopjt[.rno,.cvno]<>0 THEN
CALL cvaxis_check(.rno,cv_coopjt[.rno,.cvno],.ret)
IF .ret==0 THEN
CVSPEED .rno: .cv_sp
POINT .a = NULL
POINT .b = TRANS(0,0,0,.deg_o,.deg_a)+TRANS(10)
SETLCVSLOPE .rno: .a,.b
ELSE
flg_cvpc_stop = FALSE
.ret = err_cv_setting
RETURN
END
END
END
cv_deg_o[.cvno] = .deg_o
cv_deg_a[.cvno] = .deg_a
cv_ulim[.cvno] = .cv_ulim
cv_llim[.cvno] = .cv_llim
cv_work_pitch[.cvno] = .cv_pitch
flg_cvpc_stop = FALSE
ELSE
.ret = err_cv_setting
END
VALUE cmd_set_cvvis:
CALL setparam_range($prm[TASKNO,4],"REAL",1,999,FALSE,.cv_vid,.ret); 領域最小値[1]・最大値[999]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,5],"REAL",0,999,FALSE,.cv_vrap,.ret); 領域最小値[0]・最大値[999]確認
IF .ret<>err_no_error GOTO end
CALL setparam_range($prm[TASKNO,6],"REAL",-999,999,FALSE,.cv_voff,.ret); 領域最小値[-999]・最大値[999]確認
IF .ret<>err_no_error GOTO end
data_vis_cvno = VAL($prm[TASKNO,1])
.l2num = VAL($prm[TASKNO,2])
data_cv_vis[.l2num] = VAL($prm[TASKNO,3])
data_cv_vid[.l2num] = .cv_vid
data_cv_vrap[.l2num] = .cv_vrap
data_cv_voffset[.l2num] = .cv_voff
ANY :
.ret = err_cmd_type
END
end:
.END
.PROGRAM setparam_range(.$strings,.$prm_type,.lower,.upper,.prm_mode,.param,.ret)
;-------------------------------- 
;機能：文字列を数値に上下限つきで変換
;引数：設定値(文字列)、設定値形式、設定値丸め処理（「FALSE」の時、範囲外の場合はエラーとする）、上限、下限
;戻値：設定値(数値)、成否
;-------------------------------- 
.ret = err_no_error
.param = VAL(.$strings); 文字列を数値に変換
IF .$prm_type=="INT" THEN
.param = INT(.param+0.5)
END
IF .param<.lower THEN; 下限確認
IF .prm_mode==TRUE THEN
.param = .lower
ELSE
.ret = err_bat_value
RETURN
END
END
IF .upper<.param THEN; 上限確認
IF .prm_mode==TRUE THEN
.param = .upper
ELSE
.ret = err_bat_value
RETURN
END
END
.END
.PROGRAM setstep(.ret)
;-------------------------------- 
;機能：作業情報の設定コア
;引数：実数配列
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.l3type = VAL($prm[TASKNO,4])
NOEXIST_SET_S $prm[TASKNO,10] = "0"
.sp = VAL($prm[TASKNO,10])
IF .l3type==l3type_move OR .l3type==l3type_shift THEN
IF .l3type==l3type_move THEN
NOEXIST_SET_S $prm[TASKNO,17] = "0"
.sp_mode = VAL($prm[TASKNO,17])
ELSEIF .l3type==l3type_shift THEN
NOEXIST_SET_S $prm[TASKNO,14] = "0"
.sp_mode = VAL($prm[TASKNO,14])
END
CASE .sp_mode OF
VALUE 0,1: ; %指定の場合
IF (.l3type==l3type_move OR .l3type==l3type_shift) AND (.sp<=0 OR .sp>130) THEN
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
VALUE 2,3: ;mm/s指定の場合
;	    	    IF (.l3type==L3TYPE_MOVE OR .l3type==L3TYPE_SHIFT) AND (.sp<=0 OR .sp>1950) THEN システム対応後変更(R11?)
IF (.l3type==l3type_move OR .l3type==l3type_shift) AND (.sp<=0 OR .sp>1500) THEN ;暫定処理(R10)
PRINT "TASKNO=",TASKNO,", err_bad_speed"
.ret = err_bad_speed
RETURN
END
END
END
IF flg_mem_chk==TRUE THEN
IF SYSDATA(MEM.FREE)<=mem_min_value THEN
.ret = err_mem_value
RETURN
END
END
IF $prm[TASKNO,5]<>"" THEN
$data_l3name[.l2num,.l3num] = $prm[TASKNO,5]
flg_noset_name = FALSE
ELSE
flg_noset_name = TRUE
END
data_l3type[.l2num,.l3num] = .l3type    ; @@@ ADD 20140926 A.kobayashi
data_robottype[.l2num,.l3num] = VAL($prm[TASKNO,1])
;.prm[5]以降が設定データ
CASE .l3type OF
VALUE l3type_move:
data_vision_sta[.l2num,.l3num] = VAL($prm[TASKNO,6])
;ビジョンID変換(引数順でID割当番号)
data_vision_id1[.l2num,.l3num] = VAL($prm[TASKNO,7])
CALL convert_vid(mode_add,type_pos,VAL($prm[TASKNO,8]),data_vision_id2[.l2num,.l3num])
CALL convert_vid(mode_add,type_pos,VAL($prm[TASKNO,9]),data_vision_id3[.l2num,.l3num])
data_repspeed[.l2num,.l3num] = VAL($prm[TASKNO,10])
data_postype[.l2num,.l3num] = VAL($prm[TASKNO,11])
data_wait_befor[.l2num,.l3num] = VAL($prm[TASKNO,12])
data_wait_after[.l2num,.l3num] = VAL($prm[TASKNO,13])
IF $prm[TASKNO,14]=="1234" THEN
$prm[TASKNO,14] = $ENCODE(data_acc)
$prm[TASKNO,15] = $ENCODE(data_dec)
$prm[TASKNO,16] = $ENCODE(data_accu)
$prm[TASKNO,17] = "0"
END
IF VAL($prm[TASKNO,16])<=0 THEN
$prm[TASKNO,16] = "0.01"
END
data_accel[.l2num,.l3num] = VAL($prm[TASKNO,14])
data_decel[.l2num,.l3num] = VAL($prm[TASKNO,15])
data_accuracy[.l2num,.l3num] = VAL($prm[TASKNO,16])
data_abssp_mode[.l2num,.l3num] = VAL($prm[TASKNO,17])
data_move_jt[.l2num,.l3num] = VAL($prm[TASKNO,18])
data_cv_no[.l2num,.l3num] = VAL($prm[TASKNO,19])
data_cv_work[.l2num,.l3num] = VAL($prm[TASKNO,20])
VALUE l3type_io_wait:
data_signum[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_sigstatus[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_wait_befor[.l2num,.l3num] = VAL($prm[TASKNO,8])
data_wait_after[.l2num,.l3num] = VAL($prm[TASKNO,9])
data_wait_timeo[.l2num,.l3num] = VAL($prm[TASKNO,10])
IF $prm[TASKNO,11]=="1234" THEN
data_wait_tocon[.l2num,.l3num] = 0
ELSE
data_wait_tocon[.l2num,.l3num] = VAL($prm[TASKNO,11])
END
VALUE l3type_io_chang:
data_signum[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_sigstatus[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_wait_befor[.l2num,.l3num] = VAL($prm[TASKNO,8])
data_wait_after[.l2num,.l3num] = VAL($prm[TASKNO,9])
data_keep_wait[.l2num,.l3num] = VAL($prm[TASKNO,10])
VALUE l3type_cstart,l3type_cend,l3type_wstart,l3type_wend,l3type_return:
;No need parameters for this commands.
VALUE l3type_vision,l3type_calvisio:
data_vision_cal[.l2num,.l3num] = VAL($prm[TASKNO,7])
IF $prm[TASKNO,8]=="1234" THEN
data_vision_cnt[.l2num,.l3num] = 0
ELSE
data_vision_cnt[.l2num,.l3num] = VAL($prm[TASKNO,8]); ビジョンNG続行フラグ(0:停止,1:続行)
END
;ビジョンID変換
CALL convert_vid(mode_add,VAL($prm[TASKNO,7]),VAL($prm[TASKNO,6]),data_vision_id[.l2num,.l3num])
VALUE l3type_l2reset:
data_l2resetnum[.l2num,.l3num] = VAL($prm[TASKNO,6])
VALUE l3type_hand_cha:
data_hand_ctl[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_hand_sol[.l2num,.l3num] = VAL($prm[TASKNO,7])
VALUE l3type_colchk:
data_colchk[.l2num,.l3num] = VAL($prm[TASKNO,6])
VALUE l3type_ifgoto:
data_l3ifgoto_i[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_l3ifgoto_l[.l2num,.l3num] = VAL($prm[TASKNO,7])
VALUE l3type_iflabel:
data_l3label[.l2num,.l3num] = VAL($prm[TASKNO,6])
VALUE l3type_cnt:
data_cntid[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_cnttype[.l2num,.l3num] = VAL($prm[TASKNO,7])
VALUE l3type_cntset:
data_cntid[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_cntval[.l2num,.l3num] = VAL($prm[TASKNO,7])
VALUE l3type_stop:
data_restart_fl[.l2num,.l3num] = VAL($prm[TASKNO,6])
VALUE l3type_call:
$data_callname[.l2num,.l3num] = $prm[TASKNO,6]
data_callno[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_callposnum[.l2num,.l3num] = VAL($prm[TASKNO,8])
VALUE l3type_cvwait:
data_wait_cvno[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_wait_cvwo[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_wait_cvul[.l2num,.l3num] = VAL($prm[TASKNO,8])
data_wait_cvll[.l2num,.l3num] = VAL($prm[TASKNO,9])
data_wait_cvto[.l2num,.l3num] = VAL($prm[TASKNO,10])
VALUE l3type_cvstart:
data_cvcoop_no[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_cvcoop_wo[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_cvcoop_pos[.l2num,.l3num] = VAL($prm[TASKNO,8])
VALUE l3type_cvcomp:
data_cvcoop_no[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_cvcoop_wo[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_cvcoop_wo2[.l2num,.l3num] = VAL($prm[TASKNO,8])
VALUE l3type_shift:
data_refpos[.l2num,.l3num] = VAL($prm[TASKNO,6])
data_postype[.l2num,.l3num] = VAL($prm[TASKNO,7])
data_wait_befor[.l2num,.l3num] = VAL($prm[TASKNO,8])
data_wait_after[.l2num,.l3num] = VAL($prm[TASKNO,9])
data_repspeed[.l2num,.l3num] = VAL($prm[TASKNO,10])
data_accel[.l2num,.l3num] = VAL($prm[TASKNO,11])
data_decel[.l2num,.l3num] = VAL($prm[TASKNO,12])
data_accuracy[.l2num,.l3num] = VAL($prm[TASKNO,13])
data_abssp_mode[.l2num,.l3num] = VAL($prm[TASKNO,14])
data_move_jt[.l2num,.l3num] = VAL($prm[TASKNO,15])
data_cv_no[.l2num,.l3num] = VAL($prm[TASKNO,16])
data_cv_work[.l2num,.l3num] = VAL($prm[TASKNO,17])
ANY :
.ret = err_bad_l3type
END
.END
.PROGRAM setstepifgoto(.ret)
;-------------------------------- 
;機能：作業用条件分岐詳細設定コア
;引数：2:第2階層番号、3:第3階層番号、4:条件番号、
;      5:分岐指定、6:分岐判断種類、7:分岐判断材料、8:分岐判定閾値
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
.ifconid = VAL($prm[TASKNO,4])
IF flg_mem_chk==TRUE THEN
IF SYSDATA(MEM.FREE)<=mem_min_value THEN
.ret = err_mem_value
RETURN
END
END
data_ifmode[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,5])
data_iftype[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,6])
data_ifitem[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,7])
data_ifcnt[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,8])
data_ifcnt2[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,9])
data_ifcnt3[.l2num,.l3num,.ifconid] = VAL($prm[TASKNO,10])
.END
.PROGRAM setsteppos(.ret)
;-------------------------------- 
;機能：作業用教示点位置情報取得コア
;引数：第2階層番号、第3階層番号、動作方法種類(.mode)、値(.value)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
.l2num = VAL($prm[TASKNO,2])
.l3num = VAL($prm[TASKNO,3])
IF flg_mem_chk==TRUE THEN
IF SYSDATA(MEM.FREE)<=mem_min_value THEN
.ret = err_mem_value
RETURN
END
END
data_mode[.l2num,.l3num] = VAL($prm[TASKNO,4])
data_tool[.l2num,.l3num] = VAL($prm[TASKNO,5])
data_pos1[.l2num,.l3num] = VAL($prm[TASKNO,6]);JT1
data_pos2[.l2num,.l3num] = VAL($prm[TASKNO,7]);JT2
data_pos3[.l2num,.l3num] = VAL($prm[TASKNO,8]);JT3
data_pos4[.l2num,.l3num] = VAL($prm[TASKNO,9]);JT4
data_pos5[.l2num,.l3num] = 0;固定
data_pos6[.l2num,.l3num] = 0;固定
data_pos7[.l2num,.l3num] = VAL($prm[TASKNO,10]);EXT1
data_pos8[.l2num,.l3num] = VAL($prm[TASKNO,11]);EXT2
data_pos9[.l2num,.l3num] = VAL($prm[TASKNO,12]);CV1/CV2
.END
.PROGRAM shift_pos(.rno,.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
;-------------------------------- 
;機能：教示点加算
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
.ret = err_no_error
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
.axis = SYSDATA(ZROB.NOWAXIS,.temp_rno)
DECOMPOSE .temp_rno: .inpos[1] = .#inpos
DECOMPOSE .temp_rno: .offsetpos[1] = .#offsetpos
IF debug.prt.pos==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "shift_pos()-> .offsetpos[]=",.offsetpos[.i]
END
END
IF (disable_avetool==FALSE) AND (flg_shift_move==FALSE) THEN
IF (.rno==robot_all) AND (.mode==mode_xyzr1ext1) AND (.shift_type==mode_tool) THEN
;inposは無視して、現在値ベースで加算する
POINT .inpos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4])
;中心位置にオフセット加算
CALL getcurrentpos(robot_master,.mode,.#pos_m,.ret)
DECOMPOSE robot_master: .pos_m[1] = .#pos_m
POINT .pos_m = TRANS(.pos_m[1],.pos_m[2],.pos_m[3],.pos_m[4],.pos_m[5],.pos_m[6])
CALL getcurrentpos(robot_slave,.mode,.#pos_s,.ret)
DECOMPOSE robot_slave: .pos_s[1] = .#pos_s
POINT .pos_s = TRANS(.pos_s[1],.pos_s[2],.pos_s[3],.pos_s[4],.pos_s[5],.pos_s[6])
POINT .pos_ave = AVE_TRANS(.pos_m,.pos_s)
POINT .pos_diff = -.pos_m+.pos_ave
;マスター位置に換算
POINT .pos = .pos_ave+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4])-.pos_diff
DECOMPOSE .outpos[1] = .pos
CASE .axis OF
VALUE 4:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
VALUE 5:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.inpos[7]+.offsetpos[7])
VALUE 6,7,8:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.inpos[7]+.offsetpos[7],.inpos[8]+.offsetpos[8])
END
RETURN
END
END
flg_shift_move = FALSE ;基準位置シフト用フラグOFF
CALL shift_poscore(.rno,.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
.END
.PROGRAM shift_poscore(.rno,.mode,.shift_type,.#inpos,.#offsetpos,.#outpos,.ret)
;-------------------------------- 
;機能：教示点加算コア処理
;引数：動作方法(.mode->MODE_JT/MODE_XYZR1EXT1)、シフト方法(.shift_type->MODE_TOOL/MODE_BASE)、教示点構成要素(.inpos実数配列),オフセット量(.offsetpos実数配列)
;戻値：生成した位置(.outpos実数配列)、成否
;xxx外部軸仕様未確定xxx
;-------------------------------- 
.ret = err_no_error
.temp_rno = .rno
IF .temp_rno==0 THEN
.temp_rno = 1
END
.axis = SYSDATA(ZROB.NOWAXIS,.temp_rno)
DECOMPOSE .temp_rno: .inpos[1] = .#inpos
DECOMPOSE .temp_rno: .offsetpos[1] = .#offsetpos
CASE .mode OF
VALUE mode_jt:
;OFFSET値は各軸とする(ビジョン補正の加算演算はロボットBC判断で対応不要とのこと)
CASE .axis OF
VALUE 4:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1]+.offsetpos[1],.inpos[2]+.offsetpos[2],.inpos[3]+.offsetpos[3],.inpos[4]+.offsetpos[4],.inpos[5]+.offsetpos[5],.inpos[6]+.offsetpos[6])
VALUE 5:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1]+.offsetpos[1],.inpos[2]+.offsetpos[2],.inpos[3]+.offsetpos[3],.inpos[4]+.offsetpos[4],.inpos[5]+.offsetpos[5],.inpos[6]+.offsetpos[6],.inpos[7]+.offsetpos[7])
VALUE 6,7,8:
POINT .temp_rno: .#pos = #PPOINT(.inpos[1]+.offsetpos[1],.inpos[2]+.offsetpos[2],.inpos[3]+.offsetpos[3],.inpos[4]+.offsetpos[4],.inpos[5]+.offsetpos[5],.inpos[6]+.offsetpos[6],.inpos[7]+.offsetpos[7],.inpos[8]+.offsetpos[8])
END
DECOMPOSE .temp_rno: .outpos[1] = .#pos
VALUE mode_xyzr1ext1:
CASE .shift_type OF
VALUE mode_tool:
POINT .temp_rno: .pos = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])+TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6])
DECOMPOSE .temp_rno: .outpos[1] = .pos
IF SYSDATA(JTEXIST,.temp_rno,7)<>FALSE THEN
.outpos[7] = .inpos[7]+.offsetpos[7]
END
IF SYSDATA(JTEXIST,.temp_rno,8)<>FALSE THEN
.outpos[8] = .inpos[8]+.offsetpos[8]
END
VALUE mode_base:
POINT .temp_rno: .pos = TRANS(.offsetpos[1],.offsetpos[2],.offsetpos[3],.offsetpos[4],.offsetpos[5],.offsetpos[6])+TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
DECOMPOSE .temp_rno: .outpos[1] = .pos
IF SYSDATA(JTEXIST,.temp_rno,7)<>FALSE THEN
.outpos[7] = .inpos[7]+.offsetpos[7]
END
IF SYSDATA(JTEXIST,.temp_rno,8)<>FALSE THEN
.outpos[8] = .inpos[8]+.offsetpos[8]
END
END
ANY :
.ret = err_bad_mode
RETURN
END
CASE .axis OF
VALUE 4:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
VALUE 5:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.outpos[7])
VALUE 6,7,8:
POINT .temp_rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.outpos[7],.outpos[8])
END
IF debug.prt.pos==TRUE THEN
FOR .i = 1 TO .axis+2
PRINT "shift_poscore()-> .inpos[]=",.inpos[.i]
END
FOR .i = 1 TO .axis+2
PRINT "shift_poscore()-> .outpos[]=",.outpos[.i]
END
END
.END
.PROGRAM shift_posmake(.temp_rno,.l2num,.l3num,.move,.mode,.#inpos,.#outpos,.ret)
;-------------------------------- 
;機能：基準位置からのシフト位置を作成
;引数：ロボット番号、第2階層番号(.l2num)、第3階層番号(.l3num)、シフト移動の移動軸指定、動作方法(.mode->0;JT、1:XYZR1EXT1)、基準位置
;戻値：シフト後の位置、成否
;-------------------------------- 
.l3ref = data_refpos[.l2num,.l3num];基準位置の第三階層番号
.shiftpos[1] = data_pos1[.l2num,.l3num]; XYZR1EXT1EXT2のシフト量を生成
.shiftpos[2] = data_pos2[.l2num,.l3num]
.shiftpos[3] = data_pos3[.l2num,.l3num]
.shiftpos[4] = data_pos4[.l2num,.l3num]
.shiftpos[5] = data_pos5[.l2num,.l3num]
.shiftpos[6] = data_pos6[.l2num,.l3num]
.shiftpos[7] = data_pos7[.l2num,.l3num]
.shiftpos[8] = data_pos8[.l2num,.l3num]
POINT .temp_rno: .#tmp_inpos = .#inpos ;基準位置を代入
DECOMPOSE .temp_rno: .cpos[1] = .#tmp_inpos
NOEXIST_SET_R .cpos[7] = 0
NOEXIST_SET_R .cpos[8] = 0
POINT .temp_rno: .#base_pos = #PPOINT(.cpos[1],.cpos[2],.cpos[3],.cpos[4],.cpos[5],.cpos[6])
POINT .temp_rno: .#ext_pos = #PPOINT(.cpos[7],.cpos[8],0,0,0,0)
IF .l3ref<>0 THEN ;基準位置が現在値ではない場合
.ref_move = data_move_jt[.l2num,.l3ref] ;基準位置の移動軸指定
;シフト移動軸が基軸+外部軸で、基準位置が基軸のみまたは外部軸のみの場合、基準位置で定義されていない座標を現在値とする。
;シフト移動軸が基軸のみ、または外部軸のみ、かつ基準位置が基軸+外部軸の場合、シフトしない軸は現在値とする。
IF ((.move==1) AND (.ref_move==0 OR .ref_move==2)) OR ((.ref_move==1) AND (.move==0 OR .move==2)) THEN
BREAK
IF .mode==mode_jt THEN
DECOMPOSE .temp_rno: .here_pos[1] = #S_HERE(.temp_rno)
ELSE
DECOMPOSE .temp_rno: .here_pos[1] = S_HERE(.temp_rno)
END
NOEXIST_SET_R .here_pos[7] = 0
NOEXIST_SET_R .here_pos[8] = 0
CASE .ref_move OF
VALUE 0: ;基準位置が基軸のみの場合
POINT .temp_rno: .#ext_pos = #PPOINT(.here_pos[7],.here_pos[8],0,0,0,0)
VALUE 1: ;基準位置が基軸+外部軸の場合
CASE .move OF
VALUE 0: ;シフト移動が基軸のみの場合
POINT .temp_rno: .#ext_pos = #PPOINT(.here_pos[7],.here_pos[8],0,0,0,0)
VALUE 2: ;シフト移動が外部軸のみの場合
POINT .temp_rno: .#base_pos = #PPOINT(.here_pos[1],.here_pos[2],.here_pos[3],.here_pos[4])
END
VALUE 2: ;基準位置が外部軸のみの場合
POINT .temp_rno: .#base_pos = #PPOINT(.here_pos[1],.here_pos[2],.here_pos[3],.here_pos[4])
END
END
END
IF .mode==mode_jt THEN ;基準位置の座標種類が各軸値の場合
L3TRN .temp_rno: .trn[1]=.#base_pos,1 ;基準位置の基軸を各軸値から変換値に変換
POINT .temp_rno: .#base_pos = #PPOINT(.trn[1],.trn[2],.trn[3],.trn[4],.trn[5],.trn[6])
.mode = mode_xyzr1ext1 ;動作方法を変換値にする
END
DECOMPOSE .temp_rno: .bpos[1] = .#base_pos
DECOMPOSE .temp_rno: .epos[1] = .#ext_pos
CASE SYSDATA(ZROB.NOWAXIS,.temp_rno) OF
VALUE 4:
POINT .temp_rno: .#tmp_inpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6])
POINT .temp_rno: .#sft_offset = #PPOINT(.shiftpos[1],.shiftpos[2],.shiftpos[3],.shiftpos[4],.shiftpos[5],.shiftpos[6])
VALUE 5:
POINT .temp_rno: .#tmp_inpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6],.epos[1])
POINT .temp_rno: .#sft_offset = #PPOINT(.shiftpos[1],.shiftpos[2],.shiftpos[3],.shiftpos[4],.shiftpos[5],.shiftpos[6],.shiftpos[7])
VALUE 6,7,8:
POINT .temp_rno: .#tmp_inpos = #PPOINT(.bpos[1],.bpos[2],.bpos[3],.bpos[4],.bpos[5],.bpos[6],.epos[1],.epos[2])
POINT .temp_rno: .#sft_offset = #PPOINT(.shiftpos[1],.shiftpos[2],.shiftpos[3],.shiftpos[4],.shiftpos[5],.shiftpos[6],.shiftpos[7],.shiftpos[8])
END
flg_shift_move = TRUE ;shift_pos関数内処理用フラグON
CALL shift_pos(.temp_rno,mode_xyzr1ext1,mode_tool,.#tmp_inpos,.#sft_offset,.#outpos,.ret); シフト後移動位置の算出
.END
.PROGRAM slave_run(.timeout,.ret)
;-------------------------------- 
;機能：スレーブ動作実行
;引数：
;戻値：成否
;-------------------------------- 
.ret = err_no_error
UTIMER @slavetime = 0
flg_slave_move = TRUE
WHILE (1) DO
IF flg_slave_move==FALSE THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() Slave robot moved to TARGET-POSITION."
END
RETURN
ELSE
IF debug.prt.move==TRUE THEN
PRINT "->movepos() WAITING Slave robot move to TARGET-POSITION. TIME=",UTIMER(@slavetime),"/LIMIT=",.timeout
END
END
IF UTIMER(@slavetime)>.timeout THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() TIMEOUT ERROR.Slave robot NOT move to TARGET-POSITION."
END
.ret = err_cmd_timeout
RETURN
END
IF g_last_error<>err_no_error THEN
IF debug.prt.move==TRUE THEN
PRINT "->movepos() Detected error. g_last_error=",g_last_error
END
.ret = err_srobot_erro
RETURN
END
TWAIT ascycle
END
.END
.PROGRAM status_check(.ret)
;-------------------------------- 
;機能：ロボット状態監視
;引数：なし
;戻値：成否(err_no_error:正常、0以外:異常)
;-------------------------------- 
.ret = err_no_error
NOEXIST_SET_R .flg_hold_cnt = FALSE
IF (flg_start_reboo==FALSE) AND (flg_main_run==TRUE OR flg_direct_run==TRUE) AND (SWITCH(POWER ,1)==OFF OR SWITCH(POWER ,2)==OFF) THEN
IF g_last_error<>err_motor_off THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(POWER,1)==OFF OR SWITCH(POWER,2)==OFF)"
END
END
.ret = err_emg_stop
END
IF (flg_start_reboo==FALSE) AND (((flg_main_run==TRUE) AND (flg_tablet_run[1]==TRUE) AND (flg_tablet_run[2]==TRUE)) OR flg_direct_run==TRUE) AND ((SWITCH(CS ,1)==OFF) OR (SWITCH(CS ,2)==OFF)) AND (flg_restart==FALSE) THEN
IF (SWITCH(POWER ,1)==ON AND SWITCH(POWER ,2)==ON) THEN
IF (flg_master_move==TRUE) OR ((robot_mode==mode_tablet) AND (robot_mode_flg<>FALSE)) OR ((robot_mode==mode_direct) AND (robot_mode_flg<>FALSE)) THEN
IF .flg_hold_cnt==FALSE THEN
UTIMER .@nowtime = 0
.flg_hold_cnt = TRUE
END
IF UTIMER(.@nowtime)>boot_timeout THEN
IF g_last_error<>err_cs_off THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (SWITCH(CS,1)==OFF) OR (SWITCH(CS,2)==OFF)"
END
END
.flg_hold_cnt = FALSE
.ret = err_cs_off
END
ELSE
.flg_hold_cnt = FALSE
END
ELSE
.flg_hold_cnt = FALSE
END
ELSE
.flg_hold_cnt = FALSE
END
IF (flg_start_reboo==FALSE) AND (flg_main_run==TRUE OR flg_direct_run==TRUE) AND (g_last_error<>err_no_error) THEN
IF (SWITCH(POWER ,1)!=OFF AND SWITCH(POWER ,2)!=OFF) THEN
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> (FLG_START_REBOOT==FALSE) AND (FLG_MAIN_RUN==TRUE OR FLG_DIRECT_RUN==TRUE) AND (G_LAST_ERROR<>err_no_error)"
END
.ret = g_last_error
END
END
;動作範囲外エラーや干渉回避エラーなどが発生
IF (SWITCH(ERROR ,1)==ON) OR (SWITCH(ERROR ,2)==ON) THEN
IF (SYSDATA(ERROR.CODE,1)<>OFF) AND (SYSDATA(ERROR.CODE,2)<>OFF) THEN;2台同時にエラーコード有り
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF AND SYSDATA(ERROR.CODE,2)<>OFF"
END
.ret = err_roboterror[0];ロボット本体異常発生中（2台同時発生中）
ELSE
IF SYSDATA(ERROR.CODE,1)<>OFF THEN;マスタロボットで発生中
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,1)<>OFF == ON"
END
.ret = err_roboterror[1];下アーム異常発生中
ELSE
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> SYSDATA(ERROR.CODE,2.)<>OFF == ON"
END
.ret = err_roboterror[2];上アーム異常発生中
END
END
END
;即応答コマンド実行中等にエラーが発生した場合はここから即応答する
;pccom関数内だと自動リセット後で判定できない可能性有
IF .ret<>err_no_error THEN
;衝突検知感度自動調整設定OFF
CALL chg_colcalflg(OFF)
;1台ロボットが停止した場合を考慮してHOLDする
MC HOLD 1:
MC HOLD 2:
IF data_execute==TRUE THEN
CALL update_holdpos
END
CALL update_error(.ret)
IF (flg_master_move==TRUE) THEN
IF cmd_wait_type[ope_command]==cmd_type_wait THEN
CALL sendresp(ope_command,"",.ret)
IF debug.prt.reboo==TRUE THEN
PRINT "status_check()-> Detected robot-error while moving robot.so execute sendresp()."
END
END
END
CALL reset_mon_sp(robot_all); モニタ速度を変更している場合は元に戻す
CALL chk_robot_stop_
END
.END
.PROGRAM sub()
;---------------------------------
;機能：動作プログラム(スレーブ)
;引数：無し
;戻値：無し
;-------------------------------- 
.ret = g_last_error
.$res = ""
IF TASKNO==pg_slave THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Booted sub program. This program working in ROBOT-MASTER."
END
ELSE
PRINT "sub()-> Booted sub program in BAD-TASK. TASKNO=",TASKNO
RETURN
END
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> Done sub program. ROBOT_MODE=",robot_mode,",ROBOT_MODE_FLG=",robot_mode_flg
END
GOTO 10
END
CALL exec_alone(.ret)
;ダイレクトティーチモード強制解除
SAEND
SAENVCHKON
;
flg_slave_moved = FALSE; 動作済みフラグ
syn_mode_end = FALSE; 同期終了フラグ
999
;初期化：共通処理
IF flg_slave_moved==FALSE THEN
CALL chg_move_param(0,100,100,100,1,.ret)
END
;初期化：ロボット別
flg_tablet_run[2] = TRUE
flg_slave_rdy = FALSE
flg_slave_move = FALSE
;マスターロボット動作準備完了待ち
IF flg_tablet_run[1]==FALSE THEN
UTIMER .@nowtime = 0
DO
IF UTIMER(.@nowtime)>wait_maste_time THEN
GOTO 10
END
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",WAITING... MASTER-ROBOT still not booted."
END
TWAIT ascycle
UNTIL (flg_tablet_run[1]==TRUE)
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 1"
END
ELSE
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",MASTER-ROBOT is booted. CHECKPOINT 2"
END
END
;コマンド実行指示待ち
DO
IF (robot_mode==mode_direct) AND (robot_mode_flg<>FALSE) THEN
;プログラム終了後status_check関数が反応してエラー状態に遷移する
IF debug.prt.sub==ON THEN
PRINT "sub()-> (ROBOT_MODE==MODE_DIRECT) AND (ROBOT_MODE_FLG<>FALSE)"
END
GOTO 10
END
;マスター動作プログラム終了に併せてスレーブロボットの動作を終了する
IF flg_tablet_run[1]==FALSE THEN
IF debug.prt.sub==ON THEN
PRINT "sub()-> MSTER ROBOT IS NOT BOOTING...OPE_COMMAND=",ope_command
END
GOTO 10
END
;同期終了処理
IF syn_mode_end==TRUE THEN
syn_mode_end = FALSE
ALONE
END
TWAIT ascycle
UNTIL (flg_slave_move==TRUE)
;コマンド実行
;実行タイミングはMASTERが指示、エラー処理はMASTERで実行
CASE ope_command OF
VALUE cmd_exe_gen:
;原点番号設定
.home_no = VAL($ope_param[3])
;ロボット番号設定
IF zsw_mode_home==OFF THEN
.rno = robot_slave
ELSE
.rno = VAL($ope_param[1])
END
;仕様変更、速度指定無効化、常時固定値
.sp = safty_move_sp
CALL gen_core(.rno,.home_no,.sp,.ret)
BREAK
VALUE cmd_exe_start,cmd_exe_move,cmd_exe_teach,cmd_exe_l2exe,cmd_exe_restart:
IF flg_slave_paral==FALSE THEN
;動作コマンドのみサポート、その他(IO待ち、変更など）はMASTERで実行
IF flg_slave_call==TRUE AND ope_command<>cmd_exe_move AND ope_command<>cmd_exe_teach THEN
flg_slave_call = FALSE
coopsta[robot_slave] = COOPSTATUS(robot_slave)
SCALL $gs_callname
BREAK
IF coopsta[robot_slave]<>COOPSTATUS(robot_slave) THEN
CALL update_error(err_coop_chg)
END
ELSE
CALL submove(.ret)
CALL update_error(.ret)
END
ELSE
BREAK; 並列動作開始の為BREAK
;並列スレーブロボット連続作業実行
.l2num = gs_l2num
.l3num = gs_l3num
IF .l2num==0 AND .l3num==0 THEN
IF debug.prt.sub==ON THEN
PRINT "sub()->.l2num and .l3num are Zero for SLAVE ROBOT!."
END
flg_slave_con = FALSE
GOTO 10
END
;マスターが実行済み部分をスキップして処理開始
IF flg_slave_con==TRUE THEN
CALL l2exec(.l2num,.l3num,.ret)
CALL update_error(.ret)
ELSE
FOR .l2num = gs_l2num TO data_l2num
CALL l2exec(.l2num,.l3num,.ret)
IF .ret<>err_no_error THEN
IF .ret==err_slave_acten THEN
;正常終了処理
.ret = err_no_error
GOTO 10
ELSE
;異常終了処理
CALL update_error(.ret)
GOTO 10
END
END
;途中作業以降は先頭から実行
.l3num = 1
END
END
END
VALUE cmd_exe_gravity:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_GRAVITYADJ"
END
.mode = gs_gravity_mode
.setval = gs_gravity_setv
CALL gravityadj_core(robot_slave,.mode,.setval,.ret)
CALL update_error(.ret)
VALUE cmd_exe_vscalib:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VSCALIB"
END
.rno = gs_rno
.camno = gs_camno
.calno = gs_calno
.camtype = gs_camtype
POINT .target = gs_posxyzr1
.len = gs_len
.height = gs_height
POINT .tool_p = gs_toolp
CALL vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
CALL update_error(.ret)
VALUE cmd_exe_vcalchk:
IF debug.prt.sub==ON THEN
PRINT "sub()-> TASKNO=",TASKNO,",SLAVE-ROBOT->EXECUTE CMD_EXE_VCALCHK"
END
.rno = gs_rno
.camno = gs_camno
.height = gs_height
CALL vision_excalchk(.rno,.camno,.height,.ret)
CALL update_error(.ret)
ANY :
IF debug.prt.sub==ON THEN
PRINT "sub()-> Error occuerd. You try to execute unsupport command.OPE_COMMAND=",ope_command
END
.ret = err_cmd_type
END
10
;終了処理
;マスタープログラム終了検知までsubプログラムを終了しない(sub関数先頭ループ処理に検知実装有)
IF flg_main_run<>FALSE THEN
GOTO 999
ELSE
flg_slave_move = FALSE
END
flg_tablet_run[2] = FALSE
flg_main_run = FALSE
.END
.PROGRAM submove(.ret)
;---------------------------------
;機能：スレーブロボット専用指定位置移動
;引数：無し
;戻値：成否
;メモ：動作に必要な情報はマスター側で生成する
;---------------------------------
.ret = err_no_error
;同期モード動作
IF flg_req_mamode==TRUE THEN
IF debug.prt.sub==TRUE THEN
PRINT "->submove() SLAVE ROBOT ....................."
END
IF syn_mode_start==TRUE THEN; 協調動作開始時のみ実行
syn_mode_start = FALSE
BREAK; 同期開始の為BREAK
IF flg_slave_moved==FALSE THEN
JMOVE #HERE
flg_slave_moved = TRUE
END
;マスタ側にスレーブが協調モードに入ることを通知する
;協調動作に入った後のハンドシェイクはASシステムが行うので考慮不要とのこと
flg_slave_rdy = TRUE
SLAVE
END
RETURN
END
; 動作関連パラメータ設定
.cvworkno = gs_cvworkno
CALL chg_move_param(gs_sp_mode,gs_sp,gs_accel,gs_decel,gs_accuracy,.ret)
IF .ret<>err_no_error THEN
RETURN
END
;移動動作
IF gs_type==mode_jmove THEN
IF gs_mode==mode_jt THEN
IF .cvworkno==FALSE THEN
JMOVE #g_mpos
ELSE
CVJMOVE #g_mpos,,.cvworkno
END
ELSE
DECOMPOSE 2: .p[1] = g_mpos
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
CALL make_cvpos(robot_slave,.#tpos,&g_mpos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
JMOVE .#outpos;変換値指定はできない
ELSE
CVJMOVE .#outpos,,.cvworkno;変換値指定はできない
END
END
ELSE
IF gs_mode==mode_jt THEN
IF .cvworkno==FALSE THEN
ZL3LMOVE #g_mpos,1,1;引数は各軸値
ELSE
CVL3LMOVE #g_mpos,1,.cvworkno;引数は各軸値
END
ELSE
DECOMPOSE 2: .p[1] = g_mpos
ZL3JNT 2: .#tpos=.p[1],#S_HERE(2),1;逆変換
CALL make_cvpos(robot_slave,.#tpos,&g_mpos,.#outpos,.ret)
IF .cvworkno==FALSE THEN
ZL3LMOVE .#outpos,1,1;引数は各軸値
ELSE
CVL3LMOVE .#outpos,1,.cvworkno;引数は各軸値
END
END
END
IF .cvworkno==FALSE THEN
;コンベア同期動作でない場合、再開不可フラグOFF
cv_norestart[robot_slave] = FALSE
END
IF flg_slave_moved==FALSE THEN
flg_slave_moved = TRUE
END
; スレーブロボットの動作中の作業番号を記憶(マスターから起動する為マスター側で記憶しスレーブ側の記憶は消去)
now_move_l3num[robot_master] = tmp_move_l3num[robot_slave]
now_move_l3num[robot_slave] = 0
; スレーブ単独動作時の先読み禁止フラグ(IO変更処理タイミングを合わせるために追加)
IF zsw_submove_pul<>FALSE THEN
PULSE ix_submove_pul
END
IF gs_bflag==TRUE THEN
BREAK
END
.END
.PROGRAM tcp_check(.num,.ret)
;---------------------------------------------------
;機能:TCP接続状態の確認
;引数:なし
;戻値:接続数、成否
;---------------------------------------------------
.ret = err_no_error
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF debug.prt.sock==TRUE THEN
PRINT "TCP_STATUS .num=",.num
IF .num>0 THEN
FOR .i = 0 TO .num-1
PRINT ".port_no[",.i,"]=",.port_no[.i]," .sid[",.i,"]=",.sid[.i]," .ecode[",.i,"]=",.ecode[.i]," .scode[",.i,"]=",.scode[.i]
END
END
END
.END
.PROGRAM tcp_close()
;---------------------------------------------------
;機能:TCP/IP 通信終了（サーバ側）
;引数:.sock_id
;戻値:.port
;---------------------------------------------------
.ret = err_no_error
;ポート閉処理
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_STATUS .num=",.num
END
IF .num<=0 THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_CLOSE <no connection>"
END
RETURN
ELSE
FOR .i = 0 TO .num-1
;LISTENポートは閉じない
IF (.sid[.i]<>tcp_listen_sid[0]) AND (.sid[.i]<>tcp_listen_sid[1]) THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_close()->TCP_CLOSE .sid=",.sid[.i]
END
TCP_CLOSE .ret,.sid[.i]
IF .ret<0 THEN
.ret = -1
ELSE
CALL updatetcpinfo(.sid[.i])
END
END
END
END
.END
.PROGRAM tcp_open(.timeout,.ret)
;---------------------------------------------------
;機能:TCP/IP通信開始（サーバ側)(動作命令用ポートオープン)
;　　 同時接続数1でクライアント側任意のタイミングで接続切断繰返しに対応
;引数:タイムアウト
;戻値:成否
;---------------------------------------------------
.ret = err_no_error
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
IF tcp_listen_lock==FALSE AND .num==0 THEN
tcp_connected[0] = FALSE
tcp_sid[0] = -1
tcp_sid_port[0] = -1
tcp_connected[1] = FALSE
tcp_sid[1] = -1
tcp_sid_port[1] = -1
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->TCP_LISTEN START port_tcp[0]=",tcp_listen_port[0]
PRINT "tcp_open()->TCP_LISTEN START port_tcp[1]=",tcp_listen_port[1]
END
TCP_LISTEN .ret,tcp_listen_port[0]
TCP_LISTEN .ret,tcp_listen_port[1]
tcp_listen_lock = TRUE
;LISTENポートの保存
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
FOR .i = 0 TO .num-1
IF .port_no[.i]==tcp_listen_port[0] THEN
tcp_listen_sid[0] = .sid[.i]
PRINT "tcp_open()->TCP_LISTEN_PORTSID[0]=",tcp_listen_sid[0]
END
IF .port_no[.i]==tcp_listen_port[1] THEN
tcp_listen_sid[1] = .sid[.i]
PRINT "tcp_open()->TCP_LISTEN_PORTSID[1]=",tcp_listen_sid[1]
END
END
END
;オープン先選択
CALL get_cominfo(type_open,.port,.nouse,.idnum,.nouse)
;受付処理許可確認
;    CALL judge_accept(accept_enable)
;    IF accept_enable==FALSE THEN
;        .ret = -1
;        RETURN
;    END
;オープン受付処理開始
TCP_ACCEPT .sid[0],.port,.timeout,ip[0]
IF .sid[0]<0 THEN
.ret = -1
RETURN
ELSE
IF .port==tcp_listen_port[0] THEN
tcp_reconnect_b[0] = TRUE
ELSE
tcp_reconnect_b[1] = TRUE
END
;初期接続、もしくは再接続
tcp_connected[.idnum] = TRUE
;ポート入替対策、再接続中のsend()/recv()エラー対策
FOR .i = 0 TO 1
IF tcp_sid_port[.i]==.port THEN
PRINT "tcp_open()->DELETE TCP-PORT SETTINGS FOR RECONNECT. i=",.i
tcp_connected[.i] = FALSE
END
END
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->NEW TCP_ACCEPT .sid[0]=",.sid[0]," .port=",.port
END
;TCP_STATUSで取得できないのでSIDに対応するポート仮記録
.new_port = .port
;ACCEPTした新しいSIDを仮記録
.new_sid = .sid[0]
;前回ACCEPTしたポートを閉じる
TCP_STATUS .num,.port_no[0],.sid[0],.ecode[0],.scode[0],.$ip[0]
FOR .i = 0 TO .num-1
;LISTENポートはCLOSEしない
;SIDチェック
IF (.sid[.i]<>tcp_listen_sid[0]) AND (.sid[.i]<>tcp_listen_sid[1]) THEN
;開きなおし対象ポート検索
;SIDチェック
FOR .j = 0 TO 1
IF (.sid[.i]==tcp_sid[.j]) THEN
IF .new_port==tcp_sid_port[.j] THEN
IF debug.prt.sock==TRUE THEN
PRINT "tcp_open()->CLOSING .sid[i]=",.sid[.i]," .new_port=",.new_port
END
TCP_CLOSE .ret,.sid[.i]
IF .ret<0 THEN
.ret = -1
ELSE
CALL updatetcpinfo(.sid[.i])
GOTO 10
END
END
END
END
END
END
10
;ACCEPTした新しいSIDの仮記憶をグローバル変数のSIDに上書き
PRINT "tcp_open()->NEW->.port=",.new_port,",.sid=",.new_sid
tcp_sid[.idnum] = .new_sid
;TCP_STATUSで取得できないのでSIDに対応するポート記録
tcp_sid_port[.idnum] = .new_port
IF .port==tcp_listen_port[0] THEN
tcp_reconnect_b[0] = FALSE
ELSE
tcp_reconnect_b[1] = FALSE
END
END
.END
.PROGRAM tcp_recv() ;Communication Receiving data
.num = 0
TCP_RECV rret,sock_id,$recv_buf[1],.num,tout_rec,max_length
IF rret<0 THEN
PRINT "TCP_RECV error in RECV",rret
$recv_buf[1] = "000"
ELSE
IF .num>0 THEN
PRINT "TCP_RECV OK  in RECV",rret
ELSE
$recv_buf[1] = "000"
END
END
.END
.PROGRAM tcp_send(.ret,.$data) ;Communication Sending data
$send_buf[1] = .$data
buf_n = 1
.ret = 1
TCP_SEND .ret,sock_id,$send_buf[1],buf_n,tout
IF .ret<0 THEN
.ret = -1
PRINT "TCP_SEND error in SEND",.ret
ELSE
PRINT "TCP_SEND OK  in SEND",.ret
END
.END
.PROGRAM tcp_vcom_vision()
; FUNCTION: TCP/IP通信(ｸﾗｲｱﾝﾄ) 送受信[PC3]
; NOTE    : ver1.0.0[13/02/08]
v.com_error = verr_init;                          通信結果クリア(変数定義用)
$vcom_res = "";                            エラー内容クリア(変数定義用)
CALL vcom_init;                        ビジョン変数初期化
CALL pc3_vcom_log(0,"通信ＰＧ起動")
SIGNAL -ix_vcomm_error
SIGNAL -ix_vcomm_start,-ix_vcomm_busy,-ix_vcomm_comp; 通信開始信号＆通信中信号＆通信完了信号ＯＦＦ
SIGNAL -ix_pc_start;                       ＰＣプログラム起動確認信号ＯＦＦ
loop:
CALL pc3_vcom_log(0,"通信開始信号待ち...")
CALL pc3_handshake(ix_vcomm_start)
CALL pc3_vcom_log(0,"通信開始")
SIGNAL ix_vcomm_busy;                      通信中信号ＯＮ
v.com_error = verr_init;                          通信結果クリア
$vcom_res = "";                            エラー内容クリア
res_open:
IF vsend_port==vrecv_port GOTO open
CALL pc3_vcom_log(0,"ソケットオープン開始[結果受信用]")
CALL pc3_tcp_sopen(vrecv_port,vtcp_res_sock);TCP/IP ソケットオープン
IF v.com_error<>verr_init GOTO res_close;         ソケット異常時
CALL pc3_vcom_log(0,"ソケットオープン完了[結果受信用]")
open:
CALL pc3_vcom_log(0,"ソケットオープン開始[送受信用]")
CALL pc3_tcp_sopen(vsend_port,vtcp_sock);  TCP/IP ソケットオープン
IF v.com_error<>verr_init GOTO close;             ソケット異常時
CALL pc3_vcom_log(0,"ソケットオープン完了[送受信用]")
send:
IF SIG(ix_vrecv_only) GOTO recv
IF vsend_timeout<=0 GOTO ack
CALL pc3_vcom_log(0,"データ送信開始")
CALL pc3_tcp_send(vtcp_sock,vsend_timeout);TCP/IP データ送信
IF v.com_error<>verr_init GOTO close;             送信異常時
CALL pc3_vcom_log(0,"データ送信完了")
ack:
IF vack_timeout<=0 GOTO recv
CALL pc3_vcom_log(0,"ACK受信待ち開始")
CALL pc3_tcp_recv(vtcp_sock,vack_timeout); TCP/IP ACK受信
IF v.com_error<>verr_init GOTO close;             受信異常時
CALL pc3_vcom_ackchk($vrecv_data[0])
IF v.com_error<>verr_init GOTO close
CALL pc3_vcom_log(0,"ACK受信完了")
TWAIT 0.032
recv:
IF vrecv_timeout<=0 OR vsend_port!=vrecv_port GOTO res_recv
CALL pc3_vcom_log(0,"データ受信待ち開始")
CALL pc3_tcp_recv(vtcp_sock,vrecv_timeout); TCP/IP データ受信
CALL pc3_vcom_log(0,"データ受信完了")
res_recv:
IF vrecv_timeout<=0 OR vsend_port==vrecv_port GOTO close
CALL pc3_vcom_log(0,"データ受信待ち開始[結果受信用]")
CALL pc3_tcp_recv(vtcp_res_sock,vrecv_timeout); TCP/IP データ受信
CALL pc3_vcom_log(0,"データ受信完了[結果受信用]")
close:
IF sock_notclose==0 THEN
CALL pc3_vcom_log(0,"ソケットクローズ開始")
CALL pc3_tcp_sclose(vtcp_sock);            TCP/IP ソケットクローズ
CALL pc3_vcom_log(0,"ソケットクローズ完了")
END
res_close:
IF vsend_port==vrecv_port GOTO result
IF sock_notclose==0 THEN
CALL pc3_vcom_log(0,"ソケットクローズ開始[結果受信用]")
CALL pc3_tcp_sclose(vtcp_res_sock);        TCP/IP ソケットクローズ
CALL pc3_vcom_log(0,"ソケットクローズ完了[結果受信用]")
END
result:; 通信結果確認
IF v.com_error<>verr_init GOTO error
GOTO end
error:; エラー処理
SIGNAL ix_vcomm_error;                     通信エラー信号ＯＮ
PRINT "通信エラー in tcp_vcom_vision"
HALT;                                      停止
end:; 通信完了処理
v.com_error = verr_ok;                           通信結果ＯＫ
SIGNAL -ix_vcomm_busy,ix_vcomm_comp;       通信中信号ＯＦＦ＆通信完了信号ＯＮ
GOTO loop
.END
.PROGRAM tcprecv() ;Communication Receiving data
.num = 0
TCP_RECV rret,sock_id,$recv_buf[1],.num,tout_rec,max_length
IF rret<0 THEN
PRINT "TCP_RECV error in RECV",rret
$recv_buf[1] = "000"
ELSE
IF .num>0 THEN
PRINT "TCP_RECV OK  in RECV",rret
ELSE
$recv_buf[1] = "000"
END
END
.END
.PROGRAM tcpsend(.ret,.$data) ;Communication Sending data
$send_buf[1] = .$data
buf_n = 1
.ret = 1
TCP_SEND sret,sock_id,$send_buf[1],buf_n,tout
IF sret<0 THEN
.ret = -1
PRINT "TCP_SEND error in SEND",sret
ELSE
PRINT "TCP_SEND OK  in SEND",sret
END
.END
.PROGRAM test1()
DRIVE 4,20
DRIVE 4,-20
CALL tcpsend(ret,"OK")
isready = TRUE
.END
.PROGRAM test2()
SPEED 2 ALWAYS
JMOVE #h2_6
JMOVE #h2_7
JMOVE #h2_8
JMOVE #h2_9
JMOVE #h2_10
JMOVE #h2_11
JMOVE #h2_12
JMOVE #h2_13
.END
.PROGRAM testcf()
sig1 = 0
MC execute caffeeh1
MC execute 2: caffeeh2
.END
.PROGRAM testdraw()
SPEED 10
FOR i = 0 TO 5
L3DRAW ,50
L3DRAW ,-50
END
.END
.PROGRAM udp_reader()
ret = 0
$cnt[0] = ""
p = 0
ip[0] = 192
ip[1] = 168
ip[2] = 0
ip[3] = 2
WHILE TRUE DO
UDP_RECVFROM ret,52000,$cnt[0],p,1
IF ret!=0 THEN
i = 0; TYPE "ERROR"
ELSE
TYPE $cnt[0]
END
END
.END
.PROGRAM update_error(.ret)
;---------------------------------
;機能：エラー状態、表示更新
;引数：エラーコード
;戻値：無し
;---------------------------------
IF log_error_ena<>FALSE AND .ret>err_no_error AND g_last_error<>.ret THEN
CALL error_log(.ret)
END
g_last_error = .ret
.END
.PROGRAM update_holdpos()
;-------------------------------- 
;機能：位置データの記録
;引数：無し
;戻値：無し
;--------------------------------
;停止位置記憶有効フラグ
IF disable_readj_p==FALSE THEN
flg_enable_stop = TRUE
END
POINT #rec_holdpos[1] = #S_HERE(1)
POINT #rec_holdpos[2] = #S_HERE(2)
IF debug.prt.func==TRUE THEN
FOR .j = 1 TO 2
DECOMPOSE .buf[1] = #rec_holdpos[.j]
FOR .i = 1 TO 6
PRINT "TASKNO=",TASKNO,"update_holdpos()-> Element of REC_HOLDPOS[",.j,"]:[",.i,"]=",.buf[.i]
END
END
END
.END
.PROGRAM update_vspos(.l2num,.l3num,.#inpos,.#outpos,.cvno,.cvwork,.cvworkno,.cvvalue,.&cvfrm,.ret)
;-------------------------------- 
;機能：ビジョン計測結果反映
;引数：入力変換値配列
;戻値：出力変換値配列,成否
;-------------------------------- 
.ret = err_no_error
.rno = data_robottype[.l2num,.l3num]
DECOMPOSE .rno: .inpos[1] = .#inpos
POINT .rno: .#outpos = .#inpos
;補正なしの場合は入力値はそのまま返すために出力値を入力値で初期化する
FOR .i = 1 TO 6
.outpos[.i] = .inpos[.i]
END
;
;ビジョン補正設定有効・無効判定確認
CALL check_vsl3data(.l2num,.l3num,.chk)
IF .chk<>TRUE THEN
;ビジョン補正設定無効(エラーではない)
RETURN
END
NOEXIST_SET_R cv_vision[0] = 0; CV同期なしの場合、.cvno = 0 になる
; 補正値チェック（ビジョンNG続行フラグONなのに補正動作に来てしまった場合の対策処理）
.id2 = data_vision_id2[.l2num,.l3num]
.id3 = data_vision_id3[.l2num,.l3num]
IF .id2<>0 THEN
.$tmp = "vwork["+$ENCODE(.id2)+",1]"
IF EXISTDATA(.$tmp,T)==OFF THEN; 補正値変数なし
.ret = err_vis_contng; ビジョン補正作業続行不可
RETURN
ELSE
IF (ZOPTION(6,1)<>0 AND ZOPTION(6,2)<>0) AND cv_vision[.cvno]==1 THEN
POINT .vw = cv_vwork[.cvno,.cvwork]; （コンベアオプションON AND 固定カメラ）
ELSE
POINT .vw = vwork[.id2,1]
END
IF ABS(DX(.vw)-vis_init)<0.1 AND ABS(DY(.vw)-vis_init)<0.1 THEN; 補正値変数に初期値が入っていた場合
.ret = err_vis_contng; ビジョン補正作業続行不可
RETURN
END
END
END
IF .id3<>0 THEN
.$tmp = "vwork["+$ENCODE(.id3)+",1]"
IF EXISTDATA(.$tmp,T)==OFF THEN; 補正値変数なし
.ret = err_vis_contng; ビジョン補正作業続行不可
RETURN
ELSE
IF (ZOPTION(6,1)<>0 AND ZOPTION(6,2)<>0) AND cv_vision[.cvno]==1 THEN
POINT .vw = cv_vwork[.cvno,.cvwork]; （コンベアオプションON AND 固定カメラ）
ELSE
POINT .vw = vwork[.id3,1]
END
IF ABS(DX(.vw)-vis_init)<0.1 AND ABS(DY(.vw)-vis_init)<0.1 THEN; 補正値変数に初期値が入っていた場合
.ret = err_vis_contng; ビジョン補正作業続行不可
RETURN
END
END
END
;補正演算
;DATA_VISION_ID1、DATA_VISION_ID2、DATA_VISION_ID3=装置補正用ビジョンID、ワーク位置補正用ビジョンID、ツール位置補正用ビジョンIDの順番固定とする
POINT .in = TRANS(.inpos[1],.inpos[2],.inpos[3],.inpos[4],.inpos[5],.inpos[6])
IF (ZOPTION(6,1)<>0 AND ZOPTION(6,2)<>0) AND cv_vision[.cvno]==1 THEN
CALL vcorrect_cv(.&in,.id2,.id3,.&pos,.cvno,.cvwork,.cvvalue,.&cvfrm,.ret); CV同期有での補正計算
ELSE
CALL vcorrect(.&in,.id2,.id3,.&pos)
END
DECOMPOSE .rno: .outpos[1] = .pos
CASE SYSDATA(ZROB.NOWAXIS,.rno) OF
VALUE 4:
POINT .rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6])
VALUE 5:
POINT .rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.inpos[7])
VALUE 6,7,8:
POINT .rno: .#outpos = #PPOINT(.outpos[1],.outpos[2],.outpos[3],.outpos[4],.outpos[5],.outpos[6],.inpos[7],.inpos[8])
END
.END
.PROGRAM updatel2l3info(.flg_disp,.l2num,.l3num,.flg_full)
;-------------------------------- 
;機能：作業実行状態更新、内部制御用変数更新
;引数：タブレット用情報更新フラグ(ON/OFF)、第2階層番号(マイナス値の場合更新無し)、第3階層番号(マイナス値の場合更新無し)、完全初期化フラグ
;戻値：無し
;--------------------------------
IF .flg_full==TRUE THEN
;完全初期化
data_cur_l2disp = 0
data_cur_l3disp = 0
FOR .i = 1 TO 2
data_cur_l2rec[.i] = 0
data_cur_l3rec[.i] = 0
now_move_l3num[.i] = 0
END
flg_master_con = FALSE
flg_slave_con = FALSE
RETURN
END
IF TASKNO==pg_master THEN
.rno = robot_master
ELSE
.rno = robot_slave
END
IF .l2num>=0 THEN
data_cur_l2rec[.rno] = .l2num
IF (.flg_disp==TRUE) AND (.rno==robot_master) THEN
data_cur_l2disp = .l2num
END
END
IF .l3num>=0 THEN
data_cur_l3rec[.rno] = .l3num
IF (.flg_disp==TRUE) AND (.rno==robot_master) THEN
data_cur_l3disp = .l3num
END
END
IF .l2num==0 AND .l3num==0 THEN
IF .flg_disp==TRUE THEN
IF .rno==robot_master THEN
flg_master_con = FALSE
ELSE
flg_slave_con = FALSE
END
END
; 作業リセット時記憶消去
now_move_l3num[robot_master] = 0
now_move_l3num[robot_slave] = 0
END
.END
.PROGRAM updatetcpinfo(.sid)
;---------------------------------------------------
;機能:TCP接続情報の初期化
;引数:SID
;戻値:なし
;---------------------------------------------------
FOR .j = 0 TO 1
IF tcp_sid[.j]==.sid THEN
IF tcp_sid_port[.j]==tcp_listen_port[0] THEN
PRINT "updateTCPInfo()->TCP_CLOSE port=",tcp_listen_port[0],",.sid=",.sid
tcp_connected[0] = FALSE
tcp_sid[0] = -1
tcp_sid_port[0] = -1
ELSE
PRINT "updateTCPInfo()->TCP_CLOSE port=",tcp_listen_port[1],",.sid=",.sid
tcp_connected[1] = FALSE
tcp_sid[1] = -1
tcp_sid_port[1] = -1
END
END
END
.END
.PROGRAM upr()
JMOVE #up1
L3LMOVE #up2,1
DRIVE 3,55
sig1 = 1
WAIT sig2==1
DRIVE 3,-5
JMOVE #up3
JMOVE #up4
sig3 = 1
WAIT sig4==1
L3LMOVE #up5,1
L3LMOVE #up6,1
L3LMOVE #up7,1
L3LMOVE #up8,1
L3LMOVE #up9,1
L3LMOVE #up10,1
WAIT sig5==1
JMOVE #up11
.END
.PROGRAM vcalib_check(.cam_no,.mes_no,.robot_no,.handeye,.correct_no,.nige,.ret); キャリブレーション精度チェック
; FUNCTION: キャリブレーション精度チェック
; NOTE    : ver1.0.0[16/04/08]
;
.ret = err_no_error;
; --------------------------------------
;   パラメータセット
; --------------------------------------
IF .handeye==1 THEN
.have = 0;
.rot90 = -90
.rot135 = -135
.rot180 = -180
ELSE
.have = 1; 
.rot90 = 90
.rot135 = 135
.rot180 = 180
END
;
.sp = 100
.sp2 = 80
ABS.SPEED .robot_no:  ON
CALL setl3speed(.sp,TRUE)
;
.accu = 1
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
ACCURACY 1 ALWAYS
; --------------------------------------
;   リトライフラグリセット
; --------------------------------------
vchk_retry = 0
start:
;
; --------------------------------------
;   ターゲット位置を基準登録＆計測実施
; --------------------------------------
CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,1,.correct_no,0,.ret)
IF .ret<>0 GOTO end
CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
IF .ret<>0 GOTO end
POINT/OAT vwork[.correct_no,1] = v_master[.correct_no,1]; 計測結果はOAT回転していないものとする
;
; --------------------------------------
;   ロボット位置＆計測結果を保存
; --------------------------------------
POINT vcheck_point1[.cam_no] = S_HERE(.robot_no)
POINT vcheck_work1[.cam_no] = vwork[.correct_no,1]
;
; --------------------------------------------------
;  ターゲット位置を90°,180°回転させた補正位置を作成
; --------------------------------------------------
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot90)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu[.cam_no]); 現在値を90°回転させた位置
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot135)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu2[.cam_no]); 現在値を135°回転させた位置
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot180)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_point2[.cam_no]); 現在値を180°回転させた位置
;
IF .nige<>0 THEN
POINT .app1[.cam_no] = TRANS(,,.nige)+vcheck_point1[.cam_no]
POINT vcheck_tyuu[.cam_no] = TRANS(,,.nige)+vcheck_tyuu[.cam_no]
POINT vcheck_tyuu2[.cam_no] = TRANS(,,.nige)+vcheck_tyuu2[.cam_no]
POINT .app2[.cam_no] = TRANS(,,.nige)+vcheck_point2[.cam_no]
ZL3LMOVE .app1[.cam_no],1,1; 現在位置上空
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ABS.SPEED .robot_no:  ON
CALL setl3speed(.sp2,FALSE)
ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
ELSE
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
END
BREAK
ABS.SPEED .robot_no:  ON
CALL setl3speed(.sp2,FALSE)
JMOVE vcheck_point2[.cam_no]; 180°回転した位置
BREAK
; --------------------------------------------------
;  180°回転した位置で再度ビジョン計測
; --------------------------------------------------
TWAIT 0.5
CALL vision_exe(.cam_no,.mes_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
IF .ret<>0 THEN
vchk_retry = 0
GOTO return;
END
;
; --------------------------------------------------
;  0°・180°での計測結果のXY座標のみを取り出し
; --------------------------------------------------
IF .handeye==1 THEN
POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
POINT vcheck_temp[.cam_no] = vcam_tool[.cam_no]; 現在のキャリブデータをバックアップ
POINT vcam_tool[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vcam_tool[.cam_no]; ズレ量を補正
END
ELSE
POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
POINT vcheck_temp[.cam_no] = vision_frm[.cam_no]; 現在のキャリブデータをバックアップ
POINT vision_frm[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vision_frm[.cam_no]; ズレ量を補正
END
END
;
PRINT /X2,"X ACCURACY = ",vcheck_x[.cam_no],"mm"
PRINT /X2,"Y ACCURACY = ",vcheck_y[.cam_no],"mm"
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
vchk_retry = vchk_retry+1;
IF vchk_retry>=5 THEN
PRINT /X2,"Calib check error. check vision recognition."
ELSE
PRINT /X2,"Execute calib re-check, because accuracy is over 0.1mm"
END
ELSE
vchk_retry = 0;
PRINT /X2,"Calib check OK."
END
;
; --------------------------------------------------
;  元の位置に戻る
; --------------------------------------------------
return:
IF .nige<>0 THEN
ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE .app1[.cam_no],1,1; 開始位置上空
ELSE
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
END
BREAK
JMOVE vcheck_point1[.cam_no]; 開始位置
BREAK
IF vchk_retry>=5 THEN
.ret = err_vis_chkng; 精度チェックエラー 
CALL vlog_calib(.cam_no,.handeye,1)
RETURN
END
IF vchk_retry>0 GOTO start; リトライ実施
end:
ABS.SPEED .robot_no:  OFF
vcalchk_nige[.cam_no] = .nige
CALL vlog_calib(.cam_no,.handeye,1)
.END
.PROGRAM vcalib_check_om(.cam_no,.sce_no,.robot_no,.handeye,.correct_no,.nige,.ret); キャリブレーション精度チェック
; FUNCTION: キャリブレーション精度チェック(OMRON)
; NOTE    : ver1.0.0[16/04/08]
;
.ret = err_no_error;
; --------------------------------------
;   パラメータセット
; --------------------------------------
IF .handeye==1 THEN
.have = 0;
.rot90 = -90
.rot135 = -135
.rot180 = -180
ELSE
.have = 1; 
.rot90 = 90
.rot135 = 135
.rot180 = 180
END
;
.sp = 100
.sp2 = 80
ABS.SPEED .robot_no:  ON
SPEED .sp MM/S ALWAYS
;
.accu = 1
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
ACCURACY 1 ALWAYS
; --------------------------------------
;   リトライフラグリセット
; --------------------------------------
vchk_retry = 0
start:
;
; --------------------------------------
;   ターゲット位置を基準登録＆計測実施
; --------------------------------------
CALL vision_omron(.cam_no,.sce_no,.robot_no,.handeye,.have,1,.correct_no,0,.ret)
IF .ret<>0 GOTO end
CALL vision_omron(.cam_no,.sce_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
IF .ret<>0 GOTO end
POINT/OAT vwork[.correct_no,1] = v_master[.correct_no,1]; 計測結果はOAT回転していないものとする
;
; --------------------------------------
;   ロボット位置＆計測結果を保存
; --------------------------------------
POINT vcheck_point1[.cam_no] = S_HERE(.robot_no)
POINT vcheck_work1[.cam_no] = vwork[.correct_no,1]
;
; --------------------------------------------------
;  ターゲット位置を90°,180°回転させた補正位置を作成
; --------------------------------------------------
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot90)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu[.cam_no]); 現在値を90°回転させた位置
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot135)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_tyuu2[.cam_no]); 現在値を135°回転させた位置
POINT vwork[.correct_no,1] = vcheck_work1[.cam_no]+RZ(.rot180)
CALL vcorrect(&vcheck_point1[.cam_no],.correct_no,0,&vcheck_point2[.cam_no]); 現在値を180°回転させた位置
;
IF .nige<>0 THEN
POINT .app1[.cam_no] = TRANS(,,.nige)+vcheck_point1[.cam_no]
POINT vcheck_tyuu[.cam_no] = TRANS(,,.nige)+vcheck_tyuu[.cam_no]
POINT vcheck_tyuu2[.cam_no] = TRANS(,,.nige)+vcheck_tyuu2[.cam_no]
POINT .app2[.cam_no] = TRANS(,,.nige)+vcheck_point2[.cam_no]
ZL3LMOVE .app1[.cam_no],1,1; 現在位置上空
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ABS.SPEED .robot_no:  ON
SPEED .sp2 MM/S
ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
ELSE
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
END
BREAK
ABS.SPEED .robot_no:  ON
SPEED .sp2 MM/S
JMOVE vcheck_point2[.cam_no]; 180°回転した位置
BREAK
; --------------------------------------------------
;  180°回転した位置で再度ビジョン計測
; --------------------------------------------------
TWAIT 0.5
CALL vision_omron(.cam_no,.sce_no,.robot_no,.handeye,.have,0,.correct_no,0,.ret)
IF .ret<>0 THEN
vchk_retry = 0
GOTO return;
END
;
; --------------------------------------------------
;  0°・180°での計測結果のXY座標のみを取り出し
; --------------------------------------------------
IF .handeye==1 THEN
POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
POINT vcheck_temp[.cam_no] = vcam_tool[.cam_no]; 現在のキャリブデータをバックアップ
POINT vcam_tool[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vcam_tool[.cam_no]; ズレ量を補正
END
ELSE
POINT .p1 = TRANS(DX(vcheck_work1[.cam_no]),DY(vcheck_work1[.cam_no]))
POINT .p2 = TRANS(DX(vwork[.correct_no,1]),DY(vwork[.correct_no,1]))
POINT vcheck_dist[.cam_no] = -.p2+.p1; 2つの結果の距離（ズレ量）
vcheck_x[.cam_no] = DX(vcheck_dist[.cam_no])/2
vcheck_y[.cam_no] = DY(vcheck_dist[.cam_no])/2
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
POINT vcheck_temp[.cam_no] = vision_frm[.cam_no]; 現在のキャリブデータをバックアップ
POINT vision_frm[.cam_no] = TRANS(vcheck_x[.cam_no],vcheck_y[.cam_no])+vision_frm[.cam_no]; ズレ量を補正
END
END
;
PRINT /X2,"X ACCURACY = ",vcheck_x[.cam_no],"mm"
PRINT /X2,"Y ACCURACY = ",vcheck_y[.cam_no],"mm"
IF ABS(vcheck_x[.cam_no])>0.1 OR ABS(vcheck_y[.cam_no])>0.1 THEN
vchk_retry = vchk_retry+1;
IF vchk_retry>=5 THEN
PRINT /X2,"Calib check error. check vision recognition."
ELSE
PRINT /X2,"Execute calib re-check, because accuracy is over 0.1mm"
END
ELSE
vchk_retry = 0;
PRINT /X2,"Calib check OK."
END
;
; --------------------------------------------------
;  元の位置に戻る
; --------------------------------------------------
return:
IF .nige<>0 THEN
ZL3LMOVE .app2[.cam_no],1,1; 180°回転した位置上空
BREAK
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
BREAK
ZL3LMOVE .app1[.cam_no],1,1; 開始位置上空
ELSE
ZL3LMOVE vcheck_tyuu2[.cam_no],1,1; 中間点2
BREAK
ZL3LMOVE vcheck_tyuu[.cam_no],1,1; 中間点
END
BREAK
JMOVE vcheck_point1[.cam_no]; 開始位置
BREAK
IF vchk_retry>=5 THEN
.ret = err_vis_chkng; 精度チェックエラー
RETURN
END
IF vchk_retry>0 GOTO start; リトライ実施
end:
ABS.SPEED .robot_no:  OFF
vcalchk_nige[.cam_no] = .nige
.END
.PROGRAM vcalib_comp(.cam_no,.ret); キャリブレーション完了
; FUNCTION: キャリブ完了処理(フレーム作成)
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_result_ng[9999] = OFF; シミュレータNGフラグ[ID]
IF vsim_result_ng[9999]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
.ret = err_vis_calend
END
RETURN
END
;
.$vsend = "CAE,"+$ENCODE(/I1,.cam_no)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション完了エラー"
.ret = err_vis_calend
END
.END
.PROGRAM vcalib_exe(.robot,.cam_no,.mes_no,.handeye,.&target,.dist,.nige,.&tool_p,.ret); キャリブレーション実行
; FUNCTION: キャリブレーション
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .cam_no  カメラ番号
;           .mes_no  計測番号
;           .handeye ハンドアイ:1, 固定:0
;           .target  ターゲット位置
;           .dist    移動距離
;           .nige    逃げ高さ
;           .tool_p  ツール位置
;           .ret     計測結果
;
.ret = err_no_error;
;
.sp = 100
ABS.SPEED .robot:  ON
CALL setl3speed(.sp,TRUE)
;
.accu = 1
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
ACCURACY 1 ALWAYS
;
; ----------------------------------------------------
;   キャリブ原点はダイレクトティーチで教えておくこと
; ----------------------------------------------------
POINT vcalib_o[.cam_no] = S_HERE(.robot); ダイレクトティーチの点を原点とする
;
; ----------------------------------------------------
;   K-VFinderへキャリブレーション開始を伝える
; ----------------------------------------------------
CALL vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
IF .ret!=err_no_error GOTO end
;
; -------------------------------------------
;   原点へ移動（変換値：フランジ位置を記憶）
; -------------------------------------------
JMOVE vcalib_o[.cam_no]; O計測点
BREAK
;
; ----------------------
;   原点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,1,.ret); 原点計測
JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
IF .ret!=err_no_error GOTO end
;  
; -----------------------------------------------------
;   ツールX+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
POINT vcalib_x[.cam_no] = vcalib_o[.cam_no]+TRANS(.dist); 変換値の計算(X+)
POINT/EXT vcalib_x[.cam_no] = vcalib_o[.cam_no]
JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
JMOVE vcalib_x[.cam_no]; X+計測点
BREAK
;
; ----------------------
;   X点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,2,.ret); X点計測
JMOVE TRANS(,,.nige)+vcalib_x[.cam_no]; アプローチ位置
IF .ret!=err_no_error GOTO end
;
; -----------------------------------------------------
;   ツールY+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
POINT vcalib_y[.cam_no] = vcalib_o[.cam_no]+TRANS(,.dist); 変換値の計算(Y+)
POINT/EXT vcalib_y[.cam_no] = vcalib_o[.cam_no]
JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
JMOVE vcalib_y[.cam_no]; Y+計測点
BREAK
;
; ----------------------
;   Y点でビジョン計測
; ----------------------
TWAIT 1; ロボット停止待ち
CALL vcalib_vis(.cam_no,3,.ret); Y点計測
JMOVE TRANS(,,.nige)+vcalib_y[.cam_no]; アプローチ位置
IF .ret!=err_no_error GOTO end
;
; ---------------------------------------------------------------
;   K-VFinderにキャリブレーション完了を伝え、フレームを作成する
; ---------------------------------------------------------------
CALL vcalib_comp(.cam_no,.ret); キャリブレーション完了
IF .ret!=err_no_error GOTO end
;
IF .handeye==OFF THEN
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
ELSE
; ----------------------------------------------------------------------------------------------
;   カメラツール位置の生成(ハンドアイ）
; ----------------------------------------------------------------------------------------------
POINT vcalh[.cam_no] = .target
POINT .v = vcalh[.cam_no]+.tool_p; ツール込みでのターゲット位置
POINT vcam_o[.cam_no] = -vcalib_o[.cam_no]+.v
POINT vcam_x[.cam_no] = -vcalib_x[.cam_no]+.v
POINT vcam_y[.cam_no] = -vcalib_y[.cam_no]+.v
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vcam_tool[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]);
END
; ----------------------------------------------------------------------------------------------
;   キャリブレーションで使用したパラメータをカメラ番号ごとに保存(vcalib_checkで使用)
; ----------------------------------------------------------------------------------------------
vcal_robot[.cam_no] = .robot;     ロボット番号
vcal_mes[.cam_no] = .mes_no;      計測番号
vcal_handeye[.cam_no] = .handeye; ハンドアイフラグ
vcal_dist[.cam_no] = .dist;       移動距離記憶
vcal_nige[.cam_no] = .nige;       逃げ量記憶
POINT vcal_tool[.cam_no] = .tool_p; ツール記憶
CALL vlog_calib(.cam_no,.handeye,0); ログ
;
end:
;
; -------------------------------------------
;   原点へ戻る
; -------------------------------------------
JMOVE TRANS(,,.nige)+vcalib_o[.cam_no]; アプローチ位置
JMOVE vcalib_o[.cam_no]; O計測点
BREAK
ABS.SPEED .robot:  OFF
.END
.PROGRAM vcalib_exe_cv(.rno,.cam_no,.cvno,.cvdist,.&tool_p,.&target1,.&target2,.&target3,.ret)
; FUNCTION: コンベアビジョンキャリブレーション
; NOTE    : ver1.0.0[17/03/27]
;
; ----------------------------------------------
;   ロボット動作なし・CV軸値は位置変数に含まない
; ----------------------------------------------
.ret = err_no_error;
;
; ----------------------------------------------
;   ティーチした3点の距離チェック
; ----------------------------------------------
.dist1 = DISTANCE(.target1,.target2);
.dist2 = DISTANCE(.target2,.target3);
.dist3 = DISTANCE(.target3,.target1);
IF (.dist1<0.1 OR .dist2<0.1 OR .dist3<0.1) THEN
.ret = err_vis_cvcal
RETURN
END
;
POINT vcalib_o[.cam_no] = .target1
POINT vcalib_x[.cam_no] = .target2
POINT vcalib_y[.cam_no] = .target3
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
; ----------------------------------------------------------------------------------------------
;   キャリブレーションで使用したパラメータをカメラ番号ごとに保存
; ----------------------------------------------------------------------------------------------
vcal_robot[.cam_no] = .rno;     ロボット番号
vcal_mes[.cam_no] = .cvno;      計測番号(にコンベア番号を入れる)
vcal_handeye[.cam_no] = 0;      固定カメラ
vcal_dist[.cam_no] = .cvdist;   CV移動距離記憶
vcal_nige[.cam_no] = 0;         逃げ量=0
POINT vcal_tool[.cam_no] = .tool_p; ツール記憶
.END
.PROGRAM vcalib_exe_mn(.robot,.cam_no,.handeye,.&grab_pos,.&target_o,.&target_x,.&target_y,.&tool_p,.ret)
; FUNCTION: キャリブレーション(他社ビジョン手動)
; NOTE    : ver1.0.0.0[16/07/06]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .cam_no  カメラ番号
;           .handeye ハンドアイ:1, 固定:0
;           .grab_pos 撮影位置
;           .target_o ターゲット原点位置
;           .target_x ターゲットX位置
;           .target_y ターゲットY位置
;           .tool_p  ツール位置
;           .ret     計測結果
;
.ret = err_no_error;
;
; -------------------------------------------
;   タブレットからターゲットのO,X,Y三点を取得
; -------------------------------------------
POINT vcalib_o[.cam_no] = .target_o
POINT vcalib_x[.cam_no] = .target_x
POINT vcalib_y[.cam_no] = .target_y
IF .handeye==OFF THEN
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
ELSE
; ----------------------------------------------------------------------------------------------
;   カメラツール位置の生成(ハンドアイ）
; ----------------------------------------------------------------------------------------------
POINT .v_o = vcalib_o[.cam_no]+.tool_p; ツール込みでのターゲット位置
POINT .v_x = vcalib_x[.cam_no]+.tool_p
POINT .v_y = vcalib_y[.cam_no]+.tool_p
POINT vcam_o[.cam_no] = -.grab_pos+.v_o
POINT vcam_x[.cam_no] = -.grab_pos+.v_x
POINT vcam_y[.cam_no] = -.grab_pos+.v_y
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vcam_tool[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]);
END
; ----------------------------------------------------------------------------------------------
;   キャリブレーションで使用したパラメータをカメラ番号ごとに保存(vcalib_checkで使用)
; ----------------------------------------------------------------------------------------------
vcal_robot[.cam_no] = .robot;     ロボット番号
vcal_mes[.cam_no] = 0;      計測番号
vcal_handeye[.cam_no] = .handeye; ハンドアイフラグ
vcal_dist[.cam_no] = 0;       移動距離記憶
vcal_nige[.cam_no] = 0;       逃げ量記憶
POINT vcal_tool[.cam_no] = .tool_p; ツール記憶
.END
.PROGRAM vcalib_om_x(.robot,.dist,.nige,.ret); オムロンキャリブレーション実行
; FUNCTION: オムロンキャリブレーション1回目
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .dist    移動距離
;           .nige    逃げ高さ
;           .ret     計測結果
;
.ret = err_no_error;
;
.sp = 100
ABS.SPEED .robot:  ON
SPEED .sp MM/S ALWAYS
;
.accu = 1
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
ACCURACY 1 ALWAYS
;
; ----------------------------------------------------
;   キャリブ原点はダイレクトティーチで教えておくこと
; ----------------------------------------------------
POINT vcal_om_o = S_HERE(.robot); ダイレクトティーチの点を原点とする
;
; -------------------------------------------
;   原点へ移動（変換値：フランジ位置を記憶）
; -------------------------------------------
JMOVE vcal_om_o; O計測点
BREAK
JMOVE TRANS(,,.nige)+vcal_om_o; アプローチ位置
;
; -----------------------------------------------------
;   ツールX+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
POINT vcal_om_x = vcal_om_o+TRANS(.dist); 変換値の計算(X+)
JMOVE TRANS(,,.nige)+vcal_om_x; アプローチ位置
JMOVE vcal_om_x; X+計測点
BREAK
vcal_om_st = 1
.END
.PROGRAM vcalib_om_y(.robot,.cam_no,.handeye,.&target,.dist,.nige,.&tool_p,.ret); オムロンキャリブレーション実行
; FUNCTION: オムロンキャリブレーション2回目
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .robot   ロボット番号 下アーム:1, 上アーム:2
;           .cam_no  カメラ番号
;           .handeye ハンドアイ:1, 固定:0
;           .target  ターゲット位置
;           .dist    移動距離
;           .nige    逃げ高さ
;           .tool_p  ツール位置
;           .ret     計測結果
;
;
.ret = err_no_error;
;
; -----------------------------------------------------
;   キャリブレーション1回目実行チェック
; -----------------------------------------------------
NOEXIST_SET_R vcal_om_st = 0; キャリブ1回目で生成されている変数
IF vcal_om_st==0 THEN
.ret = err_vis_calom;キャリブレーションNG(キャリブレーション1回目未実施)
RETURN
END
.dist_ox = DISTANCE(vcal_om_o,vcal_om_x)
.dist_err = ABS(.dist-.dist_ox); キャリブ1回目の.distと2回目の.distのズレ
IF .dist_err>0.1 THEN
.ret = err_vis_calst; キャリブレーションNG(移動距離違い)
RETURN
END
;
.sp = 100
ABS.SPEED .robot:  ON
SPEED .sp MM/S ALWAYS
;
.accu = 1
ZL3TRN .accur[1]=.accu,.accu,.accu,.accu,.accu,.accu; [1:X(mm),2:Y(mm),3:Z(mm),4:R1(deg),5-6:対象外]
ZL3ACCURACY .accur[1] ALWAYS; 精度を設定
ACCURACY 1 ALWAYS
; -----------------------------------------------------
;   ツールY+方向へ移動（移動距離はパラメータ設定参照）
; -----------------------------------------------------
JMOVE TRANS(,,.nige)+vcal_om_x; アプローチ位置
POINT vcal_om_y = vcal_om_o+TRANS(,.dist); 変換値の計算(Y+)
JMOVE TRANS(,,.nige)+vcal_om_y; アプローチ位置
JMOVE vcal_om_y; Y+計測点
BREAK
;
POINT vcalib_o[.cam_no] = vcal_om_o
POINT vcalib_x[.cam_no] = vcal_om_x
POINT vcalib_y[.cam_no] = vcal_om_y
;
IF .handeye==OFF THEN
;
; ----------------------------------------------
;   固定カメラビジョンフレーム生成
; ----------------------------------------------
POINT vcam_o[.cam_no] = vcalib_o[.cam_no]+.tool_p; ツール込でのターゲット位置
POINT vcam_x[.cam_no] = vcalib_x[.cam_no]+.tool_p
POINT vcam_y[.cam_no] = vcalib_y[.cam_no]+.tool_p
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vision_frm[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]); フレーム作成
ELSE
; ----------------------------------------------------------------------------------------------
;   カメラツール位置の生成(ハンドアイ）
; ----------------------------------------------------------------------------------------------
POINT vcalh[.cam_no] = .target
POINT .v = vcalh[.cam_no]+.tool_p; ツール込みでのターゲット位置
POINT vcam_o[.cam_no] = -vcalib_o[.cam_no]+.v
POINT vcam_x[.cam_no] = -vcalib_x[.cam_no]+.v
POINT vcam_y[.cam_no] = -vcalib_y[.cam_no]+.v
POINT/Z vcam_x[.cam_no] = vcam_o[.cam_no]; 変換後にＺ位置合わせ(OATのAに数値が入らないように)
POINT/Z vcam_y[.cam_no] = vcam_o[.cam_no]
POINT vcam_tool[.cam_no] = FRAME(vcam_o[.cam_no],vcam_x[.cam_no],vcam_y[.cam_no],vcam_o[.cam_no]);
END
; ----------------------------------------------------------------------------------------------
;   キャリブレーションで使用したパラメータをカメラ番号ごとに保存(vcalib_checkで使用)
; ----------------------------------------------------------------------------------------------
vcal_robot[.cam_no] = .robot;     ロボット番号
vcal_mes[.cam_no] = 0;      計測番号
vcal_handeye[.cam_no] = .handeye; ハンドアイフラグ
vcal_dist[.cam_no] = .dist;       移動距離記憶
vcal_nige[.cam_no] = .nige;       逃げ量記憶
POINT vcal_tool[.cam_no] = .tool_p; ツール記憶
;
vcal_om_st = 0
.END
.PROGRAM vcalib_start(.cam_no,.mes_no,.dist,.ret); キャリブレーション開始
; FUNCTION: キャリブ開始処理
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_result_ng[9997] = OFF; シミュレータNGフラグ[ID]
IF vsim_result_ng[9997]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
.ret = err_vis_calst
END
RETURN
END
;
.$vsend = "CAS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+","+$ENCODE(/F6.2,.dist)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション開始エラー"
.ret = err_vis_calst;
END
.END
.PROGRAM vcalib_vis(.cam_no,.count,.ret); キャリブレーション計測
; FUNCTION: キャリブ計測処理
; NOTE    : ver1.0.0[15/10/02]
;
.ret = err_no_error
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_result_ng[9998] = OFF; シミュレータNGフラグ[ID]
IF vsim_result_ng[9998]<>OFF THEN
; シミュレーションNG (認識個数0個エラー)
.ret = err_vis_calmeas
END
RETURN
END
;
.$vsend = "CAL,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I1,.count)+",";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF v.err<>0 THEN
PRINT /X2,"キャリブレーション計測エラー"
.ret = err_vis_calmeas;
END
.END
.PROGRAM vcheck_connect(.ret)
; FUNCTION: ビジョンPC接続チェック
; NOTE    : ver1.0.0[16/10/18]
;
.ret = err_no_error;
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_connect_ng = OFF; シミュレータNGフラグ[ID]
IF vsim_connect_ng<>OFF THEN
.ret = err_vis_connect; 接続異常
END
RETURN
END
; ----------------------------------------
;   計測実施して通信異常かどうか確認する
; ----------------------------------------
.$vsend = "DUARO_VISION_CHECK";送信データ作成
CALL vcommand(.$vsend);
CALL vget_result;
IF 88<=v.err AND v.err<=99 THEN; 計測結果チェック(通信異常でないか)
PRINT /X2,"ビジョンPC接続異常"
.ret = err_vis_connect; 接続異常
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン接続エラー
END
.END
.PROGRAM vchk_pc_start(.res,.task_no)
; FUNCTION: ＰＣプログラム起動確認
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER @vtime_vchk_pc = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF TASK(.task_no)==1 GOTO next
TWAIT ascycle;                           ＰＣプログラム起動待ち
UNTIL UTIMER(@vtime_vchk_pc)>=vpc_start_time;     タイムアウトするまで
next:
DO;                                        条件ループ開始
IF SIG(-ix_pc_start) GOTO end
TWAIT ascycle;                           ＰＣプログラム起動確認信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_vchk_pc)>=vpc_start_time;     タイムアウトするまで
.res = -1
end:
.END
.PROGRAM vchk_sig_change(.res,.sig_no,.timeout)
; FUNCTION: タイムアウト付き信号状態変更待ち
; NOTE    : ver1.0.0[12/10/18]
.res = 0
UTIMER @vtime_vchk_sig = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(.sig_no) GOTO end
TWAIT ascycle;                           信号の状態変更待ち
UNTIL UTIMER(@vtime_vchk_sig)>=.timeout;           タイムアウトするまで
.res = -1
end:
.END
.PROGRAM vcom_init(); ビジョン変数初期化
; FUNCTION: ビジョン変数初期化
; NOTE    : ver1.0.0[15/10/02]
; ---------------------------------------------------
;   変数定義されていない場合のみパラメータを設定する
;   変更したい場合は変数を直接変更する
; ---------------------------------------------------
;
NOEXIST_SET_R vlog = 1;                                  ログ保存モード[0:保存なし,1:エラーログ保存,2:全ログ保存]
NOEXIST_SET_R vlog_max = 1000;                           ログ最大数
FOR .i = 1 TO 2
NOEXIST_SET_R vlog_cnt[.i] = 1;                        ログカウンタ
END
;
NOEXIST_SET_R ascycle = 0.016;                           ASサイクル待ち時間
NOEXIST_SET_R vsend_port = 50003;                        送信ポート番号
NOEXIST_SET_R vrecv_port = 50002;                        受信ポート番号
NOEXIST_SET_R vsend_ip[0] = 192;                         送信先IPアドレス
NOEXIST_SET_R vsend_ip[1] = 168
NOEXIST_SET_R vsend_ip[2] = 0
NOEXIST_SET_R vsend_ip[3] = 10
NOEXIST_SET_R vsend_num = 1;                             送信文字列数
NOEXIST_SET_R vrecv_str_num = 32;                        受信文字列長
NOEXIST_SET_R vsend_timeout = 0.5;                       送信タイムアウト時間(sec)
NOEXIST_SET_R vrecv_timeout = 3;                         受信タイムアウト時間(sec)
vrecv_timeout = MAXVAL(vrecv_timeout,3);                 受信タイムアウト最小値 3sec
NOEXIST_SET_R ix_vcomm_start = 2101;                     通信開始信号
NOEXIST_SET_R ix_vcomm_busy = 2102;                      通信中信号
NOEXIST_SET_R ix_vcomm_comp = 2103;                      通信完了信号
NOEXIST_SET_R ix_vcomm_error = 2104;                     通信エラー信号
NOEXIST_SET_R ix_vrecv_start = 2105;                     受信開始信号
NOEXIST_SET_R ix_vrecv_comp = 2106;                      受信完了信号
NOEXIST_SET_R ix_pc_start = 2107;                        ＰＣプログラム起動確認信号
NOEXIST_SET_R ix_vsend_only = 2108;                      通信時送信のみ(受信なし)信号
NOEXIST_SET_R ix_vrecv_only = 2109;                      通信時受信のみ(送信なし)信号
NOEXIST_SET_R vpc_start_time = 2;                        ＰＣプログラム起動待ちタイムアウト(sec)
vpc_start_time = MAXVAL(vpc_start_time,2);               ＰＣプログラム起動待ちタイムアウト最小値 2sec
NOEXIST_SET_R vhandshake_time = 2;                       ハンドシェイクタイムアウト(sec)
vhandshake_time = MAXVAL(vhandshake_time,2);             ハンドシェイクタイムアウト最小値 2sec
NOEXIST_SET_R vretry_max = 1;                            リトライ回数
NOEXIST_SET_R vretry_wait = 0.5;                         リトライ前の待ち時間(sec)
NOEXIST_SET_R verr_ok = 0;                               通信結果(ＯＫ, "0"以外はＮＧ)
NOEXIST_SET_R verr_socket = 87;                          通信結果(接続エラー（TCP）)
NOEXIST_SET_R verr_onlymode = 88;                        通信結果(片方向通信モードエラー)
NOEXIST_SET_R verr_unknown = 89;                         通信結果(不明なエラー)
NOEXIST_SET_R verr_init = 90;                            通信結果(初期値, 未計測)
NOEXIST_SET_R verr_send = 91;                            通信結果(送信エラー)
NOEXIST_SET_R verr_recv = 92;                            通信結果(受信エラー)
NOEXIST_SET_R verr_timeout1 = 93;                        通信結果(受信開始待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout2 = 94;                        通信結果(受信完了待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout3 = 95;                        通信結果(受信ＰＧ起動待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout4 = 96;                        通信結果(送信ＰＧ起動待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout5 = 97;                        通信結果(通信完了(実行中)待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout6 = 98;                        通信結果(送信ＰＧ実行待ちタイムアウトエラー)
NOEXIST_SET_R verr_timeout7 = 99;                        通信結果(通信完了待ちタイムアウトエラー)
NOEXIST_SET_R vis_init = -99999;                         検出結果初期値
NOEXIST_SET_R vis_err_vid = 2;                           検出結果(K-VFinderのエラーコード[2:画像取込エラー])
NOEXIST_SET_R vis_err_num = 6;                           検出結果(K-VFinderのエラーコード[6:検出個数0個エラー])
NOEXIST_SET_R z_vselect = 0;                             ビジョン切り替えフラグ
NOEXIST_SET_R vcom_retry_max = 0;                        通信リトライ回数(初期値:0)
NOEXIST_SET_R vr_log_cnt = 0;                            通信リトライログカウンタ
.END
.PROGRAM vcom_retry_log(.$string,.err)
; FUNCTION: 通信リトライログ作成
; NOTE    : ver1.0.0[16/07/07]
.$log = $DATE(3)+" "+$TIME+" [retry] "+$ENCODE(/I,.err)+" : "+.$string;ログデータ作成
$vr_log[vr_log_cnt] = .$log;            ログデータ保存
vr_log_cnt = vr_log_cnt+1;             ログカウンタカウントアップ
IF vr_log_cnt>vlog_max THEN;            ログカウンタ上限超えの為リセット
vr_log_cnt = 1
END
.END
.PROGRAM vcommand(.$command); ビジョンコマンド送信
; FUNCTION: ビジョンコマンド送信[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vget_resultと合わせて使用する
; --------------------------------
;
IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
CALL vcom_init;                          ビジョン変数初期化
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
RETURN;                                  送信ＰＧ起動待ちタイムアウトエラー
END
END
SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
RETURN;                                    通信完了待ちタイムアウトエラー)
start:
$vsend_data[0] = .$command;送信データ作成
CALL vinit;                                計測結果クリア
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
IF .chk!=0 THEN
CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
RETURN;                                  送信ＰＧ実行待ちタイムアウトエラー
END
.END
.PROGRAM vcorrect(.&base_pos,.id2,.id3,.&adj_pos); 補正位置作成
; FUNCTION: 補正位置作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: 補正前の教示位置,ビジョンID2,ビジョンID3,補正後の教示位置(返却値)
;           ビジョンID2,3はタブレットに準拠
;
IF .id2<>0 AND .id3<>0 THEN; id2とid3両方にIDが割り振られていた場合
.result2 = vwork_res[.id2,1]; 結果番号(固定)
.result3 = vwork_res[.id3,1]; 結果番号(ハンドアイ)
IF vc_have[.id2]<>OFF AND vc_have[.id3]<>OFF THEN
; 把持していない(id2)＋把持していない(id3) の場合、2点でフレーム作成して補正（装置間補正と同等）
POINT .vtable_m = FRAME(v_master[.id3,1],v_master[.id2,1],TRANS(,,100)+v_master[.id3,1],v_master[.id3,1])
POINT .vtable_m = .vtable_m+RX(-90); マスターフレーム
;
POINT/Z vwork[.id2,1] = v_master[.id2,1]
POINT/Z vwork[.id3,1] = v_master[.id3,1]
POINT .vtable_w = FRAME(vwork[.id3,1],vwork[.id2,1],TRANS(,,100)+vwork[.id3,1],vwork[.id3,1])
POINT .vtable_w = .vtable_w+RX(-90); 現在のフレーム
;
POINT .valfa = -.vtable_m+.base_pos; マスターフレームから見た教示位置
POINT .adj_pos = .vtable_w+.valfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
.a = DEXT(.adj_pos,4)
.t = DEXT(.adj_pos,6)
POINT/OAT .adj_pos = TRANS(,,,.a+.t,,0)
ELSE
; 固定カメラ把持ワーク(id2)＋ハンドアイカメラ置きワーク(id3)
POINT .have_m = .base_pos+v_master[.id2,.result2]; ティーチ位置でベースから見たマスターワーク把持位置
POINT .rslt_m = -v_master[.id3,.result3]+.have_m; マスターハンドアイ計測結果から見たマスターワーク把持位置
;
POINT .valfa = vwork[.id3,.result3]+.rslt_m; 現在ハンドアイ計測結果から見たマスターワーク把持位置
POINT .adj_pos = .valfa-vwork[.id2,.result2]; 現在ワーク位置に対するロボット位置(ツール先端)
END
ELSE
IF .id2==0 THEN
.id = .id3; id3だけIDが割り振られていた場合
ELSE
.id = .id2; id2だけIDが割り振られていた場合
END
;
.result = vwork_res[.id,1];   結果番号
IF vc_handeye[.id]<>OFF THEN; ハンドアイフラグ(ハンドアイ:1, 固定:0)
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; ハンドアイカメラ・把持あり
POINT .valfa = v_master[.id,.result]-vwork[.id,1]; マスターと現在のワーク位置差分
POINT .adj_pos = .base_pos+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
ELSE
; ハンドアイカメラ・把持なし
POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
ELSE
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; 固定カメラ・把持あり
POINT .valfa = .base_pos+v_master[.id,.result]; ティーチ位置でベースから見たマスターワーク把持位置
POINT .adj_pos = .valfa-vwork[.id,1]; 現在ワーク位置に対するロボット位置(ツール先端)
ELSE
; 固定カメラ・把持なし
POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
END
END
POINT/EXT .adj_pos = .base_pos
.END
.PROGRAM vcorrect_cv(.&base_pos,.id2,.id3,.&adj_pos,.cvno,.cvwork,.cvvalue,.&cvfrm,.ret)
; FUNCTION: コンベア同期ありの補正計算
; NOTE    : ver1.0.0[17/03/27]
;
IF .id2<>0 AND .id3<>0 THEN;
; どちらもID入っていたら補正不可
.ret = err_vis_contng; ビジョン補正作業続行不可
ELSE
IF .id2==0 THEN
.id = .id3; id3だけIDが割り振られていた場合
ELSE
.id = .id2; id2だけIDが割り振られていた場合
END
;
IF vc_handeye[.id]<>OFF THEN; ハンドアイフラグ(ハンドアイ:1, 固定:0)
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; ハンドアイカメラ・把持あり
.ret = err_vis_contng; ビジョン補正作業続行不可
ELSE
; ハンドアイカメラ・把持なし
.result = vwork_res[.id,1];   結果番号
POINT .valfa = -v_master[.id,.result]+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = vwork[.id,1]+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
ELSE
IF vc_have[.id]==OFF THEN;  把持フラグ(把持あり:0, 把持なし:1)
; 固定カメラ・把持あり
.ret = err_vis_contng; ビジョン補正作業続行不可
ELSE
; 固定カメラ・把持なし
POINT .cv_vector = .cvfrm+TRANS(.cvvalue-vcal_dist[vc_cam[.id]])-.cvfrm; ベースから見たCV進行方向の「マスター登録時CV値 - キャリブ時CV値」ベクトル
;
.result = cv_vres[.cvno,.cvwork];   結果番号
POINT .cv_vmaster = .cv_vector+v_master[.id,.result]; v_masterはキャリブ時CV値のものなので,マスター登録時CV値の値に変換
POINT .cv_vwork = .cv_vector+cv_vwork[.cvno,.cvwork]; vworkもv_master同様に変換 (cv_vworkはバッファ管理側からもらう)
;        
POINT .valfa = -.cv_vmaster+.base_pos; マスターワーク位置から見たティーチ位置
POINT .adj_pos = .cv_vwork+.valfa; 現在ワーク位置に対するロボット位置(ツール先端)
END
END
END
POINT/EXT .adj_pos = .base_pos
.END
.PROGRAM vcorrect_table(.&base_pos,.id,.&adj_pos); 装置間補正
; FUNCTION: 装置間補正
; NOTE    : ver1.0.0[15/10/02]
;
; 1点目と2点目の装置IDを取得
CALL convert_vid(mode_add,1,.id,.equip_id1)
CALL convert_vid(mode_add,2,.id,.equip_id2)
;
POINT .vtable_m = FRAME(v_master[.equip_id1,1],v_master[.equip_id2,1],TRANS(,,100)+v_master[.equip_id1,1],v_master[.equip_id1,1])
POINT .vtable_m = .vtable_m+RX(-90); マスター穴で作成したフレーム
;
POINT/Z vwork[.equip_id1,1] = v_master[.equip_id1,1]
POINT/Z vwork[.equip_id2,1] = v_master[.equip_id2,1]
POINT .vtable_w = FRAME(vwork[.equip_id1,1],vwork[.equip_id2,1],TRANS(,,100)+vwork[.equip_id1,1],vwork[.equip_id1,1])
POINT .vtable_w = .vtable_w+RX(-90); 現在の穴で作成したフレーム
;
POINT .valfa = -.vtable_m+.base_pos; マスターフレームから見た教示位置
POINT .adj_pos = .vtable_w+.valfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
.a = DEXT(.adj_pos,4)
.t = DEXT(.adj_pos,6)
POINT/OAT .adj_pos = TRANS(,,,.a+.t,,0)
POINT/EXT .adj_pos = .base_pos
;
.END
.PROGRAM vget_result(); ビジョン結果取得
; FUNCTION: ビジョン結果取得
; NOTE    : ver1.0.0[15/10/02]
; --------------------------------
;   vcommandと合わせて使用する
; --------------------------------
;
v.error_cnt = 0;                           エラーカウント初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
start:
DO;                                        条件ループ開始
IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
UNTIL UTIMER(.@vtime)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
GOTO end
check:
IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
CALL vstr_decode($vrecv_data[0]);        文字列分解
$vres = $vst[0];                         計測結果代入
SCASE $vres OF
SVALUE "OK":;                           ビジョン結果ＯＫ
v.err = verr_ok
SVALUE "NG":;                           ビジョン計測ＮＧ
v.err = VAL($vst[1]);                  エラーコード取得
PRINT /X2,"ビジョンＮＧ : v.err = ",v.err
SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
ANY :;                                  不明なＮＧ
CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
END
ELSE;                                      通信ＮＧ
$vres = $vcom_res
v.err = v.com_err
END
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vilock_end(.rno)
; FUNCTION: ビジョン計測インターロック終了（マクロ用）
; NOTE    : ver1.0.0[17/08/23]
IF .rno==1 THEN
SIGNAL -ix_vloc_mas;                          マスター処理完了
ELSE
SIGNAL -ix_vloc_sla;                          スレーブ処理完了
END
.END
.PROGRAM vilock_start(.rno)
; FUNCTION: ビジョン計測インターロック開始（マクロ用）
; NOTE    : ver1.0.0[17/08/23]
CALL vcom_init;                              ビジョン変数初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+1; インターロックタイムアウト時間(sec)
retry:
IF .rno==1 THEN
SIGNAL ix_vloc_mas;                           マスター計測処理中ON
TWAIT ascycle;                           
UTIMER @vtime_mas = 0;                    タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vloc_sla)==ON GOTO loc;       スレーブ側が計測していなければ
IF SIG(ix_vloc_now)==ON GOTO loc;        スレーブ側がロック確認中（デッドロックになったらマスター優先で抜ける）
TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_mas)>=.vtimeout;      タイムアウトするまで
.ret = err_vis_locmas;                     インターロックタイムアウトエラー(マスター)
SIGNAL -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
SIGNAL ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
data_execute = FALSE
CALL update_error(.ret)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
flg_exec_first_ = TRUE
GOTO retry; エラー停止/再開
ELSE
SIGNAL ix_vloc_sla,ix_vloc_now;               スレーブ計測処理中ON,スレーブロック確認中ON
TWAIT ascycle;                           
UTIMER @vtime_sla = 0;                    タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vloc_mas)==ON GOTO loc;       マスター側が計測していなければ 
TWAIT ascycle;                           インターロック中信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_sla)>=.vtimeout;      タイムアウトするまで
.ret = err_vis_locsla;                     インターロックタイムアウトエラー(スレーブ) 
SIGNAL -ix_vloc_mas,-ix_vloc_sla,-ix_vloc_now;タイムアウト発生したらインターロック初期化
SIGNAL ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
data_execute = FALSE
CALL update_error(.ret)
DO
TWAIT ascycle
UNTIL (data_execute==TRUE)
flg_exec_first_ = TRUE
GOTO retry; エラー停止/再開
END
loc:
IF .rno==2 THEN
SIGNAL -ix_vloc_now;                          スレーブロック確認中OFF
END
.END
.PROGRAM vimage(.cam_no,.shutter,.$filename); ビジョン画像保存
; FUNCTION: ビジョン画像保存[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/11/29]
; ARGUMENT: カメラ番号, シャッター速度
;
IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
CALL vcom_init;                          ビジョン変数初期化
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
RETURN;                                送信ＰＧ起動待ちタイムアウトエラー)
END
END
SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER @vtime_vision = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_vision)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
RETURN;                                    通信完了待ちタイムアウトエラー)
start:
$vsend_data[0] = "IMG,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/F6.2,.shutter)+","+.$filename+",";送信データ作成
CALL vinit;                                計測結果クリア
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
IF .chk!=0 THEN
CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
RETURN;                                  送信ＰＧ実行待ちタイムアウトエラー)
END
.END
.PROGRAM vinit()
; FUNCTION: ビジョン計測結果クリア
; NOTE    : ver1.0.0[12/10/18]
$vres = ""
v.err = verr_init;                         計測結果クリア[90:未計測, 0:OK, 0<>:NG]
v.num = 0;                                 検出個数クリア
POINT vision[1] = TRANS(vis_init,vis_init);検出結果クリア
POINT vpos[1] = vision[1]
.END
.PROGRAM vis_change(.mode); ビジョン変更
; FUNCTION: ビジョン変更
; NOTE    : ver1.0.1[16/10/18]
; ---------------------------------------------------
;   .mode 0:K-VFinder, 1:OMRON
; ---------------------------------------------------
;
CASE .mode OF
VALUE 0: ; K-VFinder
vsend_port = 50003;                      送信ポート番号
vrecv_port = 50002;                      受信ポート番号
vrecv_str_num = 32;                      受信文字列長
;
vsend_ip[0] = 192
vsend_ip[1] = 168
vsend_ip[2] = 0
vsend_ip[3] = 10
;
VALUE 1: ; OMRON
vsend_port = 9876;                       送信ポート番号
vrecv_port = 9876;                       受信ポート番号
vrecv_str_num = 255;                     受信文字列長
vcontrol_char = 13;                      制御文字コード
;
NOEXIST_SET_R vack_timeout = 1;          ACKチェックタイムアウト
NOEXIST_SET_R tcp_debug = 0;             TCP通信デバッグモード(0:通常通信 1:デバッグ通信)
sock_notclose = 1;                       通信ごとにソケットをクローズするか(0:クローズする 1:クローズしない)
NOEXIST_SET_R recog0_err = 1;            検出個数0をエラーとする
;
NOEXIST_SET_R vsend_ip1[0] = 192;         カメラ1IP
NOEXIST_SET_R vsend_ip1[1] = 168
NOEXIST_SET_R vsend_ip1[2] = 0
NOEXIST_SET_R vsend_ip1[3] = 10
; 
NOEXIST_SET_R vsend_ip2[0] = 192;         カメラ2IP(コントローラ内蔵型センサの場合、この数値を変更)
NOEXIST_SET_R vsend_ip2[1] = 168
NOEXIST_SET_R vsend_ip2[2] = 0
NOEXIST_SET_R vsend_ip2[3] = 10
END
;
CALL vcom_init
;
IF TASK(1003) THEN; 通信PGが動作いたら止める
PCABORT 3: 
END
;
z_vselect = .mode;                          他社ビジョン選択
.END
.PROGRAM vis_excalchkom(.rno,.camno,.sceno,.height,.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーション精度チェック実行
;引数：ロボット番号、カメラ番号、シーン番号、逃げ高さ
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gs_excalchk_err = .ret
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vis_excalchkom()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vis_excalchkom()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vis_excalchkom()-> .sceno=",.sceno
PRINT "TASKNO=",TASKNO,",vis_excalchkom()-> .height=",.height
PRINT "TASKNO=",TASKNO,",vis_excalchkom()-> .ret=",.ret
END
.$cam = $ENCODE(/I1,.camno); カメラ番号
.$chk_r = "vcal_robot["+.$cam+"]"
.$chk_h = "vcal_handeye["+.$cam+"]"
IF EXISTDATA(.$chk_r,R)==OFF || EXISTDATA(.$chk_h,R)==OFF THEN
.ret = err_vis_nocalib; キャリブレーション未実施
gs_excalchk_err = .ret
CALL error_log(.ret)
RETURN
END
.robot_no = vcal_robot[.camno];
.handeye = vcal_handeye[.camno];
.correct_no = 1000;
.nige = .height;
; --------------------------------------
;   キャリブレーション精度チェック動作
; --------------------------------------
CALL vcalib_check_om(.camno,.sceno,.robot_no,.handeye,.correct_no,.nige,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
gs_excalchk_err = .ret
.END
.PROGRAM vis_execalxom(.rno,.len,.height,.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーションX実行
;引数：ロボット番号、移動距離、移動前逃げ高さ
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gs_excalib_err = .ret
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vis_execalxom()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vis_execalxom()-> .len=",.len
PRINT "TASKNO=",TASKNO,",vis_execalxom()-> .height=",.height
PRINT "TASKNO=",TASKNO,",vis_execalxom()-> .ret=",.ret
END
; calib実行
CALL vcalib_om_x(.rno,.len,.height,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
gs_excalib_err = .ret
.END
.PROGRAM vis_execalyom(.rno,.camno,.camtype,.&target,.len,.height,.&tool_p,.ret)
;-------------------------------- 
;機能：OMRONカメラキャリブレーションY実行
;引数：ロボット番号、計測番号、カメラ種類、ターゲット位置(XYZR1)、移動距離、移動前逃げ高さ、ツール(XY)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gs_excalib_err = .ret
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .camtype=",.camtype
DECOMPOSE .buf1[1] = .target
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_x=",.buf1[1]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_y=",.buf1[2]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_z=",.buf1[3]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_o(r1)=",.buf1[4]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_a=",.buf1[5]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .pos_t=",.buf1[6]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .len=",.len
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .height=",.height
DECOMPOSE .buf2[1] = .tool_p
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_x=",.buf2[1]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_y=",.buf2[2]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_z=",.buf2[3]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_o=",.buf2[4]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_a=",.buf2[5]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .tool_t=",.buf2[6]
PRINT "TASKNO=",TASKNO,",vis_execalyom()-> .ret=",.ret
END
; calib実行
CALL vcalib_om_y(.rno,.camno,.camtype,.&target,.len,.height,.&tool_p,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
gs_excalib_err = .ret
.END
.PROGRAM vis_execvcal(.rno,.camno,.cvno,.cvdist,.&tool_p,.&target1,.&target2,.&target3,.ret)
;-------------------------------- 
;機能：コンベアビジョンキャリブレーション
;引数：ロボット番号、カメラ番号、コンベア番号、CV移動距離、ツール、1〜3点目のターゲット位置
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .cvno=",.cvno
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .cvdist=",.cvdist
DECOMPOSE .buf1[1] = .tool_p
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .tool_x=",.buf1[1]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .tool_y=",.buf1[2]
DECOMPOSE .buf2[1] = .target1
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_x[1]=",.buf2[1]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_y[1]=",.buf2[2]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_z[1]=",.buf2[3]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_o(r1)[1]=",.buf2[4]
DECOMPOSE .buf3[1] = .target2
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_x[2]=",.buf3[1]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_y[2]=",.buf3[2]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_z[2]=",.buf3[3]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_o(r1)[2]=",.buf3[4]
DECOMPOSE .buf4[1] = .target3
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_x[3]=",.buf4[1]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_y[3]=",.buf4[2]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_z[3]=",.buf4[3]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .pos_o(r1)[3]=",.buf4[4]
PRINT "TASKNO=",TASKNO,",vis_execvcal()-> .ret=",.ret
END
; calib実行
CALL vcalib_exe_cv(.rno,.camno,.cvno,.cvdist,.&tool_p,.&target1,.&target2,.&target3,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
.END
.PROGRAM vis_measure_om();オムロン ビジョン計測指令送信
; FUNCTION: オムロン 現在のシーン番号で計測
; NOTE    : ver1.0.0[13/02/27]
;
;
SIGNAL -ix_vcomm_error,-ix_vcomm_comp
$vsend_data[0] = "MEASURE";                送信データ作成
CALL vis_tcp(1,1,1);                           送信開始
CALL vis_wait_tcp;                             受信待ち
IF v.com_error==verr_ok AND $vcom_res=="" THEN;  通信ＯＫ
;   判定処理をvset_pos_omに移行
ELSE;                                      通信ＮＧ
v.err = v.com_error
$vres = $vcom_res
END
.END
.PROGRAM vis_tcp(.send_timeout,.ack_timeout,.recv_timeout)
; FUNCTION: ビジョン装置へ指令を送信
; NOTE    : ver1.0.0[13/02/27]
IF TASK(1003)<>1 THEN;                     送受信ＰＧ起動確認
CALL vcom_init
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: tcp_vcom_vision;            送受信ＰＧ起動
CALL vchk_pc_start(.chk,1003)
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vis");送信ＰＧ起動待ちタイムアウトエラー
RETURN;                                送信ＰＧ起動待ちタイムアウトエラー)
END
END
WHILE SIG(ix_vcomm_busy) DO
TWAIT ascycle;                           通信中信号ＯＦＦ待ち
END
vsend_timeout = .send_timeout;             送信タイムアウト時間(sec)
vack_timeout = .ack_timeout;              ＡＣＫタイムアウト時間(sec)
vrecv_timeout = .recv_timeout;             受信タイムアウト時間(sec)
CALL vinit; 初期化
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vpc_start_time)
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","vchk_sig_change エラー in vis");送信ＰＧ起動待ちタイムアウトエラー
HALT;                                    停止(送信ＰＧ実行待ちタイムアウトエラー)
END
.END
.PROGRAM vis_wait_tcp()
; FUNCTION: ビジョン装置から結果を受信
; NOTE    : ver1.0.0[13/02/27]
.vcomm_timeout = vsend_timeout+vack_timeout+vrecv_timeout*2; 送受信タイムアウト時間設定(sec)
UTIMER .@vcomm_time = 0;                   送受信タイマーリセット
DO;                                        条件ループ開始
IF SIG(ix_vcomm_error) OR SIG(ix_vcomm_comp) GOTO end
TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
UNTIL UTIMER(.@vcomm_time)>=.vcomm_timeout; タイムアウトするまで
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
PCABORT 3:  ;                                通信プログラム強制停止
WAIT TASK(1003)<>1;                        通信プログラム停止待ち
HALT
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vision(.cam_no,.mes_no); ビジョン計測
; FUNCTION: ビジョン計測[⇒ K-VFinder]
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: カメラ番号, 計測番号
;
IF TASK(1003)<>1 THEN;                     送信ＰＧ起動確認
CALL vcom_init;                          ビジョン変数初期化
SIGNAL ix_pc_start;                      ＰＣプログラム起動確認信号ＯＮ
PCEXECUTE 3: pc3_vcom_send;              送信ＰＧ起動
CALL vchk_pc_start(.chk,1003);           送信ＰＧ[PC3]起動待ち
IF .chk!=0 THEN
CALL vset_error(verr_timeout4,"Timeout","送信ＰＧ起動待ちタイムアウトエラー in vision");送信ＰＧ起動待ちタイムアウトエラー
RETURN;                                送信ＰＧ起動待ちタイムアウトエラー)
END
END
SIGNAL -ix_vcomm_error;                    ※メインＰＧでエラー信号を使用する場合はここでリセットしない※
SIGNAL -ix_vcomm_comp;                     ※メインＰＧで通信完了信号を使用する場合はここでリセットしない※
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER @vtime_vision = 0;                        タイマーリセット
DO;                                        条件ループ開始
IF SIG(-ix_vcomm_busy) AND SIG(-ix_vcomm_comp) GOTO start
TWAIT ascycle;                           通信中信号＆通信完了信号ＯＦＦ待ち
UNTIL UTIMER(@vtime_vision)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout5,"Timeout","通信完了待ちタイムアウトエラー in vision")
RETURN;                                    通信完了待ちタイムアウトエラー)
start:
$vsend_data[0] = "VIS,"+$ENCODE(/I1,.cam_no)+","+$ENCODE(/I3,.mes_no)+",";送信データ作成
v.cam_no = .cam_no;                        カメラ番号代入
v.mes_no = .mes_no;                        計測番号代入
CALL vinit;                                計測結果クリア
SIGNAL ix_vcomm_start;                     通信開始信号ＯＮ
CALL vchk_sig_change(.chk,-ix_vcomm_start,vhandshake_time);通信開始信号ＯＦＦ待ち(通信実行確認)
IF .chk!=0 THEN
CALL vset_error(verr_timeout6,"Timeout","送信ＰＧ実行待ちタイムアウトエラー in vision");送信ＰＧ実行待ちタイムアウトエラー
RETURN;                                  送信ＰＧ実行待ちタイムアウトエラー)
END
.END
.PROGRAM vision_excalchk(.rno,.camno,.height,.ret)
;-------------------------------- 
;機能：カメラキャリブレーション精度チェック実行
;引数：ロボット番号、カメラ番号、逃げ高さ
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gs_excalchk_err = .ret
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .height=",.height
PRINT "TASKNO=",TASKNO,",vision_excalchk()-> .ret=",.ret
END
.$cam = $ENCODE(/I1,.camno); カメラ番号
.$chk_r = "vcal_robot["+.$cam+"]"
.$chk_m = "vcal_mes["+.$cam+"]"
.$chk_h = "vcal_handeye["+.$cam+"]"
IF EXISTDATA(.$chk_r,R)==OFF || EXISTDATA(.$chk_h,R)==OFF || EXISTDATA(.$chk_m,R)==OFF THEN
.ret = err_vis_nocalib; キャリブレーション未実施
gs_excalchk_err = .ret
CALL error_log(.ret)
RETURN
END
.mes_no = vcal_mes[.camno];
.robot_no = vcal_robot[.camno];
.handeye = vcal_handeye[.camno];
.correct_no = 1000;
.nige = .height;
; --------------------------------------
;   キャリブレーション精度チェック動作
; --------------------------------------
CALL vcalib_check(.camno,.mes_no,.robot_no,.handeye,.correct_no,.nige,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
gs_excalchk_err = .ret
.END
.PROGRAM vision_exe(.cam_no,.mes_no,.robot,.handeye,.have,.teach,.id,.calpos,.ret); ビジョン計測プログラム
; FUNCTION: ビジョン計測プログラム
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .cam_no  カメラ番号
;           .mes_no  計測番号
;           .robot   ロボット番号 下アーム:1, 上アーム:2
;           .handeye ハンドアイ:1, 固定:0
;           .have    把持あり:0, 把持なし:1
;           .teach   ティーチング用計測:1, 通常計測:0
;           .id      ビジョンID
;           .calpos  位置補正用計測:0, 装置補正1点目:1, 装置補正2点目:2, 3:ビジョンなし装置補正
;           .ret     計測結果
;
; ---------------------------------------------------------------------------------------
;   ※ビジョン計測プログラム実行条件（ロボット計測位置）
;   // 固定カメラ・把持なし      ：固定カメラ視野内にロボットがいないこと
;   // 固定カメラ・把持あり      ：把持ワークがカメラ視野内に写っている位置
;   // ハンドアイカメラ・把持なし：カメラ視野内にワークが写る位置
;   // ハンドアイカメラ・把持あり：位置不問・ワークを把持して視野内にワークがあること
; ---------------------------------------------------------------------------------------
;
.ret = err_no_error
.vid = .id
.retry_num = 0
retry:
vchk_task = TASKNO
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_result_ng[.vid] = OFF; シミュレータNGフラグ[ID]
IF vsim_result_ng[.vid]==OFF THEN
; シミュレーションOK
IF .teach<>OFF THEN
POINT v_master[.vid,1] = TRANS(0,0,0,0,0,0)
vc_cam[.vid] = .cam_no
vc_mes[.vid] = .mes_no
vc_rob[.vid] = .robot
vc_handeye[.vid] = .handeye
vc_have[.vid] = .have
IF .calpos<>0 THEN
; 装置補正マスター登録ログ
CALL vlog_cal(.vid,0,1,1)
END
ELSE
.sx = vsim_x
.sy = vsim_y
.sz = vsim_z
IF .calpos==2 THEN
.sx = .sx+100; 装置補正２点目用
END
POINT vwork[.vid,1] = TRANS(.sx,.sy,.sz,0,0,0)
; 装置補正用計測実行フラグ
IF .calpos==1 OR .calpos==2 THEN
vequip_flg[.id] = ON
END
END
vwork_res[.vid,1] = 1;
v.num = 1
ELSE
; シミュレーションNG (認識個数0個エラー)
.ret = err_vis_recog0
POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化
; 装置補正用計測実行フラグ
IF .calpos==1 OR .calpos==2 THEN
vequip_flg[.id] = OFF
END
vwork_res[.vid,1] = 1;
v.num = 0
END
RETURN
END
;
; ------------
;   計測実施
; ------------
IF .teach==OFF THEN
vcom_retry = 0;              通常計測時通信リトライカウントリセット
ELSE
vcom_retry = vcom_retry_max; マスター登録時通信リトライなし
END
com_retry:
;
CALL vision(.cam_no,.mes_no);                     ビジョン計測
IF v.err==verr_init THEN;
CALL vset_pos(.robot,.handeye,.have,.teach,.vid); 計測完了待兼補正位置作成
END
;
IF vchk_task<>TASKNO THEN
.retry_num = .retry_num+1
TWAIT vretry_wait
err_count = err_count+1
IF .retry_num<=vretry_max GOTO retry
v.err = 89
END
IF v.err<>0 THEN; 計測結果チェック
IF err_vis_only<v.err+4000 AND v.err+4000<err_vis_tout7 THEN; エラーコードが4088〜4099であれば通信エラー
.$str = "cam:"+$ENCODE(/I1,.cam_no)+" mes:"+$ENCODE(/I3,.mes_no)+" id:"+$ENCODE(/I4,.vid)+" retry:"+$ENCODE(/I1,vcom_retry)
CALL vcom_retry_log(.$str,v.err)
vcom_retry = vcom_retry+1
IF vcom_retry>vcom_retry_max GOTO com_retend
UTIMER .@timeout = 0
DO
IF (TASK(1003)<>1 AND TASK(1004)<>1) GOTO com_retry; 通信異常時はPC3,4が停止するのを待つ(前回の通信完全終了待ち)
TWAIT ascycle
UNTIL (UTIMER(.@timeout)>vrecv_timeout)
CALL vcom_retry_log("リトライ時PC停止エラー",v.err)
END
com_retend:
;
PRINT /X2,"ビジョン計測エラー"
.ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
; 装置補正用計測実行フラグ
IF (.calpos==1 OR .calpos==2) AND .teach==OFF THEN
vequip_flg[.id] = OFF
END
RETURN; ビジョン計測エラー
END
;
IF .teach<>OFF THEN
; -----------------------------
;   ティーチ時はマスター登録
; -----------------------------
IF v.num<>1 THEN
PRINT /X2,"計測個数が複数あります"
.ret = err_vis_teach; マスター登録時複数認識
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン計測エラー
END
;
; ------------------------------
;   計測位置（フランジ）を記憶
; ------------------------------
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT vis_point[.cam_no,.mes_no] = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
;
; ---------------------------------------
;   1個目の計測結果をマスターとして登録
; ---------------------------------------
.res_no = v.result_no[1]; 結果番号
;
.$cam = $ENCODE(/I1,.cam_no); カメラ番号
IF .handeye<>OFF THEN
.$chk = "vcam_tool["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
.ret = err_vis_nocalib; キャリブレーションエラー
RETURN;
END
IF .have==OFF THEN
; ハンドアイカメラ・把持あり
POINT v_master[.vid,.res_no] = vcam_tool[.cam_no]+vision[1]; フランジから見たワーク位置
ELSE
; ハンドアイカメラ・把持なし
POINT v_master[.vid,.res_no] = vis_point[.cam_no,.mes_no]+vcam_tool[.cam_no]+vision[1]; ベースから見たワーク位置
END
ELSE
.$chk = "vision_frm["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
.ret = err_vis_nocalib; キャリブレーションエラー
RETURN;
END
IF .have==OFF THEN
; 固定カメラ・把持あり
POINT v_master[.vid,.res_no] = -vis_point[.cam_no,.mes_no]+vision_frm[.cam_no]+vision[1]; フランジから見たワーク把持位置
ELSE
; 固定カメラ・把持なし
POINT v_master[.vid,.res_no] = vision_frm[.cam_no]+vision[1]; ベースから見たワーク位置
END
END
CALL vlog_master(.vid); ログ
;
; --------------------
;   補正番号に紐付け
; --------------------
vc_cam[.vid] = .cam_no
vc_mes[.vid] = .mes_no
vc_rob[.vid] = .robot
vc_handeye[.vid] = .handeye
vc_have[.vid] = .have
IF .calpos<>0 THEN
; 装置補正マスター登録ログ
CALL vlog_cal(.vid,0,1,1)
END
ELSE
; 装置補正用計測実行フラグ
IF .calpos==1 OR .calpos==2 THEN
vequip_flg[.id] = ON
END
END
;
.END
.PROGRAM vision_execalib(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
;-------------------------------- 
;機能：カメラキャリブレーション実行
;引数：ロボット番号、カメラ番号、計測番号、カメラ種類、ターゲット位置(XYZR1)、移動距離、移動前逃げ高さ、ツール(XY)
;戻値：成否
;-------------------------------- 
.ret = err_no_error
gs_excalib_err = .ret
IF debug.prt.visio==TRUE THEN
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .rno=",.rno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camno=",.camno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .calno=",.calno
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .camtype=",.camtype
DECOMPOSE .buf1[1] = .target
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_x=",.buf1[1]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_y=",.buf1[2]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_z=",.buf1[3]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_o(r1)=",.buf1[4]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_a=",.buf1[5]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .pos_t=",.buf1[6]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .len=",.len
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .height=",.height
DECOMPOSE .buf2[1] = .tool_p
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_x=",.buf2[1]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_y=",.buf2[2]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_z=",.buf2[3]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_o=",.buf2[4]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_a=",.buf2[5]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .tool_t=",.buf2[6]
PRINT "TASKNO=",TASKNO,",vision_execalib()-> .ret=",.ret
END
; calib実行
CALL vcalib_exe(.rno,.camno,.calno,.camtype,.&target,.len,.height,.&tool_p,.ret)
IF log_error_ena<>FALSE AND .ret>err_no_error THEN
CALL error_log(.ret)
END
gs_excalib_err = .ret
.END
.PROGRAM vision_main(.rno,.id,.camno,.calno,.camtype,.holdtype,.calpos,.recflg,.ret)
;-------------------------------- 
;機能：ビジョン実行
;引数：ロボット番号、ビジョンID、カメラ番号、計測番号、カメラ種類、把持種類、計測箇所(0:ワーク計測、1:装置一点目、2:装置2点目)、マスター登録フラグ
;戻値：成否
;-------------------------------- 
.ret = err_no_error
CALL vcom_init;                              ビジョン変数初期化
SIGNAL -ix_result_vng[.rno];                    ビジョン結果ＮＧ信号初期化
;
IF debug.prt.visio==TRUE THEN
PRINT "vision_main()->.rno=",.rno
PRINT "vision_main()->.id=",.id
PRINT "vision_main()->.camno=",.camno
PRINT "vision_main()->.calno=",.calno
PRINT "vision_main()->.camtype=",.camtype
PRINT "vision_main()->.holdtype=",.holdtype
PRINT "vision_main()->.calpos=",.calpos
PRINT "vision_main()->.recflg=",.recflg
END
;
CASE z_vselect OF
VALUE 0: ; K-VFinder
CALL vision_exe(.camno,.calno,.rno,.camtype,.holdtype,.recflg,.id,.calpos,.ret)
VALUE 1: ; OMRON
CALL vision_omron(.camno,.calno,.rno,.camtype,.holdtype,.recflg,.id,.calpos,.ret)
END
IF .ret<>err_no_error THEN
SIGNAL ix_result_vng[.rno];                   ビジョンＮＧ信号ＯＮ
END
IF .recflg==OFF AND .ret==err_no_error THEN
POINT vision_shift[.rno,.id] = -v_master[.id,1]+vwork[.id,1]
ELSE
;マスター登録時はシフト量0
POINT vision_shift[.rno,.id] = TRANS(0,0,0,0,0,0)
END
; マクロで使えるように前回の計測結果をここで記憶
v.pre_id = .id;          前回の補正ID
v.pre_rno[.id] = .rno;   前回のロボット番号
v.pre_camno[.id] = .camno;      前回のカメラ番号
v.pre_calno[.id] = .calno;      前回の計測番号
v.pre_camtype[.id] = .camtype;  前回のカメラ種別
v.pre_holdtype[.id] = .holdtype;前回の把持種別
v.pre_calpos[.id] = .calpos;    前回の計測種別
POINT v.pre_shift[.id] = vision_shift[.rno,.id]; 前回の補正量
IF .recflg==OFF THEN
NOEXIST_SET_L vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期値
POINT v.pre_work[.id] = vwork[.id,1];            前回の計測結果
ELSE
NOEXIST_SET_L v_master[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期値
POINT v.pre_work[.id] = v_master[.id,1];         前回の計測結果    
END
NOEXIST_SET_R vwork_res[.id,1] = 1
v.pre_resno[.id] = vwork_res[.id,1];       前回の結果番号
IF .ret<>err_no_error THEN
v.pre_result[.id] = 0; 前回の結果/NG
ELSE
v.pre_result[.id] = 1; 前回の結果/OK
END
v.pre_num[.id] = v.num;  前回の結果個数
;
IF debug.prt.visio==TRUE THEN
DECOMPOSE .buf[1] = vision_shift[.rno,.id]
PRINT "vision_main()->XYR1(TRANS)=",$ENCODE(.buf[1]),",",$ENCODE(.buf[2]),",",$ENCODE(.buf[3]),",",$ENCODE(.buf[4]),",",$ENCODE(.buf[5]),",",$ENCODE(.buf[6])
END
.END
.PROGRAM vision_omron(.cam_no,.sce_no,.robot,.handeye,.have,.teach,.id,.calpos,.ret)
; ---------------------------------------------------------------------------------------
;   ※ビジョン計測プログラム実行条件（ロボット計測位置）
;   // 固定カメラ・把持なし      ：固定カメラ視野内にロボットがいないこと
;   // 固定カメラ・把持あり      ：把持ワークがカメラ視野内に写っている位置
;   // ハンドアイカメラ・把持なし：カメラ視野内にワークが写る位置
;   // ハンドアイカメラ・把持あり：位置不問・ワークを把持して視野内にワークがあること
; ---------------------------------------------------------------------------------------
;
.ret = err_no_error
.vid = .id
; ------------
; シミュレーション
; ------------
IF SYSDATA(ZSIMENV)==2 OR vsim_flg==ON THEN; SYSDATA(ZSIMENV)->0=実機/2:シミュレータ
NOEXIST_SET_R vsim_result_ng[.vid] = OFF; シミュレータNGフラグ[ID]
IF vsim_result_ng[.vid]==OFF THEN
; シミュレーションOK
IF .teach<>OFF THEN
POINT v_master[.vid,1] = TRANS(0,0,0,0,0,0)
vc_cam[.vid] = .cam_no
vc_mes[.vid] = .sce_no
vc_rob[.vid] = .robot
vc_handeye[.vid] = .handeye
vc_have[.vid] = .have
IF .calpos<>0 THEN
; 装置補正マスター登録ログ
CALL vlog_cal(.vid,0,1,1)
END
ELSE
.sx = vsim_x
.sy = vsim_y
.sz = vsim_z
IF .calpos==2 THEN
.sx = .sx+100; 装置補正２点目用
END
POINT vwork[.vid,1] = TRANS(.sx,.sy,.sz,0,0,0)
; 装置補正用計測実行フラグ
IF .calpos==1 OR .calpos==2 THEN
vequip_flg[.id] = ON
END
END
vwork_res[.vid,1] = 1;
ELSE
; シミュレーションNG (認識個数0個エラー)
.ret = err_vis_recog0
POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化
END
RETURN
END
; ------------
;   計測実施
; ------------
CALL vcom_init
v.cam_no = .cam_no;                        カメラ番号代入
v.mes_no = .sce_no;                        シーン番号代入
CALL scene_change_om(.sce_no)
IF v.err<>verr_init AND v.err<>0 THEN; 計測結果チェック
PRINT /X2,"ビジョン計測エラー in scene_change_om"
.ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン計測エラー
END
TWAIT ascycle
CALL vis_measure_om
IF v.err==verr_init OR v.err==0 THEN;
CALL vset_pos_om(.robot,.handeye,.have,.teach,.vid); 計測完了待兼補正位置作成
ELSE
PRINT /X2,"ビジョン計測エラー in vis_measure_om"
.ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン計測エラー
END
IF v.err<>0 AND v.err<>verr_init THEN; 計測結果チェック
PRINT /X2,"ビジョン計測エラー in vset_pos_om"
.ret = v.err+4000; ビジョンエラー/ｴﾗｰｺｰﾄﾞ+4000
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン計測エラー
END
;
IF .teach<>OFF THEN
; -----------------------------
;   ティーチ時はマスター登録
; -----------------------------
IF v.num<>1 THEN
PRINT /X2,"計測個数が複数あります"
.ret = err_vis_teach; マスター登録時複数認識
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN; ビジョン計測エラー
END
;
; ------------------------------
;   計測位置（フランジ）を記憶
; ------------------------------
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT vis_point[.cam_no,.sce_no] = S_HERE(.robot)-.tool_now;ロボット計測位置(フランジ)
;
; ---------------------------------------
;   1個目の計測結果をマスターとして登録
; ---------------------------------------
.res_no = 1; 結果番号
;
.$cam = $ENCODE(/I1,.cam_no); カメラ番号
IF .handeye<>OFF THEN
.$chk = "vcam_tool["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
.ret = err_vis_nocalib; キャリブレーションエラー
RETURN;
END
IF .have==OFF THEN
; ハンドアイカメラ・把持あり
POINT v_master[.vid,.res_no] = vcam_tool[.cam_no]+vision[1]; フランジから見たワーク位置
ELSE
; ハンドアイカメラ・把持なし
POINT v_master[.vid,.res_no] = vis_point[.cam_no,.sce_no]+vcam_tool[.cam_no]+vision[1]; ベースから見たワーク位置
END
ELSE
.$chk = "vision_frm["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
.ret = err_vis_nocalib; キャリブレーションエラー
RETURN;
END
IF .have==OFF THEN
; 固定カメラ・把持あり
POINT v_master[.vid,.res_no] = -vis_point[.cam_no,.sce_no]+vision_frm[.cam_no]+vision[1]; フランジから見たワーク把持位置
ELSE
; 固定カメラ・把持なし
POINT v_master[.vid,.res_no] = vision_frm[.cam_no]+vision[1]; ベースから見たワーク位置
END
END
;
; --------------------
;   補正番号に紐付け
; --------------------
vc_cam[.vid] = .cam_no
vc_mes[.vid] = .sce_no
vc_rob[.vid] = .robot
vc_handeye[.vid] = .handeye
vc_have[.vid] = .have
IF .calpos<>0 THEN
; 装置補正マスター登録ログ
CALL vlog_cal(.vid,0,1,1)
END
ELSE
; 装置補正用計測実行フラグ
IF .calpos==1 OR .calpos==2 THEN
vequip_flg[.id] = ON
END
END
.END
.PROGRAM vless_calexe(.&in_pos,.&tool_p,.id,.&out_pos)
;-------------------------------- 
;機能：ビジョンなし装置補正実行
;引数：補正前データ、実行時ツール、ビジョンＩＤ、補正後データ
;戻値：なし
;-------------------------------- 
POINT .sm1 = v_master[.id,1]+vless_tool[.id] ;
POINT .sm2 = v_master[.id,2]+vless_tool[.id] ;
POINT .sw1 = vwork[.id,1]+.tool_p;
POINT .sw2 = vwork[.id,2]+.tool_p;
;
POINT/Z .sm2 = .sm1; 2点目のZは1点目に合わせる
POINT vless_frm_m = FRAME(.sm1,.sm2,TRANS(,,100)+.sm1,.sm1)
POINT vless_frm_m = vless_frm_m+RX(-90); マスター穴で作成したフレーム
;
POINT/Z .sw2 = .sw1; 2点目のZは1点目に合わせる
POINT vless_frm_w = FRAME(.sw1,.sw2,TRANS(,,100)+.sw1,.sw1)
POINT vless_frm_w = vless_frm_w+RX(-90); 現在の穴で作成したフレーム
;
POINT .salfa = -vless_frm_m+.in_pos; マスターフレームから見た教示位置
POINT .out_pos = vless_frm_w+.salfa; 現在のフレーム位置に対する補正位置
;
; OATのT部分に値が入っていると双腕ロボットが動作できないので、Tを0にしてOを回転させる
.a = DEXT(.out_pos,4)
.t = DEXT(.out_pos,6)
POINT/OAT .out_pos = TRANS(,,,.a+.t,,0)
POINT/EXT .out_pos = .in_pos
;
.END
.PROGRAM vless_calmain(.rno,.id,.&tool_p,.&p1,.&p2,.recflg,.ret)
;-------------------------------- 
;機能：ビジョンなし装置補正メイン
;引数：ロボット番号、ビジョンID、ツール、１点目座標、２点目座標、マスター登録フラグ(1:マスター登録,2:補正実行）
;戻値：成否
;-------------------------------- 
.ret = err_no_error
IF debug.prt.visio==TRUE THEN
PRINT "vless_calmain()->.rno=",.rno
PRINT "vless_calmain()->.id=",.id
DECOMPOSE .buf1[1] = .tool_p
PRINT "vless_calmain()->.tool_x=",.buf1[1]
PRINT "vless_calmain()->.tool_y=",.buf1[2]
PRINT "vless_calmain()->.tool_z=",.buf1[3]
PRINT "vless_calmain()->.tool_o=",.buf1[4]
PRINT "vless_calmain()->.tool_a=",.buf1[5]
PRINT "vless_calmain()->.tool_t=",.buf1[6]
DECOMPOSE .buf2[1] = .p1
PRINT "vless_calmain()->.p1_x=",.buf2[1]
PRINT "vless_calmain()->.p1_y=",.buf2[2]
PRINT "vless_calmain()->.p1_z=",.buf2[3]
PRINT "vless_calmain()->.p1_o=",.buf2[4]
PRINT "vless_calmain()->.p1_a=",.buf2[5]
PRINT "vless_calmain()->.p1_t=",.buf2[6]
DECOMPOSE .buf3[1] = .p2
PRINT "vless_calmain()->.p2_x=",.buf3[1]
PRINT "vless_calmain()->.p2_y=",.buf3[2]
PRINT "vless_calmain()->.p2_z=",.buf3[3]
PRINT "vless_calmain()->.p2_o=",.buf3[4]
PRINT "vless_calmain()->.p2_a=",.buf3[5]
PRINT "vless_calmain()->.p2_t=",.buf3[6]
PRINT "vless_calmain()->.recflg=",.recflg
END
; ID変換
CALL convert_vid(mode_add,type_device3,.id,.vid);      calposに合わせてID変換 calpos=3:ID=3001〜3999
IF .recflg==1 THEN
; マスター登録 v_masterを流用　２つ目の引数要素で１点目２点目を判別（ビジョンありはIDで判別しているので注意）
POINT v_master[.vid,1] = .p1
POINT v_master[.vid,2] = .p2
POINT vless_tool[.vid] = .tool_p
CALL vlog_cal(.vid,0,0,1)
ELSE
POINT vwork[.vid,1] = .p1
POINT vwork[.vid,2] = .p2
;
NOEXIST_SET_R vc_chkflg[.id] = OFF
IF vc_chkflg[.id]<>OFF THEN
; 位置ズレチェック
.dist1 = DISTANCE(v_master[.vid,1],vwork[.vid,1]); 装置1点目の位置ズレ量
.dist2 = DISTANCE(v_master[.vid,2],vwork[.vid,2]); 装置2点目の位置ズレ量
NOEXIST_SET_R vc_poschk[.id] = 100
IF .dist1>vc_poschk[.id] OR .dist2>vc_poschk[.id] THEN; 閾値判定
.ret = err_vis_poschk
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN
END
; 距離ズレチェック
.dist1 = DISTANCE(v_master[.vid,1],v_master[.vid,2])
.dist2 = DISTANCE(vwork[.vid,1],vwork[.vid,2])
NOEXIST_SET_R vc_distchk = 5
IF ABS(.dist1-.dist2)>vc_distchk THEN
.ret = err_vis_distchk
IF log_error_ena<>FALSE THEN
CALL error_log(.ret)
END
RETURN
END
END
;第2、第3階層を探索
FOR .i = 1 TO data_l2num
FOR .j = 1 TO data_l3num[.i]
IF data_l3type[.i,.j]==l3type_move THEN
IF data_mode[.i,.j]==mode_jt THEN
;各軸値
ELSE
;変換値
IF .id==data_vision_id1[.i,.j] THEN; 計算実行する装置IDと動作の装置ID(DATA_VISION_ID)が一致
POINT .in_pos = TRANS(data_pos1[.i,.j],data_pos2[.i,.j],data_pos3[.i,.j],data_pos4[.i,.j],0,0); 変換値
CALL vless_calexe(.&in_pos,.&tool_p,.vid,.&out_pos); 装置補正実行
DECOMPOSE .out_p[1] = .out_pos; 補正後の変換値分解
; 補正値を書き換え
data_pos1[.i,.j] = .out_p[1]
data_pos2[.i,.j] = .out_p[2]
data_pos3[.i,.j] = .out_p[3]
data_pos4[.i,.j] = .out_p[4]
data_pos5[.i,.j] = 0
data_pos6[.i,.j] = 0
END
END
END
END
END
; ログのため前回マスター値バックアップ
POINT vless_bk[.vid,1] = v_master[.vid,1]
POINT vless_bk[.vid,2] = v_master[.vid,2]
POINT vless_tool_bk[.vid] = vless_tool[.vid]
; 実行後、装置補正計測結果のマスターを現在値で上書き
POINT v_master[.vid,1] = .p1
POINT v_master[.vid,2] = .p2
POINT vless_tool[.vid] = .tool_p
CALL vlog_cal(.vid,0,0,0)
END
.END
.PROGRAM vlog_cal(.id1,.id2,.vonoff,.master)
;-------------------------------- 
;機能：装置補正ログ
;引数：装置ＩＤ(1点目),装置ＩＤ(2点目), ビジョンあり(1)/なし(0),マスター登録(1)orNot(0)
;戻値：なし
;--------------------------------
NOEXIST_SET_R vlog_cal_cnt = 0;  ログカウンタ
NOEXIST_SET_R vlog_cal_max = 10; ログ最大数   
.$log = $DATE(3)+" "+$TIME+" "; ログデータ作成
IF .master==0 THEN
.$mas = "[EXE]:"
ELSE
.$mas = "[MASTER]:"
END
IF .vonoff==0 THEN
; ビジョンなし
.$vcal = "VLESSCAL"
.id2 = .id1; ２点目のIDはビジョンなしでは関係ない
DECOMPOSE .temp1[1] = v_master[.id1,1]
.$vmas1 = "v_master["+$ENCODE(/I4,.id1)+",1]= "
DECOMPOSE .temp2[1] = v_master[.id1,2]
.$vmas2 = "v_master["+$ENCODE(/I4,.id1)+",2]= "
ELSE
; ビジョンあり
.$vcal = "VCAL"
DECOMPOSE .temp1[1] = v_master[.id1,1]
.$vmas1 = "v_master["+$ENCODE(/I4,.id1)+",1]= "
IF .master==0 THEN; マスター登録の時は１点だけ
DECOMPOSE .temp2[1] = v_master[.id2,1]
.$vmas2 = "v_master["+$ENCODE(/I4,.id2)+",1]= "
END
END
.$log = .$log+.$vcal+.$mas+.$vmas1
.$log = .$log+$ENCODE(/F8.3,.temp1[1])+" "+$ENCODE(/F8.3,.temp1[2])+" "+$ENCODE(/F8.3,.temp1[3])+" "+$ENCODE(/F8.3,.temp1[4])+" "
IF .vonoff==0 OR .master==0 THEN; ビジョンあり,マスター登録は１点だけ
.$log = .$log+.$vmas2
.$log = .$log+$ENCODE(/F8.3,.temp2[1])+" "+$ENCODE(/F8.3,.temp2[2])+" "+$ENCODE(/F8.3,.temp2[3])+" "+$ENCODE(/F8.3,.temp2[4])+" "
END
$vlog_cal[vlog_cal_cnt] = .$log
vlog_cal_cnt = vlog_cal_cnt+1; 次のログへ
IF vlog_cal_cnt>vlog_cal_max THEN
vlog_cal_cnt = 0; 一定数超えたら最初から上書き
END
.END
.PROGRAM vlog_calib(.cam_no,.handeye,.check)
;-------------------------------- 
;機能：キャリブレーションログ
;引数：カメラ番号,ハンドアイ,キャリブレーション精度チェック
;戻値：なし
;--------------------------------
NOEXIST_SET_R vlog_calib_cnt = 0;  ログカウンタ
NOEXIST_SET_R vlog_calib_max = 20; ログ最大数   
.$log = $DATE(3)+" "+$TIME+" "; ログデータ作成
IF .check==0 THEN
; キャリブレーション
.$cal_type = "[CALIB]:"
ELSE
; キャリブレーション精度チェック
.$cal_type = "[CALCHECK]:"
END
IF .handeye==1 THEN
; ハンドアイ
DECOMPOSE .temp1[1] = vcam_tool[.cam_no]
.$logstr = "vcam_tool["+$ENCODE(/I1,.cam_no)+"] = "
ELSE
; 固定カメラ
DECOMPOSE .temp1[1] = vision_frm[.cam_no]
.$logstr = "vision_frm["+$ENCODE(/I1,.cam_no)+"] = "
END
.$log = .$log+.$cal_type+.$logstr
.$log = .$log+$ENCODE(/F8.3,.temp1[1])+" "+$ENCODE(/F8.3,.temp1[2])+" "+$ENCODE(/F8.3,.temp1[3])+" "+$ENCODE(/F8.3,.temp1[4])+" "
$vlog_calib[vlog_calib_cnt] = .$log
vlog_calib_cnt = vlog_calib_cnt+1; 次のログへ
IF vlog_calib_cnt>vlog_calib_max THEN
vlog_calib_cnt = 0; 一定数超えたら最初から上書き
END
.END
.PROGRAM vlog_master(.id)
;-------------------------------- 
;機能：ビジョンマスター登録ログ
;引数：品種ID
;戻値：なし
;--------------------------------
IF .id>=1000 THEN
RETURN
END
NOEXIST_SET_R vlog_mas_cnt = 0;  ログカウンタ
NOEXIST_SET_R vlog_mas_max = 50; ログ最大数   
.$log = $DATE(3)+" "+$TIME+" "; ログデータ作成
DECOMPOSE .temp1[1] = v_master[.id,1]
.$vmas1 = "v_master["+$ENCODE(/I4,.id)+",1]= "
.$log = .$log+.$vmas1
.$log = .$log+$ENCODE(/F8.3,.temp1[1])+" "+$ENCODE(/F8.3,.temp1[2])+" "+$ENCODE(/F8.3,.temp1[3])+" "+$ENCODE(/F8.3,.temp1[4])+" "
$vlog_master[vlog_mas_cnt] = .$log
vlog_mas_cnt = vlog_mas_cnt+1; 次のログへ
IF vlog_mas_cnt>vlog_mas_max THEN
vlog_mas_cnt = 0; 一定数超えたら最初から上書き
END
.END
.PROGRAM vset_error(.err,.$res,.$print)
; FUNCTION: エラーコード＆内容セット
; NOTE    : ver1.0.0[13/02/08]
v.err = .err
$vres = .$res
PRINT /X2,.$print;                         エラー内容表示
SIGNAL ix_vcomm_error;                     エラー信号ＯＮ
.END
.PROGRAM vset_pos(.robot,.handeye,.have,.teach,.id)
; FUNCTION: 補正位置データ作成
; NOTE    : ver1.0.0[15/10/02]
; ARGUMENT: .teach ティーチ時 -1, その他 -1以外
;
v.error_cnt = 0;                           エラーカウント初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER @vtime_vset_pos = 0;                        タイマーリセット
POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化（１個目の結果のみ・複数対応時は必要認識個数分初期化する）
vwork_res[.id,1] = 1;                          結果番号初期化
start:
DO;                                        条件ループ開始
IF SIG(ix_vcomm_comp) OR SIG(ix_vcomm_error) GOTO check
TWAIT ascycle;                           通信完了信号ＯＮまたは通信エラー信号ＯＮ待ち
UNTIL UTIMER(@vtime_vset_pos)>=.vtimeout;          タイムアウトするまで
CALL vset_error(verr_timeout7,"Timeout","通信完了待ちタイムアウトエラー in vset_pos")
GOTO end
check:
IF v.com_err==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
CALL vstr_decode($vrecv_data[0]);        文字列分解
$vres = $vst[0];                         計測結果代入
SCASE $vres OF
SVALUE "OK":;                           ビジョン計測ＯＫ
v.err = verr_ok
GOTO ok
SVALUE "NG":;                           ビジョン計測ＮＧ
v.err = VAL($vst[1]);                  エラーコード取得
PRINT /X2,"ビジョン計測ＮＧ : v.err = ",v.err
IF v.err==vis_err_vid OR v.err==vis_err_num GOTO ng;K-VFinderのエラーコード[2:画像取込エラー, 6:検出個数0個エラー]
SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
ANY :;                                  不明なＮＧ
CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos")
END
GOTO end
ok:; 計測ＯＫの場合補正データ作成
v.num = VAL($vst[1]);                    検出個数取得
IF v.num>0 THEN
FOR .i = 1 TO v.num;                     検出個数分繰り返す
CALL vstr_decode($vrecv_data[.i]);   文字列分解
.vres_no = VAL($vst[0]);             結果番号
.vpos_x = VAL($vst[1]);              Ｘ座標
.vpos_y = VAL($vst[2]);              Ｙ座標
.vpos_t = 0
.vpos_t = VAL($vst[3]);              θ
v.result_no[.i] = .vres_no;          結果番号代入
POINT vision[.i] = TRANS(.vpos_x,.vpos_y,0,.vpos_t); ビジョン座標値(mm)
;
IF .teach==OFF THEN;                 補正位置計算
.$cam = $ENCODE(/I1,v.cam_no);     カメラ番号文字列
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT .h = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
IF .handeye<>OFF THEN
.$chk = "vcam_tool["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
v.err = 5; キャリブレーションエラー
GOTO end;
END
IF .have==OFF THEN
POINT vwork[.id,.i] = vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持あり・フランジから見たワーク位置
ELSE
POINT vwork[.id,.i] = .h+vcam_tool[v.cam_no]+vision[.i]; ハンドアイカメラ把持なし・ベースから見たワーク位置
END
ELSE
.$chk = "vision_frm["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
v.err = 5; キャリブレーションエラー
GOTO end;
END
IF .have==OFF THEN
POINT vwork[.id,.i] = -.h+vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持あり・フランジから見たワーク把持位置
ELSE
POINT vwork[.id,.i] = vision_frm[v.cam_no]+vision[.i]; 固定カメラ把持なし・ベースから見たワーク位置
END
END
vwork_res[.id,.i] = v.result_no[.i]; 結果番号
END
END
END
ELSE;                                      通信ＮＧ
$vres = $vcom_res
v.err = v.com_err
$vcom_err_last = $vres+" cam="+$ENCODE(/I1,v.cam_no)+" mes="+$ENCODE(/I3,v.mes_no); 最後の通信エラー情報をログしておく
END
GOTO end
ng:; 計測ＮＧ[v.err=2(画像取込エラー) or v.err=6(検出個数0個エラー)]の場合リトライ処理
v.error_cnt = v.error_cnt+1;               送受信エラーカウントアップ
IF v.error_cnt>=vretry_max+1 OR ((ZOPTION(6,1)<>0 AND ZOPTION(6,2)<>0) AND (cv_vision[1]!=0 OR cv_vision[2]!=0)) THEN; エラー回数確認(コンベア同期ビジョンはリトライ内なし)
PRINT /X2,"リトライ回数上限エラー"
SIGNAL ix_vcomm_error;                   エラー信号ＯＮ
GOTO end;                                リトライ回数上限超えの為終了
ELSE
PRINT /X2,"計測リトライ : "+$ENCODE(/I2,v.error_cnt)+" 回目"
SIGNAL -ix_vcomm_comp;                   通信完了信号ＯＦＦ
TWAIT vretry_wait;                       リトライ前待ち
SIGNAL ix_vcomm_start;                   通信開始信号ＯＮ
GOTO start;                              通信完了待ち
END
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vset_pos_om(.robot,.handeye,.have,.teach,.id)
; FUNCTION: オムロン 補正位置データ作成
; NOTE    : ver1.0.1[16/07/05]
; ARGUMENT: .teach ティーチ時 -1, その他 -1以外
;
v.error_cnt = 0;                           エラーカウント初期化
.vtimeout = (vsend_timeout+vrecv_timeout)*(vretry_max+1)+0.5;送受信タイムアウト時間(sec)
UTIMER .@vtime = 0;                        タイマーリセット
POINT vwork[.id,1] = TRANS(vis_init,vis_init); 補正位置データ初期化（１個目の結果のみ・複数対応時は必要認識個数分初期化する）
vwork_res[.id,1] = 1;                          結果番号初期化
start:
;受信完了監視処理はvis_wait_tcpで行っているので、ここでする必要はない
check:
IF v.com_error==verr_ok AND $vcom_res=="" THEN;通信ＯＫ
CALL vstr_decode($vrecv_data[0]);        文字列分解
IF vdecode_num<>4 THEN
GOTO ng
END
judge_om = VAL($vst[0]);                         計測結果代入
CASE judge_om OF
VALUE 1:;                           ビジョン計測ＯＫ
v.err = verr_ok
GOTO ok
VALUE -1:;判定NG
v.err = 31
VALUE -13,-14:;検査設定異常
v.err = 32
VALUE -15:;領域外
v.err = 33
ANY :;                                  不明なＮＧ
CALL vset_error(verr_unknown,"UnknownError","ビジョン計測ＮＧ : 不明なエラー in vset_pos_om")
END
PRINT /X2,"ビジョン計測ＮＧ : v.err = ",v.err
SIGNAL ix_vcomm_error;                 エラー信号ＯＮ
GOTO end
ok:; 計測ＯＫの場合補正データ作成
$vres = "OK"
v.num = VAL($vst[1])
IF v.num>0 THEN
.vpos_x = VAL($vst[2])
.vpos_y = VAL($vst[3])
.vpos_t = 0
.vpos_t = VAL($vst[4])
v.result_no[1] = 1;          結果番号代入
POINT vision[1] = TRANS(.vpos_x,.vpos_y,0,.vpos_t); ビジョン座標値(mm)
;
IF .teach==OFF THEN;                 補正位置計算
.$cam = $ENCODE(/I1,v.cam_no);     カメラ番号文字列
.temp_tool = ZL3GET(LINKH1,.robot); 現在のツール値取得
POINT .tool_now = TRANS(,.temp_tool); ツール値作成
POINT .h = S_HERE(.robot)-.tool_now; ロボット計測位置(フランジ)
IF .handeye<>OFF THEN
.$chk = "vcam_tool["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
v.err = 5; キャリブレーションエラー
GOTO end;
END
IF .have==OFF THEN
POINT vwork[.id,1] = vcam_tool[v.cam_no]+vision[1]; ハンドアイカメラ把持あり・フランジから見たワーク位置
ELSE
POINT vwork[.id,1] = .h+vcam_tool[v.cam_no]+vision[1]; ハンドアイカメラ把持なし・ベースから見たワーク位置
END
ELSE
.$chk = "vision_frm["+.$cam+"]"
IF EXISTDATA(.$chk,T)==OFF THEN
v.err = 5; キャリブレーションエラー
GOTO end;
END
IF .have==OFF THEN
POINT vwork[.id,1] = -.h+vision_frm[v.cam_no]+vision[1]; 固定カメラ把持あり・フランジから見たワーク把持位置
ELSE
POINT vwork[.id,1] = vision_frm[v.cam_no]+vision[1]; 固定カメラ把持なし・ベースから見たワーク位置
END
END
vwork_res[.id,1] = v.result_no[1]; 結果番号
END
ELSE
IF recog0_err==1 THEN
v.err = 6
END
END
ELSE;                                      通信ＮＧ
$vres = $vcom_res
v.err = v.com_error
END
GOTO end
ng:; 受信データ異常の場合リトライ処理
v.error_cnt = v.error_cnt+1;               送受信エラーカウントアップ
$vres = "NG"
IF v.error_cnt>=vretry_max+3 THEN;         エラー回数確認
PRINT /X2,"リトライ回数上限エラー"
SIGNAL ix_vcomm_error;                   エラー信号ＯＮ
v.err = 30
GOTO end;                                リトライ回数上限超えの為終了
ELSE
PRINT /X2,"計測リトライ : "+$ENCODE(/I2,v.error_cnt)+" 回目"
SIGNAL -ix_vcomm_comp;                   通信完了信号ＯＦＦ
TWAIT vretry_wait;                       リトライ前待ち
SIGNAL ix_vcomm_start;                   通信開始信号ＯＮ
CALL vis_wait_tcp
GOTO start;                              通信完了待ち
END
end:
SIGNAL -ix_vcomm_comp;                     通信完了信号ＯＦＦ
.END
.PROGRAM vstr_decode(.$data)
; FUNCTION: 文字列データ分解(区切り文字 [,])
; NOTE    : ver1.0.0[12/10/18]
.$strings = .$data;                        文字列データ代入
IF .$strings=="" GOTO end;                 文字列データが無い為終了
.i = 0;                                    分解した個数クリア
DO;                                        条件ループ開始
$vst[.i] = $DECODE(.$strings,",",0);     ","までの文字列を取り出す
IF .$strings=="" GOTO end;               文字列データが無くなれば終了
.$temp = $DECODE(.$strings,",",1);       ","を取り出す
.i = .i+1;                               分解した個数カウントアップ
UNTIL .$strings=="";                       文字列データが無くなるまで
end:
vdecode_num = .i;                          分解した個数代入
.END
.PROGRAM wait_chg_sp(.rno,.sp,.ret)
;-------------------------------- 
;機能：速度変更確認
;引数：ロボット番号、動作速度(.sp)
;戻値：成否(±1%以内で成功)
;-------------------------------- 
.ret = err_no_error
UTIMER .@nowtime = 0
WHILE (1) DO
IF .rno==robot_slave THEN
IF debug.prt.cmd==TRUE THEN
PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED2),"---->TARGET_SP=",$ENCODE(.sp)
END
IF MSPEED2>.sp-1 AND MSPEED2<.sp+1 THEN
RETURN
END
ELSE
IF debug.prt.cmd==TRUE THEN
PRINT "wait_chg_sp() ROBOT.NO=",.rno,",WAITING CURRENT_SP->",$ENCODE(MSPEED),"---->TARGET_SP=",$ENCODE(.sp)
END
IF MSPEED>.sp-1 AND MSPEED<.sp+1 THEN
RETURN
END
END
IF UTIMER(.@nowtime)>0.1 THEN
.ret = err_chg_sp
RETURN
END
TWAIT ascycle
END
.END
